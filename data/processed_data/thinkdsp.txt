Think DSP Digital Signal Processing in Python Version 1.1.4 Think DSP Digital Signal Processing in Python Version 1.1.4 Allen B. Downey Green Tea Press Needham, Massachusetts Copyright c 2014 Allen B. Downey. Green Tea Press 9 Washburn Ave Needham MA 02492 Permission is granted to copy, distribute, and/or modify this document under the terms of the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License, which is available at http://creativecommons. org/licenses/by-nc-sa/4.0/ . The LATEX source for this book is available from http://think-dsp.com . Preface Signal processing is one of my favorite topics. It is useful in many areas of science and engineering, and if you understand the fundamental ideas, it provides insight into many things we see in the world, and especially the things we hear. But unless you studied electrical or mechanical engineering, you probably haven't had a chance to learn about signal processing. The problem is that most books (and the classes that use them) present the material bottom-up, starting with mathematical abstractions like phasors. And they tend to be theoretical, with few applications and little apparent relevance. The premise of this book is that if you know how to program, you can use that skill to learn other things, and have fun doing it. With a programming-based approach, I can present the most important ideas right away. By the end of the rst chapter, you can analyze sound recordings and other signals, and generate new sounds. Each chapter introduces a new technique and an application you can apply to real signals. At each step you learn how to use a technique rst, and then how it works. This approach is more practical and, I hope you'll agree, more fun. 0.1 Who is this book for? The examples and supporting code for this book are in Python. You should know core Python and you should be familiar with object-oriented features, at least using objects if not de ning your own. If you are not already familiar with Python, you might want to start with my other book, Think Python , which is an introduction to Python for people who have never programmed, or Mark Lutz's Learning Python , which might be better for people with programming experience. vi Chapter 0. Preface I use NumPy and SciPy extensively. If you are familiar with them already, that's great, but I will also explain the functions and data structures I use. I assume that the reader knows basic mathematics, including complex numbers. You don't need much calculus; if you understand the concepts of integration and di erentiation, that will do. I use some linear algebra, but I will explain it as we go along. 0.2 Using the code The code and sound samples used in this book are available from https: //github.com/AllenDowney/ThinkDSP . Git is a version control system that allows you to keep track of the les that make up a project. A collection of les under Git's control is called a \repository". GitHub is a hosting service that provides storage for Git repositories and a convenient web interface. The GitHub homepage for my repository provides several ways to work with the code: You can create a copy of my repository on GitHub by pressing the Fork button. If you don't already have a GitHub account, you'll need to create one. After forking, you'll have your own repository on GitHub that you can use to keep track of code you write while working on this book. Then you can clone the repo, which means that you copy the les to your computer. Or you could clone my repository. You don't need a GitHub account to do this, but you won't be able to write your changes back to GitHub. If you don't want to use Git at all, you can download the les in a Zip le using the button in the lower-right corner of the GitHub page. All of the code is written to work in both Python 2 and Python 3 with no translation. I developed this book using Anaconda from Continuum Analytics, which is a free Python distribution that includes all the packages you'll need to run the code (and lots more). I found Anaconda easy to install. By default it does a user-level installation, not system-level, so you don't need administrative privileges. And it supports both Python 2 and Python 3. You can download Anaconda from https://www.anaconda.com/distribution/ . If you don't want to use Anaconda, you will need the following packages: 0.2. Using the code vii NumPy for basic numerical computation, http://www.numpy.org/ ; SciPy for scienti c computation, http://www.scipy.org/ ; matplotlib for visualization, http://matplotlib.org/ . Although these are commonly used packages, they are not included with all Python installations, and they can be hard to install in some environments. If you have trouble installing them, I recommend using Anaconda or one of the other Python distributions that include these packages. Most exercises use Python scripts, but some also use Jupyter notebooks. If you have not used Jupyter before, you can read about it at http://jupyter.org . There are three ways you can work with the Jupyter notebooks: Run Jupyter on your computer If you installed Anaconda, you probably got Jupyter by default. To check, start the server from the command line, like this: $ jupyter notebook If it's not installed, you can install it in Anaconda like this: $ conda install jupyter When you start the server, it should launch your default web browser or create a new tab in an open browser window. Run Jupyter on Binder Binder is a service that runs Jupyter in a virtual machine. If you follow this link, http://mybinder.org/repo/ AllenDowney/ThinkDSP , you should get a Jupyter home page with the notebooks for this book and the supporting data and scripts. You can run the scripts and modify them to run your own code, but the virtual machine you run in is temporary. Any changes you make will disappear, along with the virtual machine, if you leave it idle for more than about an hour. View notebooks on nbviewer When we refer to notebooks later in the book, we will provide links to nbviewer, which provides a static view of the code and results. You can use these links to read the notebooks and listen to the examples, but you won't be able to modify or run the code, or use the interactive widgets. Good luck, and have fun! viii Chapter 0. Preface Contributor List If you have a suggestion or correction, please send email to downey@allendowney.com . If I make a change based on your feedback, I will add you to the contributor list (unless you ask to be omitted). If you include at least part of the sentence the error appears in, that makes it easy for me to search. Page and section numbers are ne, too, but not as easy to work with. Thanks! Before I started writing, my thoughts about this book bene ted from conversations with Boulos Harb at Google and Aurelio Ramos, formerly at Harmonix Music Systems. During the Fall 2013 semester, Nathan Lintz and Ian Daniher worked with me on an independent study project and helped me with the rst draft of this book. On Reddit's DSP forum, the anonymous user RamjetSoundwave helped me x a problem with my implementation of Brownian Noise. And andodli found a typo. In Spring 2015 I had the pleasure of teaching this material along with Prof. Oscar Mur-Miranda and Prof. Siddhartan Govindasamy. Both made many suggestions and corrections. Silas Gyger corrected an arithmetic error. Giuseppe Masetti sent a number of very helpful suggestions. Eric Peters sent many helpful suggestions. Special thanks to Freesound, which is the source of many of the sound samples I use in this book, and to the Freesound users who uploaded those sounds. I include some of their wave les in the GitHub repository for this book, using the original le names, so it should be easy to nd their sources. Unfortunately, most Freesound users don't make their real names available, so I can only thank them using their user names. Samples used in this book were contributed by Freesound users: iluppai, wc 10, thirsk, docquesting, kleeb, landup, zippi1, themusicalnomad, bcjordan, rockwehrmann, marcgascon7, jcveliz. Thank you all! Contents Preface v 0.1 Who is this book for? . . . . . . . . . . . . . . . . . . . . . . v 0.2 Using the code . . . . . . . . . . . . . . . . . . . . . . . . . . vi 1 Sounds and signals 1 1.1 Periodic signals . . . . . . . . . . . . . . . . . . . . . . . . . 2 1.2 Spectral decomposition . . . . . . . . . . . . . . . . . . . . . 3 1.3 Signals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 1.4 Reading and writing Waves . . . . . . . . . . . . . . . . . . . 7 1.5 Spectrums . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 1.6 Wave objects . . . . . . . . . . . . . . . . . . . . . . . . . . 8 1.7 Signal objects . . . . . . . . . . . . . . . . . . . . . . . . . . 9 1.8 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 2 Harmonics 13 2.1 Triangle waves . . . . . . . . . . . . . . . . . . . . . . . . . . 13 2.2 Square waves . . . . . . . . . . . . . . . . . . . . . . . . . . 16 2.3 Aliasing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 2.4 Computing the spectrum . . . . . . . . . . . . . . . . . . . . 19 2.5 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 x Contents 3 Non-periodic signals 23 3.1 Linear chirp . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 3.2 Exponential chirp . . . . . . . . . . . . . . . . . . . . . . . . 25 3.3 Spectrum of a chirp . . . . . . . . . . . . . . . . . . . . . . . 26 3.4 Spectrogram . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 3.5 The Gabor limit . . . . . . . . . . . . . . . . . . . . . . . . . 28 3.6 Leakage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 3.7 Windowing . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 3.8 Implementing spectrograms . . . . . . . . . . . . . . . . . . 32 3.9 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 4 Noise 37 4.1 Uncorrelated noise . . . . . . . . . . . . . . . . . . . . . . . 37 4.2 Integrated spectrum . . . . . . . . . . . . . . . . . . . . . . . 40 4.3 Brownian noise . . . . . . . . . . . . . . . . . . . . . . . . . 41 4.4 Pink Noise . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 4.5 Gaussian noise . . . . . . . . . . . . . . . . . . . . . . . . . . 46 4.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47 5 Autocorrelation 51 5.1 Correlation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 5.2 Serial correlation . . . . . . . . . . . . . . . . . . . . . . . . 54 5.3 Autocorrelation . . . . . . . . . . . . . . . . . . . . . . . . . 55 5.4 Autocorrelation of periodic signals . . . . . . . . . . . . . . . 56 5.5 Correlation as dot product . . . . . . . . . . . . . . . . . . . 60 5.6 Using NumPy . . . . . . . . . . . . . . . . . . . . . . . . . . 60 5.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 Contents xi 6 Discrete cosine transform 63 6.1 Synthesis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64 6.2 Synthesis with arrays . . . . . . . . . . . . . . . . . . . . . . 64 6.3 Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66 6.4 Orthogonal matrices . . . . . . . . . . . . . . . . . . . . . . 67 6.5 DCT-IV . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 6.6 Inverse DCT . . . . . . . . . . . . . . . . . . . . . . . . . . . 71 6.7 The Dct class . . . . . . . . . . . . . . . . . . . . . . . . . . 71 6.8 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73 7 Discrete Fourier Transform 75 7.1 Complex exponentials . . . . . . . . . . . . . . . . . . . . . . 76 7.2 Complex signals . . . . . . . . . . . . . . . . . . . . . . . . . 77 7.3 The synthesis problem . . . . . . . . . . . . . . . . . . . . . 78 7.4 Synthesis with matrices . . . . . . . . . . . . . . . . . . . . . 80 7.5 The analysis problem . . . . . . . . . . . . . . . . . . . . . . 82 7.6 Ecient analysis . . . . . . . . . . . . . . . . . . . . . . . . 83 7.7 DFT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84 7.8 The DFT is periodic . . . . . . . . . . . . . . . . . . . . . . 85 7.9 DFT of real signals . . . . . . . . . . . . . . . . . . . . . . . 86 7.10 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87 8 Filtering and Convolution 89 8.1 Smoothing . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89 8.2 Convolution . . . . . . . . . . . . . . . . . . . . . . . . . . . 91 8.3 The frequency domain . . . . . . . . . . . . . . . . . . . . . 93 8.4 The convolution theorem . . . . . . . . . . . . . . . . . . . . 94 8.5 Gaussian lter . . . . . . . . . . . . . . . . . . . . . . . . . . 95 xii Contents 8.6 Ecient convolution . . . . . . . . . . . . . . . . . . . . . . 97 8.7 Ecient autocorrelation . . . . . . . . . . . . . . . . . . . . 98 8.8 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100 9 Di erentiation and Integration 101 9.1 Finite di erences . . . . . . . . . . . . . . . . . . . . . . . . 101 9.2 The frequency domain . . . . . . . . . . . . . . . . . . . . . 102 9.3 Di erentiation . . . . . . . . . . . . . . . . . . . . . . . . . . 103 9.4 Integration . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106 9.5 Cumulative sum . . . . . . . . . . . . . . . . . . . . . . . . . 108 9.6 Integrating noise . . . . . . . . . . . . . . . . . . . . . . . . 111 9.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112 10 LTI systems 113 10.1 Signals and systems . . . . . . . . . . . . . . . . . . . . . . . 113 10.2 Windows and lters . . . . . . . . . . . . . . . . . . . . . . . 115 10.3 Acoustic response . . . . . . . . . . . . . . . . . . . . . . . . 116 10.4 Systems and convolution . . . . . . . . . . . . . . . . . . . . 119 10.5 Proof of the Convolution Theorem . . . . . . . . . . . . . . . 122 10.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124 11 Modulation and sampling 127 11.1 Convolution with impulses . . . . . . . . . . . . . . . . . . . 127 11.2 Amplitude modulation . . . . . . . . . . . . . . . . . . . . . 128 11.3 Sampling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131 11.4 Aliasing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134 11.5 Interpolation . . . . . . . . . . . . . . . . . . . . . . . . . . . 137 11.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139 Chapter 1 Sounds and signals Asignal represents a quantity that varies in time. That de nition is pretty abstract, so let's start with a concrete example: sound. Sound is variation in air pressure. A sound signal represents variations in air pressure over time. A microphone is a device that measures these variations and generates an electrical signal that represents sound. A speaker is a device that takes an electrical signal and produces sound. Microphones and speakers are called transducers because they transduce, or convert, signals from one form to another. This book is about signal processing, which includes processes for synthesizing, transforming, and analyzing signals. I will focus on sound signals, but the same methods apply to electronic signals, mechanical vibration, and signals in many other domains. They also apply to signals that vary in space rather than time, like elevation along a hiking trail. And they apply to signals in more than one dimension, like an image, which you can think of as a signal that varies in two-dimensional space. Or a movie, which is a signal that varies in two-dimensional space and time. But we start with simple one-dimensional sound. The code for this chapter is in chap01.ipynb , which is in the repository for this book (see Section 0.2). You can also view it at http://tinyurl.com/ thinkdsp01 . 2 Chapter 1. Sounds and signals 0.000 0.001 0.002 0.003 0.004 0.005 0.006 Time (s) +71.0 0.00.51.0 Figure 1.1: Segment from a recording of a bell. 1.1 Periodic signals We'll start with periodic signals , which are signals that repeat themselves after some period of time. For example, if you strike a bell, it vibrates and generates sound. If you record that sound and plot the transduced signal, it looks like Figure 1.1. This signal resembles a sinusoid , which means it has the same shape as the trigonometric sine function. You can see that this signal is periodic. I chose the duration to show three full repetitions, also known as cycles . The duration of each cycle, called the period , is about 2.3 ms. Thefrequency of a signal is the number of cycles per second, which is the inverse of the period. The units of frequency are cycles per second, or Hertz , abbreviated \Hz". (Strictly speaking, the number of cycles is a dimensionless number, so a Hertz is really a \per second"). The frequency of this signal is about 439 Hz, slightly lower than 440 Hz, which is the standard tuning pitch for orchestral music. The musical name of this note is A, or more speci cally, A4. If you are not familiar with \scienti c pitch notation", the numerical sux indicates which octave the note is in. A4 is the A above middle C. A5 is one octave higher. See http://en.wikipedia.org/ wiki/Scientific_pitch_notation . A tuning fork generates a sinusoid because the vibration of the tines is a form of simple harmonic motion. Most musical instruments produce periodic signals, but the shape of these signals is not sinusoidal. For example, Figure 1.2 shows 1.2. Spectral decomposition 3 0.001 0.002 0.003 0.004 0.005 0.006 0.007 Time (s) +1.3021.0 0.00.51.0 Figure 1.2: Segment from a recording of a violin. a segment from a recording of a violin playing Boccherini's String Quintet No. 5 in E, 3rd movement. Again we can see that the signal is periodic, but the shape of the signal is more complex. The shape of a periodic signal is called the waveform . Most musical instruments produce waveforms more complex than a sinusoid. The shape of the waveform determines the musical timbre , which is our perception of the quality of the sound. People usually perceive complex waveforms as rich, warm and more interesting than sinusoids. 1.2 Spectral decomposition The most important topic in this book is spectral decomposition , which is the idea that any signal can be expressed as the sum of sinusoids with di erent frequencies. The most important mathematical idea in this book is the discrete Fourier transform , orDFT , which takes a signal and produces its spectrum . The spectrum is the set of sinusoids that add up to produce the signal. And the most important algorithm in this book is the Fast Fourier transform , orFFT , which is an ecient way to compute the DFT. For example, Figure 1.3 shows the spectrum of the violin recording in Figure 1.2. The x-axis is the range of frequencies that make up the signal. The y-axis shows the strength or amplitude of each frequency component. 4 Chapter 1. Sounds and signals 0 2000 4000 6000 8000 10000 Frequency (Hz)05001000150020002500300035004000Amplitude Figure 1.3: Spectrum of a segment from the violin recording. The lowest frequency component is called the fundamental frequency . The fundamental frequency of this signal is near 440 Hz (actually a little lower, or \ at"). In this signal the fundamental frequency has the largest amplitude, so it is also the dominant frequency . Normally the perceived pitch of a sound is determined by the fundamental frequency, even if it is not dominant. The other spikes in the spectrum are at frequencies 880, 1320, 1760, and 2200, which are integer multiples of the fundamental. These components are called harmonics because they are musically harmonious with the fundamental: 880 is the frequency of A5, one octave higher than the fundamental. An octave is a doubling in frequency. 1320 is approximately E6, which is a perfect fth above A5. If you are not familiar with musical intervals like "perfect fth", see https: //en.wikipedia.org/wiki/Interval_(music) . 1760 is A6, two octaves above the fundamental. 2200 is approximately C ]7, which is a major third above A6. These harmonics make up the notes of an A major chord, although not all in the same octave. Some of them are only approximate because the notes that make up Western music have been adjusted for equal temperament (see http://en.wikipedia.org/wiki/Equal_temperament ). Given the harmonics and their amplitudes, you can reconstruct the signal by adding up sinusoids. Next we'll see how. 1.3. Signals 5 1.3 Signals I wrote a Python module called thinkdsp.py that contains classes and functions for working with signals and spectrums1. You will nd it in the repository for this book (see Section 0.2). To represent signals, thinkdsp provides a class called Signal , which is the parent class for several signal types, including Sinusoid , which represents both sine and cosine signals. thinkdsp provides functions to create sine and cosine signals: cos_sig = thinkdsp.CosSignal(freq=440, amp=1.0, offset=0) sin_sig = thinkdsp.SinSignal(freq=880, amp=0.5, offset=0) freq is frequency in Hz. ampis amplitude in unspeci ed units where 1.0 is de ned as the largest amplitude we can record or play back. offset is aphase o set in radians. Phase o set determines where in the period the signal starts. For example, a sine signal with offset=0 starts at sin 0, which is 0. With offset=pi/2 it starts at sin =2, which is 1. Signals have an __add__ method, so you can use the +operator to add them: mix = sin_sig + cos_sig The result is a SumSignal , which represents the sum of two or more signals. A Signal is basically a Python representation of a mathematical function. Most signals are de ned for all values of t, from negative in nity to in nity. You can't do much with a Signal until you evaluate it. In this context, \evaluate" means taking a sequence of points in time, ts, and computing the corresponding values of the signal, ys. I represent tsandysusing NumPy arrays and encapsulate them in an object called a Wave. A Wave represents a signal evaluated at a sequence of points in time. Each point in time is called a frame (a term borrowed from movies and video). The measurement itself is called a sample , although \frame" and \sample" are sometimes used interchangeably. Signal provides make_wave , which returns a new Wave object: wave = mix.make_wave(duration=0.5, start=0, framerate=11025) 1The plural of \spectrum" is often written \spectra", but I prefer to use standard English plurals. If you are familiar with \spectra", I hope my choice doesn't sound too strange. 6 Chapter 1. Sounds and signals 0.000 0.001 0.002 0.003 0.004 0.005 0.006 Time (s)1.5 0.00.51.01.5 Figure 1.4: Segment from a mixture of two sinusoid signals. duration is the length of the Wave in seconds. start is the start time, also in seconds. framerate is the (integer) number of frames per second, which is also the number of samples per second. 11,025 frames per second is one of several framerates commonly used in audio le formats, including Waveform Audio File (WAV) and mp3. This example evaluates the signal from t=0tot=0.5 at 5,513 equally-spaced frames (because 5,513 is half of 11,025). The time between frames, or timestep , is1/11025 seconds, about 91 s. Wave provides a plot method that uses pyplot . You can plot the wave like this: wave.plot() pyplot.show() pyplot is part of matplotlib ; it is included in many Python distributions, or you might have to install it. Atfreq=440 there are 220 periods in 0.5 seconds, so this plot would look like a solid block of color. To zoom in on a small number of periods, we can use segment , which copies a segment of a Wave and returns a new wave: period = mix.period segment = wave.segment(start=0, duration=period*3) period is a property of a Signal; it returns the period in seconds. start andduration are in seconds. This example copies the rst three periods frommix. The result is a Wave object. 1.4. Reading and writing Waves 7 If we plot segment , it looks like Figure 1.4. This signal contains two frequency components, so it is more complicated than the signal from the tuning fork, but less complicated than the violin. 1.4 Reading and writing Waves thinkdsp provides read_wave , which reads a WAV le and returns a Wave: violin_wave = thinkdsp.read_wave( input.wav ) AndWave provides write , which writes a WAV le: wave.write(filename= output.wav ) You can listen to the Wave with any media player that plays WAV les. On UNIX systems, I use aplay , which is simple, robust, and included in many Linux distributions. thinkdsp also provides play_wave , which runs the media player as a subprocess: thinkdsp.play_wave(filename= output.wav , player= aplay ) It usesaplay by default, but you can provide the name of another player. 1.5 Spectrums Wave provides make_spectrum , which returns a Spectrum : spectrum = wave.make_spectrum() AndSpectrum provides plot : spectrum.plot() Spectrum provides three methods that modify the spectrum: low_pass applies a low-pass lter, which means that components above a given cuto frequency are attenuated (that is, reduced in magnitude) by a factor. high_pass applies a high-pass lter, which means that it attenuates components below the cuto . band_stop attenuates components in the band of frequencies between two cuto s. This example attenuates all frequencies above 600 by 99%: 8 Chapter 1. Sounds and signals Wave Spectrum Signal Figure 1.5: Relationships among the classes in thinkdsp . spectrum.low_pass(cutoff=600, factor=0.01) A low pass lter removes bright, high-frequency sounds, so the result sounds mued and darker. To hear what it sounds like, you can convert the Spectrum back to a Wave, and then play it. wave = spectrum.make_wave() wave.play( temp.wav ) Theplay method writes the wave to a le and then plays it. If you use Jupyter notebooks, you can use make_audio , which makes an Audio widget that plays the sound. 1.6 Wave objects There is nothing very complicated in thinkdsp.py . Most of the functions it provides are thin wrappers around functions from NumPy and SciPy. The primary classes in thinkdsp are Signal, Wave, and Spectrum. Given a Signal, you can make a Wave. Given a Wave, you can make a Spectrum, and vice versa. These relationships are shown in Figure 1.5. A Wave object contains three attributes: ysis a NumPy array that contains the values in the signal; tsis an array of the times where the signal was evaluated or sampled; and framerate is the number of samples per unit of time. The unit of time is usually seconds, but it doesn't have to be. In one of my examples, it's days. Wave also provides three read-only properties: start ,end, andduration . If you modify ts, these properties change accordingly. To modify a wave, you can access the tsandysdirectly. For example: wave.ys *= 2 wave.ts += 1 The rst line scales the wave by a factor of 2, making it louder. The second line shifts the wave in time, making it start 1 second later. But Wave provides methods that perform many common operations. For example, the same two transformations could be written: 1.7. Signal objects 9 wave.scale(2) wave.shift(1) You can read the documentation of these methods and others at http:// greenteapress.com/thinkdsp.html . 1.7 Signal objects Signal is a parent class that provides functions common to all kinds of signals, likemake_wave . Child classes inherit these methods and provide evaluate , which evaluates the signal at a given sequence of times. For example, Sinusoid is a child class of Signal, with this de nition: class Sinusoid(Signal): def __init__(self, freq=440, amp=1.0, offset=0, func=np.sin): Signal.__init__(self) self.freq = freq self.amp = amp self.offset = offset self.func = func The parameters of __init__ are: freq : frequency in cycles per second, or Hz. amp: amplitude. The units of amplitude are arbitrary, usually chosen so 1.0 corresponds to the maximum input from a microphone or maximum output to a speaker. offset : indicates where in its period the signal starts; offset is in units of radians, for reasons I explain below. func : a Python function used to evaluate the signal at a particular point in time. It is usually either np.sin ornp.cos , yielding a sine or cosine signal. Like many init methods, this one just tucks the parameters away for future use. Signal provides make_wave , which looks like this: 10 Chapter 1. Sounds and signals def make_wave(self, duration=1, start=0, framerate=11025): n = round(duration * framerate) ts = start + np.arange(n) / framerate ys = self.evaluate(ts) return Wave(ys, ts, framerate=framerate) start andduration are the start time and duration in seconds. framerate is the number of frames (samples) per second. nis the number of samples, and tsis a NumPy array of sample times. To compute the ys,make_wave invokesevaluate , which is provided by Sinusoid : def evaluate(self, ts): phases = PI2 * self.freq * ts + self.offset ys = self.amp * self.func(phases) return ys Let's unwind this function one step at time: 1.self.freq is frequency in cycles per second, and each element of tsis a time in seconds, so their product is the number of cycles since the start time. 2.PI2is a constant that stores 2 . Multiplying by PI2converts from cycles to phase . You can think of phase as \cycles since the start time" expressed in radians. Each cycle is 2 radians. 3.self.offset is the phase when tists[0] . It has the e ect of shifting the signal left or right in time. 4. Ifself.func isnp.sin ornp.cos , the result is a value between  1 and 5. Multiplying by self.amp yields a signal that ranges from -self.amp to +self.amp . In math notation, evaluate is written like this: y=Acos(2ft+ 0) whereAis amplitude, fis frequency, tis time, and 0is the phase o set. It may seem like I wrote a lot of code to evaluate one simple expression, but as we'll see, this code provides a framework for dealing with all kinds of signals, not just sinusoids. 1.8. Exercises 11 1.8 Exercises Before you begin