Embedded ControllersEmbedded Controllers Using C and Arduino / 2EUsing C and Arduino / 2E James M. FioreJames M. Fiore Embedded Controllers 2 Embedded Controllers Using C and Arduino by James M. Fiore Version 2.1.11, 15 October 2024 Embedded Controllers 3 This Embedded Controllers Using C and Arduino, by James M. Fiore is copyright James M. Fiore, and released under the terms of a Creative Commons license: This work is freely redistributable for non-commercial use, share-alike with attribution Published by James M. Fiore via dissidents ISBN13: 978-1796854879 For more information or feedback, contact: James Fiore, Professor Emeritus oer@jimfiore.org jfiore@mvcc.edu For the latest revisions, related titles, and links to low cost print versions, go to: www.mvcc.edu/jfiore or my mirror sites www.dissidents.com and www.jimfiore.org YouTube Channel: Electronics with Professor Fiore Cover art by the author Embedded Controllers 4 Introduction This text is designed to introduce and expand upon material related to the C programming language and embedded controllers, and specifically, the Arduino development system and associated Atmel ATmega microcontrollers. It is intended to fit the time constraints of a typical 3 to 4 credit hour course for electrical engineering technology and computer engineering technology programs, although it could also fit the needs of a hardware-oriented course in computer science. As such, the text does not attempt to cover every aspect of the C language, the Arduino system or Atmel A VR microcontrollers. The first section deals with the C language itself. It is assumed that the student is a relative newcomer to the C language but has some experience with another high level language, for example, Python. This means concepts such as conditionals and iteration are already familiar and the student can get up and running fairly quickly. From there, the Arduino development environment is examined. Unlike the myriad Arduino books now available, this text does not simply rely on the Arduino libraries. As convenient as the libraries may be, there are other, sometimes far more efficient, ways of programming the boards. Many of the chapters examine library source code to see “what’s under the hood”. This more generic approach means it will be easier for the student to use other processors and development systems instead of being tightly tied to one platform. All Atmel schematics and data tables are derived from the published version of the Atmel 328P documentation which may be found at https://www.microchip.com/wwwproducts/en/ATMEGA328P This serves as the final word on the operation and performance of the 328P and all interested parties should become familiar with it. There is a companion laboratory manual to accompany this text. Other OER (Open Educational Resource) laboratory manuals in this series include Computer Programming with Python, and Science of Sound. OER texts and laboratory manuals are available for Operational Amplifiers & Linear Integrated Circuits, Semiconductor Devices, DC Electrical Circuit Analysis and AC Electrical Circuit Analysis. Please check my web sites for the latest versions. A Note from the Author This text was designed for our ABET accredited AAS program in Electrical Engineering Technology. Specifically, it is used in our second year embedded controllers course. I am indebted to my students, coworkers and the MVCC family for their support and encouragement of this project. While it would have been possible to seek a traditional publisher for this work, as a long-time supporter and contributor to freeware and shareware computer software, I have decided instead to release this using a Creative Commons non-commercial, share-alike license. I encourage others to make use of this manual for their own work and to build upon it. If you do add to this effort, I would appreciate a notification. “When things get so big, I don’t trust them at all You want some control-you gotta keep it small” - Peter Gabriel Embedded Controllers 5 Embedded Controllers 6 Table of Contents 1. Course Introduction ..... 8 2. C Memory Organization .... 10 3. C Language Basics ..... 14 4. C Language Basics II ..... 24 5. C Storage Types and Scope .... 32 6. C Arrays and Strings ..... 36 7. C Conditionals and Looping ... . 40 8. C Pointers and Addresses .... 48 9. C Look-Up Tables ..... 52 10. C Structures ...... 56 11. C Linked Lists* ...... 60 12. C Memory* ..... 64 13. C File I/O* ..... 68 14. C Command Line Arguments* ... 72 15. Embedded Programming .... 74 16. Hardware Architecture ..... 78 17. AVR ATmega 328P Overview** ... 84 18. Bits & Pieces: includes and defines ... 90 19. Bits & Pieces: Digital Output Circuitry ... 98 20. Bits & Pieces: Digital Input Circuitry ...102 21. Bits & Pieces: pinMode .....106 22. Bits & Pieces: digitalWrite ....112 23. Bits & Pieces: delay .....116 24. Bits & Pieces: digitalRead ....124 25. Bits & Pieces: Analog Input Circuitry ...132 26. Bits & Pieces: analogRead ....136 27. Bits & Pieces: analogWrite ....142 28. Bits & Pieces: Timer/Counters ....146 29. Bits & Pieces: Interrupts .....154 Appendices.......160 Index........165 * Included for language coverage but seldom used for small to medium scale embedded work. ** Including modest comic relief for film noir buffs. Embedded Controllers 7 1. Course Introduction 1.1 Overview This course introduces the C programming language and specifically addresses the issue of embedded programming. It is assumed that you have worked with some other high level language before, such as Python, BASIC, FORTRAN or Pascal. Due to the complexities of embedded systems, we begin with a typical desktop system and examine the structure of the language along with basic examples. Once we have a decent grounding in syntax, structure, and the development cycle, we switch over to an embedded system, namely an Arduino based development system. This course is designed so that you can do considerable work at home with minimal cost if you choose to (this is entirely optional, but programming these little beasties can be addicting so be forewarned). Along with this course text and the associated lab manual, you will need an Arduino Uno board (about $25) and a USB host cable. A small “wall wart” power adapter for it may also be useful. There’s a lot of free C programming info on the Internet but if you prefer print books and want more detail, you may also wish to purchase one of the many C programming texts available. Two good titles are Kochan’s book Programming in C and the one by Deitel & Deitel, C-How to Program. Whichever book you choose, make sure that its focus is C and not C++. You will also need a desktop C compiler. Just about any will do, including Visual C/C++, Borland, CodeWarrior, or even GCC. A couple of decent freeware compilers available on the Internet include Pelles C and Miracle C. 1.2 Frequently Asked Questions Why learn C language programming? C is perhaps the most widely used development language today. That alone is a good reason to consider it but there’s more: It is a modern structured language that has been standardized (ANSI). It is modular, allowing reuse of code. It is widely supported, allowing source code to be used for several different platforms by just recompiling for the new target. Its popularity means that several third-party add-ons (libraries and modules) are available to “stretch” the language. It has type checking which helps catch errors. It is very powerful, allowing you to get “close to the metal”. Generally, it creates very efficient code (small space and fast execution). What’s the difference between C and C++? C++ is a superset of C. First came C, then came C++. In fact, the name C++ is a programmer’s joke because ++ is the increment operator in C. Thus, C++ literally means “increment C”, or perhaps “give me the next C”. C++ does everything C does plus a whole lot more. These extra features don’t come free and embedded applications usually cannot afford the overhead. Consequently, although much Embedded Controllers 8 desktop work is done in C++ as well as C, most embedded work is done in C. Desktop development systems are usually referred to as C/C++ systems meaning that they’ll do both. Embedded development systems may be strictly C or even a variant of it (as is ours). Where can I buy an Arduino development board? The Arduino Uno board is available from a variety of sources including Digi-Key, Mouser, Parts Express and others. Shop around! What’s the difference between desktop PC development and embedded programming? Desktop development focuses on applications for desktop computers. These include things like word processors, graphing utilities, games, CAD programs, etc. These are the things most people think of when they hear the word “computer”. Embedded programming focuses on the myriad nearly invisible applications that surround us every day. Examples include the code that runs your microwave oven, automobile engine management system, cell phone, and many others. In terms of total units, embedded applications far outnumber desktop applications. You may have one or even a few PCs in your house but you probably use dozens of embedded applications every day. Embedded microcontrollers tend to be much less powerful but also much less expensive than their PC counterparts. The differing programming techniques are an integral part of this course and we shall spend considerable time examining them. How does C compare with Python? If, like many students taking this course, your background is with the Python language, you may find certain aspects of C a little odd at first. Some of it may seem overly complicated. Do not be alarmed though. The core of the language is actually simple. Python tends to hide things from the programmer while C doesn’t. Initially, this seems to make things more complicated, and it does for the most simple of programs, but for more complicated tasks C tends to cut to the heart of the matter. Many kinds of data and hardware manipulation are much more direct and efficient in C than in other languages. One practical consideration is that C is a compiled language while most versions of Python are essentially interpreted. This means that there is an extra step in the development cycle, but the resulting compiled program is much more efficient. We will examine why this is so a little later. How does C compare with assembly language? Assembly has traditionally been used when code space and speed are of utmost importance. Years ago, virtually all embedded work was done in assembly. As microcontrollers have increased in power and the C compilers have improved, the tables have turned. The downside of assembly now weighs against it. Assembly is processor-specific, unstructured, not standardized, nor particularly easy to read or write. C now offers similar performance characteristics to assembly but with all the advantages of a modern structured language. Embedded Controllers 9 2. C Memory Organization 2.1 Introduction When programming in C, it helps if you know at least a little about the internal workings of simple computer systems. As C tends to be “close to the metal”, the way in which certain things are performed as well preferred coding techniques will be more apparent. First off, let’s narrow the field a bit by declaring that we will only investigate a fairly simple system, the sort of thing one might see in an embedded application. That means a basic processor and solid state memory. We won’t worry about disk drives, monitors, and so forth. Specific details concerning controller architecture, memory hardware and internal IO circuitry are covered in later chapters. 2.2 Guts 101 A basic system consists of a control device called a CPU (central processing unit), microprocessor, or microcontroller. There are subtle distinctions between these but we have little need to go very deep at this point. Microcontrollers tend not to be as powerful as standard microprocessors in terms of processing speed but they usually have an array of input/output ports and hardware functions (such as analog-todigital or digital-to-analog converters) on chip that typical microprocessors do not. To keep things simple we shall use the term “processor” as a generic. Microprocessors normally are connected to external memory ( RAM chips). Microcontrollers generally contain sufficient on-board memory to alleviate this requirement but it is worthwhile to note that we are not talking about large (megabyte) quantities. A microcontroller may only contain a few hundred bytes of memory but in simple applications that may be sufficient. Remember, a byte of memory consists of 8 bits, each bit being thought of as a 1/0, high/low, yes/no, or true/false pair. In order for a processor to operate on data held in memory, the data must first be copied into a processor’s register (it may have dozens of registers). Only in a register can mathematical or logical operations be carried out. For example, if you desire to add one to a variable, the value of the variable must first be copied into a register. The addition is performed on the register contents yielding the answer. This answer is then copied back to the original memory location of the variable. It seems a little roundabout at first, but don’t worry, the C language compiler will take care of most of those details for you. 2.3 Memory Maps Every byte of memory in a computer system has an address associated with it. This is a requirement. Without an address, the processor has no way of identifying a specific location in memory. Generally, memory addressing starts at 0 and works its way up, although some addresses may be special or “reserved” in some systems. That is, a specific address might not refer to normal memory, but instead might refer to a certain input/output port for external communication. Very often it is useful to draw a memory map. This is nothing more than a huge array of memory slots. Some people draw them with the lowest (starting) address at the top and other people draw them with the lowest address at the bottom. Embedded Controllers 10 Here’s an example with just six bytes of memory: address 0 address 1 address 2 address 3 address 4 address 5 Figure 2.1, simple memory map Each address or slot represents a place we can store one byte. If we had to remember specific addresses we would be doing a lot of work. Instead, the C compiler will keep track of this for us. For example, if we declare a char named X, it might be at address 2. If we need to print that value, we don’t have to say “fetch the value at address 2”. Instead we say; “fetch the value of X” and the compiler generates code to make this work out to the proper address (2). This abstraction eases our mental burden considerably. As many variables require more than one byte, we may need to combine addresses to store a single value. For example, if we chose a short int, that needs two bytes. Suppose this variable starts at address 4. It will also require the use of address 5. When we access this variable the compiler automatically generates the code to utilize both addresses because it “knows” we’re using a short int. Our little six byte memory map could hold 6 char, 3 short int, 1 long int with 1 short int, 1 long int with 2 char, or some other similar combination. It cannot hold a double as that requires 8 bytes. Similarly, it could not hold an array of 4 or more short int (see Chapter Three for details on numeric data types). Arrays are of special interest as they must be contiguous in memory. For example, suppose a system has 1000 bytes of memory and a 200 element char array was declared. If this array starts at address 500 then all of the slots from 500 through 699 are allocated for the array. It cannot be created in “scattered” fashion with a few bytes here and a few bytes there. This requirement is due to the manner in which arrays are indexed (accessed), as we shall see later. 2.4 Stacks Many programs need only temporary storage for certain variables. That is, a variable may only be used for a limited time and then “thrown away”. It would be inefficient to allocate permanent space for this sort of variable. In its place, many systems use a stack. Ordinarily, an application is split into two parts, a code section and a data section. The data section contains the “permanent” (global) data. As these two will not consume the entire memory map, the remainder of the memory is often used for temporary storage via a stack. The stack starts at the opposite end of the memory map and grows toward the code and data sections. It is called a First-In-Last-Out stack or FILO stack. It works like a stack of trays in a cafeteria. The first tray placed on the stack will be the last one pulled off and vice versa. When temporary Embedded Controllers 11 variables are needed, this memory area is used. As more items are needed, more memory is taken up. As our code exits from a function, the temporary ( auto) variables declared there are no longer needed, and the stack shrinks. If we make many, many function calls with many, many declared variables, it is possible for the stack to overrun the code and data sections of our program. The system is now corrupt, and proper execution and functioning of the program are unlikely. address 0 area used by code and data area currently unused stack area, grows toward address 0 address 65,535 Figure 2.2, basic memory layout Above is a memory map example of a system with 64k bytes of memory (k=1024 or 210). Individual memory slots are not shown. Only the general areas are shown. It is worthwhile to note that in some systems, code and data are in a common area as shown (V on Neumann architecture) while in others they are physically split (Harvard architecture). Whether split or not, the basic concepts remain. So, why would we want to split the two areas, each accessed via its own memory bus1? Simple, separating the code and data allows the processor to fetch the next instruction (code) using a memory bus that is physically separate from the data bus it is currently accessing. A shared code/data memory bus would require special timing to coordinate this process as only one thing can be on the bus at any given time. Having two separate memory buses will speed execution times. 1 A bus typically refers to a collection of wires or connections upon which multiple data bits (or address bits) are sent as a group. Embedded Controllers Embedded Controllers 13 3. C Language Basics 3.1 Introduction C is a terse language. It is designed for professional programmers who need to do a lot with a little code quickly. Unlike BASIC or Python, C is a compiled language. This means that once you have written a program, it needs to be fed into a compiler that turns your C language instructions into machine code that the microprocessor or microcontroller can execute. This is an extra step, but it results in a more efficient program than an interpreter. An interpreter turns your code into machine language while it’s running, essentially a line at a time. This results in slower execution. Also, in order to run your program on another machine, that machine must also have an interpreter on it. You can think of a compiler as doing the translation all at once instead of a line at a time. Unlike many languages, C is not line oriented, but is instead free-flow. A program can be thought of as consisting of three major components: Variables, statements and functions. Variables are just places to hold things, as they are in any other language. They might be integers, floating point (real) numbers, or some other type. Statements include things such as variable operations and assignments (i.e., set x to 5 times y), tests (i.e., is x more than 10?), and so forth. Functions contain statements and may also call other functions. 3.2 Variable Naming, Types and Declaration Variable naming is fairly simple. Variable names are a combination of letters, numerals, and the underscore. Upper and lower case can be mixed and the length is typically 31 characters max, but the actual limit depends on the C compiler in use. Further, the variable name cannot be a reserved (key) word nor can it contain special characters such as . ; , * - and so on. So, legal names include things like x, volts, resistor7, or even I_Wanna_Go_Home_Now . C supports a handful of variable types. These include floating point or real numbers in two basic flavors: float, which is a 32 bit number, and double, which is a higher precision version using 64 bits. There are also a few integer types including char, which is 8 bits, short int, which is 16 bits, and long int, which is 32 bits. As char is 8 bits, it can hold 2 to the 8th combinations, or 256 different values. This is sufficient for a single ASCII character, hence the name. Similarly, a short int (or short, for short!) can hold 2 to the 16th combinations, or 65,536 values. chars and ints may be signed or unsigned (signed, allowing negative values, is the default). There is also a plain old int, which might be either 16 or 32 bits, depending on which is most efficient for the compiler (to be on the safe side, never use plain old int if the value might require more than 16 bits). Sometimes you might also come across special double long integers (also called long longs) that take up 8 bytes as well as 80 bit extended precision floats (as defined by the IEEE). Embedded Controllers 14 Here is a table to summarize the sizes and ranges of variables: Variable Type Bytes Used Minimum Maximum char 1−128 127 unsigned char 1 0 255 short int 2−32768 32767 unsigned short int 2 0 65535 long int 4≈ −2 billion≈ 2 billion unsigned long int 4 0≈ 4 billion float (6 significant digits)4± 1.2 E −38± 3.4 E +38 double (15 significant digits)8± 2.3 E −308± 1.7 E +308 Figure 3.1, numeric types and ranges C also supports arrays and compound data types. We shall examine these in a later segment. Variables must be declared before they are used. They cannot be created on a whim, so to speak, as they are in Python. A declaration consists of the variable type followed by the variable name, and optionally, an initial value. Multiple declarations are allowed. Here are some examples: char x; declares a signed 8 bit integer called x unsigned char y; declares an unsigned 8 bit integer called y short z, a; declares two signed 16 bit integers named z and a float b =1.0; declares a real number named b and sets its initial value to 1.0 Note that each of these declarations is followed with a semi-colon. The semi-colon is the C language way of saying “This statement ends here”. This means that you can be a little sloppy (or unique) in your way of dealing with spaces. The following are all equivalent and legal: float b = 1.0; float b=1.0; float b = 1.0 ; Embedded Controllers 15 3.3 Functions Functions use the same naming rules as variables. All functions use the same template that looks something like this: return_value function_name( function argument list ) statement(s) Figure 3.1, basic function template You might think of the function in the mathematical sense. That is, you give it some value(s) and it gives you back a value. For example, your calculator has a sine function. You send it an angle and it gives you back a value. In C, functions may have several arguments, not just one. They might not even have an argument. Also, C functions may return a value, but they don’t have to. The “guts” of the function are defined within the opening and closing brace pair {}. So, a function which takes two integers, x and y, as arguments, and returns a floating point value will look something like this: float my_function( int x, int y ) //...appropriate statements here... If the function doesn’t take or return values, the word void is used. If a function neither requires values nor returns a value, it would look like: void other_function( void ) //...appropriate statements here... This may appear to be extra fussy work at first, but the listing of data types makes a lot of sense because C has something called type checking. This means that if you try to send a function the wrong kind of variable, or even the wrong number of variables, the compiler will warn you that you’ve made a mistake! Thus if you try to send my_function() above two floats or three integers, the compiler will complain and save you a big headache during testing. All programs must have a place to start, and in C, program execution begins with a function called main. This does not have to be the first function written or listed, but all programs must have a function called main. Here’s our first program, found in Figure 3.2, following: Embedded Controllers 16 /* Our first program */ void main( void ) float x = 2.0; float y = 3.0; float z; z = x*y/(x+y); Figure 3.2, a simple program There is only one function here, main(). It takes no variables and returns nothing. What’s the other stuff? First, the /* */ pair denotes a comment2. Anything inside of the comment pair is ignored by the compiler. A C comment can stretch for many lines. Once inside the function, three variables are declared with two of them given initial values. Next, the variables x and y are multiplied together, divided by their sum, and assigned to z. As C is free-flow, an equivalent (but ugly) version is: /* Our first program */ void main(void){ float x=2.0;float y=3.0;float z;z=x*y/(x+y);} Figure 3.3, alternate format (to be avoided) This is the complete opposite of Python which has very rigid spacing and formatting rules. Now, suppose that this add, multiply, divide operation is something that you need to do a lot. We could split this off into a separate function. Our program now looks like Figure 3.4 on the following page: 2 C also allows // to denote a single line comment without the “backend pairing”. Embedded Controllers 17 /* Our second program */ float add_mult_div( float a, float b ) float answer; answer = a*b/(a+b); return( answer ); void main( void ) float x = 2.0; float y = 3.0; float z; z = add_mult_div( x, y ); Figure 3.4, program with separate function The new math function takes two floats as arguments and returns a float to the caller. The compiler sees the new function before it is used in main(), thus, it already “knows” that it should be sent two floats and that the return value must be assigned to a float. It is very important to note that the new math function uses different variable names ( a and b) from the caller (x and y). The variables in the new math function are really just place-holders. The values from the original call ( x and y) are copied to these new variables (a and b) and used within the new function. As they are copies, they can be altered without changing the original values of x and y. In this case, x and y are said to be local to the main() function while a and b are local to the add_mult_div() function. In other words, a isn’t visible from main() so you can’t accidentally alter it! Similarly, x isn’t visible from add_mult_div(), so you can’t accidentally alter it either. This is a positive boon when dealing with large programs using many variable names. While it’s not usually preferred, there are times when you want a variable to be known “everywhere”. These are called global items. You can make variables global by simply declaring them at the beginning of the program outside of the functions (i.e., right after that initial comment in our example). 3.4 Libraries The examples above are rather limited because, although they perform a calculation, we have no way of seeing the result! We need some way to print the answer to the computer screen. To do this, we rely on system functions and libraries. There are a series of libraries included with most C development systems to cover a variety of needs. Essentially, someone has already coded, tested and compiled a bunch of functions for you. You add these functions to your program through a process called linking. Linking simply combines your compiled code along with any required library code into a final executable program. For basic printouts, data input, and the like, we use the standard IO (Input/Output) library , or stdio for short. There is a function in this library named printf() for “print formatted”. So that the Embedded Controllers 18 compiler can do type checking, it must know something about this new function. We tell the compiler to look into a special file called a header file to find this information. Every library will have an associated header file (usually of the same name) and it will normally end with a .h file extension3. The compiler directive is called an include statement. // Our third program, this is an example of a single line comment #include <stdio.h> void main( void ) printf(“Hello world.\n”); Figure 3.5, program with library function call This program simply prints the message Hello world. to the screen. The backslash-n combo is a special formatting token that means add a new line (i.e., bring the cursor to the line below). If we did not add the #include directive, the compiler wouldn’t know anything about printf(), and would complain when we tried to use it. So, what’s in a header file? Well, among other things they contain function prototypes. The prototypes are nothing more than a template. You can create your own by cutting and pasting your function name with argument list and adding a semicolon to it. Here is the function prototype for our earlier math function: float add_mult_div( float a, float b ); You could make your own library of functions if you want. To use them, all you’d need is an appropriate include statement in your code, and remember to add