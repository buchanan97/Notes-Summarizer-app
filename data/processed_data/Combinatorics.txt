Combinatorics an upper-level introductory course in enumeration, graph theory , and design theory by Joy Morris University of Lethbridge Version 2.1.1 of March 2023 This book is offered under the Creative Commons license. (Attribution-NonCommercial-ShareAlike 2.0) Please send comments and corrections to: Joy .Morris@uleth.ca © 2014–2021 by Joy Morris. Some rights reserved. You are free to copy this book, to distribute it, to display it, and to make derivative works, under the following conditions: (1) Attribution. You must give the original author credit. (2) Noncommercial. You may not use this work for commercial purposes. (3) Share Alike. If you alter, transform, or build upon this work, you may distribute the resulting work only under a license identical to this one. — For any reuse or distribution, you must make clear to others the license terms of this work. Any of these conditions can be waived if you get permission from the copyright holder. Your fair use and other rights are in no way affected by the above. — This is a human-readable summary of the full license, which is available on-line at http://creativecommons.org/licenses/by-nc-sa/2.0/legalcode Contents Chapter 1. What is Combinatorics? 1 §1.1. Enumeration .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. 1 §1.2. Graph Theory -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - - -- - -- - -- - - -- - -- - -- - 2 §1.3. Ramsey Theory .. . .. . .. . .. . . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. 3 §1.4. Design Theory -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - - -- - -- - -- - - -- - -- - -- - 4 §1.5. Coding Theory .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . 4 Part I. Enumeration Chapter 2. Basic Counting T echniques 9 §2.1. The product rule .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . . 9 §2.2. The sum rule -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - - -- - -- - -- - 12 §2.3. Putting them together .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. . .. . . .. . .. . .. 14 §2.4. Summing up -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - - 17 Chapter 3. Permutations, Combinations, and the Binomial Theorem 19 §3.1. Permutations .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . . 19 §3.2. Combinations -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - - -- - -- - -- - 22 §3.3. The Binomial Theorem .. . .. . .. . .. . . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . . 26 Chapter 4. Bijections and Combinatorial Proofs 31 §4.1. Counting via bijections .. . .. . .. . .. . . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . . 31 §4.2. Combinatorial proofs -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - - -- 33 §4.3. The Arithmetic Triangle (Pascal’s Triangle) .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . . 39 Chapter 5. Counting with Repetitions 41 §5.1. Unlimited repetition .. . .. . .. . .. . . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . . 41 §5.2. Sorting a set that contains repetition -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- 44 Chapter 6. Induction and Recursion 49 §6.1. Recursively-defined sequences .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. . .. . . . 49 §6.2. Basic induction -- - -- - -- - -- - - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - - 51 §6.3. More advanced induction .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. 54 Chapter 7. Generating Functions 61 §7.1. What is a generating function? .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . 61 §7.2. The Generalised Binomial Theorem -- - -- - -- - -- - - -- - -- - - -- - -- - -- - - -- - -- - - 62 §7.3. Using generating functions to count things .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. 64 i ii Chapter 8. Generating Functions and Recursion 69 §8.1. Partial fractions .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. . .. . . .. . . 69 §8.2. Factoring polynomials -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- 71 §8.3. Using generating functions to solve recursively-defined sequences .. . .. . .. . .. . . 73 Chapter 9. Some Important Recursively-Defined Sequences 81 §9.1. Derangements .. . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . 81 §9.2. Catalan numbers -- - -- - -- - -- - - -- - -- - -- - - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - 82 §9.3. Bell numbers and exponential generating functions .. . .. . .. . . .. . .. . .. . . .. . .. . . 85 Chapter 10. Other Basic Counting T echniques 91 §10.1. The Pigeonhole Principle .. . .. . .. . .. . . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. 91 §10.2. Inclusion-Exclusion -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - - -- - - 97 Part II. Graph Theory Chapter 11. Basics of Graph Theory 107 §11.1. Background .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. . . 107 §11.2. Basic definitions, terminology, and notation -- - -- - -- - - -- - -- - -- - - -- - -- - -- - 108 §11.3. Subgraphs, complete graphs, and the Handshaking Lemma .. . .. . .. . . .. . .. . .. 111 §11.4. Isomorphism of graphs -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - - 114 §11.5. Random graphs .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. . .. . . .. . 119 Chapter 12. Moving through graphs 123 §12.1. Directed graphs .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. . .. . . .. . 123 §12.2. Walks and connectedness -- - -- - -- - -- - - -- - -- - -- - - -- - -- - - -- - -- - -- - - -- - -- 124 §12.3. Paths and cycles .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. 127 §12.4. Trees -- - -- - -- - -- - - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- 129 §12.5. Automorphisms of graphs .. . .. . .. . .. . . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . . 133 Chapter 13. Euler and Hamilton 139 §13.1. Euler tours and trails .. . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. 139 §13.2. Hamilton paths and cycles -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - - 143 Chapter 14. Graph Colouring 149 §14.1. Edge colouring .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . . 149 §14.2. Ramsey Theory -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - - -- - -- - 155 §14.3. Vertex colouring .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. . .. . . .. . 160 Chapter 15. Planar graphs 167 §15.1. Planar graphs .. . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. 167 §15.2. Euler’s Formula -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - - -- - -- - 173 §15.3. Map colouring .. . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. 177 iii Part III. Design Theory Chapter 16. Latin squares 185 §16.1. Latin squares and Sudokus .. . .. . .. . .. . . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . 185 §16.2. Mutually orthogonal Latin squares (MOLS) -- - -- - -- - - -- - -- - -- - - -- - -- - -- 187 §16.3. Systems of distinct representatives .. . .. . .. . .. . . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. 193 Chapter 17. Designs 199 §17.1. Balanced Incomplete Block Designs (BIBD) .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . 199 §17.2. Constructing designs, and existence of designs -- - -- - -- - - -- - -- - -- - - -- - -- - 203 §17.3. Fisher’s Inequality .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. . .. . . . 207 Chapter 18. More designs 211 §18.1. Steiner and Kirkman triple systems .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . . 211 §18.2.t-designs -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - - -- 216 §18.3. Aﬀine planes .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . 219 §18.4. Projective planes -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- 225 Chapter 19. Designs and Codes 227 §19.1. Introduction .. . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . . 227 §19.2. Error-correcting codes -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - - -- - -- - -- - - 228 §19.3. Using the generator matrix for encoding .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . 231 §19.4. Using the parity-check matrix for decoding -- - -- - -- - -- - - -- - -- - -- - - -- - -- - 233 §19.5. Codes from designs .. . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . . 238 Appendix A. Complex Numbers 241 Appendix B. Biographical Briefs 247 B.1. List of Entries .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . 248 B.2. Biographies -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - - -- - -- - -- - - -- - -- - -- - - - 250 iv Appendix C. Solutions to selected exercises 311 Solutions for Chapter 2 .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . . 311 Solutions for Chapter 3 -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - - 312 Solutions for Chapter 4 .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . . 313 Solutions for Chapter 5 -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - - 315 Solutions for Chapter 6 .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . . 316 Solutions for Chapter 7 -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - - 317 Solutions for Chapter 8 .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . . 319 Solutions for Chapter 9 -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - - 323 Solutions for Chapter 10 .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. . 324 Solutions for Chapter 11 -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - 325 Solutions for Chapter 12 .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. . 327 Solutions for Chapter 13 -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - 329 Solutions for Chapter 14 .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. . 330 Solutions for Chapter 15 -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - 333 Solutions for Chapter 16 .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. . 335 Solutions for Chapter 17 -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - 336 Solutions for Chapter 18 .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . .. . . .. . .. . . .. . .. . 338 Solutions for Chapter 19 -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - -- - - -- - -- - 343 Appendix D. List of Notation 347 Index 349 Chapter 1 What is Combinatorics? Combinatorics is a subfield of “discrete mathematics,” so we should begin by asking what discrete mathematics means. The differences are to some extent a matter of opinion, and various mathematicians might classify specific topics differently. “Discrete” should not be confused with “discreet,” which is a much more commonly-used word. They share the same Latin root, “discretio,” which has to do with wise discernment or separation. In the mathematical “discrete,” the emphasis is on separateness, so “discrete” is the opposite of “continuous.” If we are studying objects that can be separated and treated as a (generally countable) collection of units rather than a continuous structure, then this study falls into discrete mathematics. In calculus, we deal with continuous functions, so calculus is not discrete mathematics. In linear algebra, our matrices often have real entries, so linear algebra also does not fall into discrete mathematics. Text books on discrete mathematics often include some logic, as discrete mathematics is often used as a gateway course for upper-level math. Elementary number theory and set theory are also sometimes covered. Algorithms are a common topic, as algorithmic techniques tend to work very well on the sorts of structures that we study in discrete mathematics. In Combinatorics, we focus on combinations and arrangements of discrete structures. There are five major branches of combinatorics that we will touch on in this course: enumeration, graph theory, Ramsey Theory, design theory, and coding theory. (The related topic of cryptography can also be studied in combinatorics, but we will not touch on it in this course.) We will focus on enumeration, graph theory, and design theory, but will briefly introduce the other two topics. 1.1. Enumeration Enumeration is a big fancy word for counting. If you’ve taken a course in probability and statistics, you’ve already covered some of the techniques and problems we’ll be covering in this course. When a statistician (or other mathematician) is calculating the “probability” of a particular outcome in circumstances where all outcomes are equally likely, what they usually do is enumerate all possible outcomes, and then figure out how many of these include the outcome they are looking for. EXAMPLE 1.1.1. What is the probability of rolling a 3on a 6-sided die? SOLUTION. To figure this out, a mathematician would count the sides of the die (there are six) and count how many of those sides display a three (one of them). They would conclude that the probability of rolling a 3on a 6-sided die is 1/6(one in six). 2 1. What is Combinatorics? That was an example that you could probably figure out without having studied enumeration or probability, but it nonetheless illustrates the basic principle behind many calculations of probability. The object of enumeration is to enable us to count outcomes in much more complicated situations. This sometimes has natural applications to questions of probability, but our focus will be on the counting, not on the probability. After studying enumeration in this course, you should be able to solve problems such as: •If you are playing Texas Hold’em poker against a single opponent, and the two cards in your hand are a pair, what is the probability that your opponent has a higher pair? •How many distinct Shidokus ( 4-by-4Sudokus) are there? •How many different orders of five items can be made from a bakery that makes three kinds of cookies? •Male honeybees come from a queen bee’s unfertilised eggs, so have only one parent (a female). Female honeybees have two parents (one male, one female). Assuming all ancestors were distinct, how many ancestors does a male honeybee have from 10 generations ago? Although all of these questions (and many others that arise naturally) may be of interest to you, the reason we begin our study with enumeration is because we’ll be able to use many of the techniques we learn, to count the other structures we’ll be studying. 1.2. Graph Theory When a mathematician talks about graph theory, they are not referring to the “graphs” that you learn about in school, that can be produced by a spreadsheet or a graphing calculator. The “graphs” that are studied in graph theory are models of networks. Any network can be modeled by using dots to represent the nodes of the network (the cities, computers, cell phones, or whatever is being connected) together with lines to represent the connections between those nodes (the roads, wires, wireless connections, etc.). This model is called a graph. It is important to be aware that only at a node may information, traﬀic, etc. pass from one edge of a graph to another edge. If we want to model a highway network using a graph, and two highways intersect in the middle of nowhere, we must still place a node at that intersection. If we draw a graph in which edges cross over each other but there is no node at that point, you should think of it as if there is an overpass there with no exits from one highway to the other: the roads happen to cross, but they are not connecting in any meaningful sense. EXAMPLE 1.2.1. The following diagram: Fort Macleod Lethbridge Medicine HatCalgary Strathmore is a graph. Many questions that have important real-world applications can be modeled with graphs. These are not always limited to questions that seem to apply to networks. Some questions can be modeled as graphs by using lines to represent constraints or some other relationship between them (e.g. the nodes might represent classes, with a line between them if they cannot 1. What is Combinatorics? 3 be scheduled at the same time, or some nodes might represent students and others classes, with a line between a student and each of the classes they are taking). After studying graph theory in this course, you should be able to solve problems such as: •How can we find a good route for garbage trucks to take through a particular city? •Is there a delivery route that visits every city in a particular area, without repetition? •Given a collection of project topics and a group of students each of whom has expressed interest in some of the topics, is it possible to assign each student a unique topic that interests them? •A city has bus routes all of which begin and end at the bus terminal, but with different schedules, some of which overlap. What is the least number of buses (and drivers) required in order to be able to complete all of the routes according to the schedule? •Create a schedule for a round-robin tournament that uses as few time slots as possible. Some of these questions you may only be able to answer for particular kinds of graphs. Graph theory is a relatively “young” branch of mathematics. Although some of the problems and ideas that we will study date back a few hundred years, it was not until the 1930s that these individual problems were gathered together and a unified study of the theory of graphs began to develop. 1.3. Ramsey Theory Ramsey theory takes its name from Frank Plumpton Ramsey (1903—1930) , a British mathematician who died at the tragically young age of 26. Ramsey was a logician. A result that he considered a minor lemma in one of his logic papers now bears the name “Ramsey’s Theorem” and was the basis for this branch of mathematics. Its statement requires a bit of graph theory: given ccolours and fixed sizes n1,...,n c, there is an integerr=R(n1,...,n c)such that for any colouring the edges of of a complete graph on r vertices, there must be some ibetween 1andcsuch that there is a complete subgraph on ni vertices, all of whose edges are coloured with colour i. In addition to requiring some graph theory, that statement was a bit technical. In much less precise terms that don’t require so much background knowledge (but could be misleading in specific situations), Ramsey theory asserts that if a structure is big enough and contains a property we are interested in, then no matter how we cut it into (a limited number of) pieces, at least one of the pieces should also have that property. One major theorem in Ramsey theory is van der Waerden’s Theorem, which states that for any two constants candn, there is a constant V(c,n)such that if we take V(c,n)consecutive numbers and colour them with ccolours, there must be an arithmetic progression of length nall of whose members have been coloured with the same colour. EXAMPLE 1.3.1. Here is a small example of van der Waerden’s Theorem. With two colours and a desired length of 3for the arithmetic progression, we can show that V(2,3)>8using the following colouring: 3 4 5 6 7 8 9 10 (In case it is diﬀicult to see, we point out that 3,4,7, and 8are black, while 5,6,9, and 10 are grey, a different colour.) Notice that with eight consecutive integers, the difference in a three-term arithmetic progression cannot be larger than three. For every three-term arithmetic progression with difference of one, two, or three, it is straightforward to check that the numbers have not all received the same colour. In fact,V(2,3) = 9 , but proving this requires exhaustive testing. 4 1. What is Combinatorics? We will touch lightly on Ramsey theory in this course, specifically on Ramsey’s Theorem itself, in the context of graph theory. 1.4. Design Theory Like graph theory, design theory is probably not what any non-mathematician might expect from its name. When researchers conduct an experiment, errors can be introduced by many factors (including, for example, the timing or the subject of the experiment). It is therefore important to replicate the experiment a number of times, to ensure that these unintended variations do not account for the success of a particular treatment. If a number of different treatments are being tested, replicating all of them numerous times becomes costly and potentially infeasible. One way to reduce the total number of trials while still maintaining the accuracy, is to test multiple treatments on each subject, in different combinations. One of the major early motivations for design theory was this context: given a fixed number of total treatments, and a fixed number of treatments we are willing to give to any subject, can we find combinations of the possible treatments so that each treatment is given to some fixed number of subjects, and any pair of treatments is given together some fixed number of times (often just once). This is the basic structure of a block design. EXAMPLE 1.4.1. Suppose that we have seven different fertilisers and seven garden plots on which to try them. We can organise them so that each fertiliser is applied to three of the plots, each garden plot receives three fertilisers, and any pair of fertilisers is used together on precisely one of the plots. If the different fertilisers are numbered one through seven, then a method for arranging them is to place fertilisers 1,2, and 3on the first plot; 1,4, and 5on the second; 1, 6, and 7on the third; 2,4, and 6on the fourth; 2,5, and 7on the fifth; 3,4, and 7on the sixth; and 3,5, and 6on the last. Thus, 123 145 167 246 257 347 is a design. This basic idea can be generalised in many ways, and the study of structures like these is the basis of design theory. In this course, we will learn some facts about when designs exist, and how to construct them. After studying design theory in this course, you should be able to solve problems such as: •Is it possible for a design to exist with a particular set of parameters? •What methods might we use in trying to construct a design? 1.5. Coding Theory In many people’s minds “codes” and “cryptography” are inextricably linked, and they might be hard-pressed to tell you the difference. Nonetheless, the two topics are vastly different, as is the mathematics involved in them. Coding theory is the study of encoding information into different symbols. When someone uses a code in an attempt to make a message that only certain other people can read, this becomes cryptography. Cryptographers study strategies for ensuring that a code is diﬀicult to “break” for those who don’t have some additional information. In coding theory, we ignore the question of who has access to the code and how secret it may be. Instead, one of the primary concerns becomes our ability to detect and correct errors in the code. 1. What is Combinatorics? 5 Codes are used for many purposes in which the information is not intended to be secret. For example, computer programs are transformed into long strings of binary data, that a computer reinterprets as instructions. When you text a photo to a friend, the pixel and colour information are converted into binary data to be transmitted through radio waves. When you listen to an audio file, the sound frequencies of the music have been converted into binary data that your computer decodes back into sound frequencies. Electronic encoding is always subject to interference, which can cause errors. Even when a coded message is physically etched onto a device (such as a dvd), scratches can make some parts of the code illegible. When you are connected to the internet (for example, if you are streaming), wifi signals can fail, suffer interference from other nearby networks, or become overloaded. Any of these problems can cause your connection to lose or misread part of the data that is being transmitted. People don’t like it when their movies, music, or apps freeze, crash, or skip over something. This can become even more problematic if it happens during an important online meeting or class, or while you are making an electronic financial transaction. To avoid this problem, engineers use codes that allow our devices to automatically detect, and correct, minor errors that may be introduced. In coding theory, we learn how to create codes that allow for error detection and correction, without requiring excessive memory or storage capacity. Although coding theory is not a focus of this course, designs can be used to create good codes. We will learn how to make codes from designs, and what makes these codes “good.” EXAMPLE 1.5.1. Suppose we have a string of binary information, and we want the computer to store it so we can detect if an error has arisen. There are two symbols we need to encode: 0 and 1. If we just use 0as the code for indicating 0and 1as the code for 1, we’ll never know if a bit has been flipped (from 0to1or vice versa). If we use 00for0and 01for1, then if the first bit gets flipped we’ll know there was an error (because the first bit should never be 1), but we won’t notice if the second was flipped. If we use 00for0and 11for1, then we will be able to detect an error, as long as at most one bit gets flipped, because flipping one bit of either code word will result in either 01or10, neither of which is a valid code word. Thus, this code allows us to detect an error. It does not allow us to correct an error, because even knowing that a single bit has been flipped, there is no way of knowing whether a 10arose from a 00with the first bit flipped, or from a 11with the second bit flipped. We would need a longer code to be able to correct errors. After our study of coding theory, you should be able to solve problems such as: •Given a code, how many errors can be detected? •Given a code, how many errors can be corrected? •Construct some small codes that allow detection and correction of small numbers of errors. EXERCISE 1.5.2. Can you come up with an interesting counting problem that you wouldn’t know how to solve? 6 1. What is Combinatorics? SUMMARY: •enumeration •graph theory •Ramsey theory •design theory •coding theory Part I Enumeration Chapter 2 Basic Counting Techniques When we are trying to count the number of ways in which something can happen, sometimes the answer is very obvious. For example, if a doughnut shop has five different kinds of doughnuts for sale and you are planning to buy one doughnut, then you have five choices. There are some ways in which the situation can become slightly more complicated. Perhaps you haven’t decided whether you’ll buy a doughnut or a bagel, and the store also sells three kinds of bagels. Or perhaps you want a cup of coffee to go with your doughnut, and there are four different kinds of coffee, each of which comes in three different sizes. These particular examples are fairly small and straightforward, and you could list all of the possible options if you wished. The goal of this chapter is to use simple examples like these to demonstrate two rules that allow us to count the outcomes not only in these situations, but in much more complicated circumstances. These rules are the product rule , and the sum rule . 2.1. The product rule The product rule is a rule that applies when we there is more than one variable (i.e. thing that can change) involved in determining the final outcome. EXAMPLE 2.1.1. Consider the example of buying coffee at a coffee shop that sells four varieties and three sizes. When you are choosing your coffee, you need to choose both variety and size. One way of figuring out how many choices you have in total, would be to make a table. You could label the columns with the sizes, and the rows with the varieties (or vice versa, it doesn’t matter). Small Medium Large Latte small latte medium latte large latte Mocha small mocha medium mocha large mocha Espresso small espresso medium espresso large espresso Cappuccino small cappuccino medium cappuccino large cappuccino As you can see, a different combination of variety and size appears in each entry of the table, and every possible combination of variety and size appears somewhere. Thus the total number of possible choices is the number of entries in this table. Although in a small example like this we could simply count all of the entries and see that there are twelve, it will be more useful to notice that elementary arithmetic tells us that the number of entries in t