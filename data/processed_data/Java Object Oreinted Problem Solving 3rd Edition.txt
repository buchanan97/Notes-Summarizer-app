Java, Java, Java Object-Oriented Problem Solving Third Edition R. Morelli and R. Walde Trinity College Hartford, CT June 25, 2017 This work is licensed under a Creative Commons Attribution 4.0 International License (CC BY 4.0). This book was previously published by Pearson Education, Inc. Preface to the Open Source Edition Java, Java, Java, 3e was previously published by Pearson Education, Inc. The Ô¨Årst edition (2000) and the second edition (2003) were published by Prentice-Hall. In 2010 Pearson Education, Inc. reassigned the copyright to the authors, and we are happy now to be able to make the book available under an open source license. This PDF edition of the book is available under a Creative Commons Attribution 4.0 International License, which allows the book to be used, modiÔ¨Åed, and shared with attribution: (https://creativecommons.org/licenses/by/4.0/). ‚Äì Ralph Morelli and Ralph Walde ‚Äì Hartford, CT ‚Äì December 30, 2016 i ii Preface to the Third Edition We have designed this third edition of Java, Java, Java to be suitable for a typical Introduction to Computer Science (CS1) course or for a slightly more advanced Java as a Second Language course. This edition retains the ‚Äúobjects Ô¨Årst‚Äù approach to programming and problem solving that was characteristic of the Ô¨Årst two editions. Throughout the text we emphasize careful coverage of Java language features, introductory programming concepts, and object-oriented design principles. The third edition retains many of the features of the Ô¨Årst two editions, including: Early Introduction of Objects Emphasis on Object Oriented Design (OOD) UniÔ¨Åed Modeling Language (UML) Diagrams Self-study Exercises with Answers Programming, Debugging, and Design Tips. From the Java Library Sections Object-Oriented Design Sections End-of-Chapter Exercises Companion Web Site, with Power Points and other Resources The In the Laboratory sections from the Ô¨Årst two editions have been moved onto the book‚Äôs Companion Web Site. Table 1 shows the Table of Contents for the third edition. What‚Äôs New in the Third Edition The third edition has the following substantive changes: Although the book retains its emphasis on a ‚Äúrunning example‚Äù that is revisited in several chapters, the CyberPet examples have been replaced with a collection of games and puzzle examples. The CyberPet examples from earlier editions will be available on the Companion Web Site. iii iv Table 1: Table of Contents for the Third Edition. Chapter Topic Chapter 0 Computers, Objects, and Java (revised) Chapter 1 Java Program Design and Development Chapter 2 Objects: DeÔ¨Åning, Creating, and Using Chapter 3 Methods: Communicating with Objects (revised) Chapter 4 Input/Output: Designing the User Interface (new) Chapter 5 Java Data and Operators Chapter 6 Control Structures Chapter 7 Strings and String Processing Chapter 8 Inheritance and Polymorphism (new) Chapter 9 Arrays and Array Processing Chapter 10 Exceptions: When Things Go Wrong Chapter 11 Files and Streams Chapter 12 Recursive Problem Solving Chapter 13 Graphical User Interfaces Chapter 14 Threads and Concurrent Programming Chapter 15 Sockets and Networking (expanded) Chapter 16 Data Structures: Lists, Stacks, and Queues (revised and expanded) Chapters 0 (Computers, Objects, and Java) and 1 (Java Program Design and Development) have been substantially reorganized and rewritten. The new presentation is designed to reduce the pace with which new concepts are introduced. The treatment of objectoriented (OO) and UML concepts has also been simpliÔ¨Åed, and some of the more challenging OO topics, such as polymorphism, have been moved to a new Chapter 8. The new Java 1.5 Scanner class is introduced in Chapter 2 and is used to perform simple input operations. Chapter 4 (Input/Output: Designing the User Interface) has been completely written. Rather than relying primarily on applet interfaces, as in the second edition, this new chapter provides independent introductions to both a command-line interface and a graphical user interface (GUI). Instructors can choose the type of interface that best suits their teaching style. The command-line interface is based on the BufferedReader class and is used throughout the rest of the text. The GUI is designed to work with either graphical applications or applets. Both approaches are carefully presented to highlight the fundamentals of user-interface design. The chapter concludes with an optional section that introduces Ô¨Åle I/O using the newScanner class. Much of the discussion of inheritance and polymorphism, which was previously woven through the Ô¨Årst Ô¨Åve chapters in the second edition, has been integrated into a new Chapter 8. An optional graphics track is woven throughout the text. Beginning with simple examples in Chapters 1 and 2, this track also includes v some of the examples that were previously presented in Chapter 10 of the second edition. Chapter 15, on Sockets and Networking, is expanded to cover some of the more advanced Java technologies that have emerged, including servlets and Java Server Pages. Chapter 16, on Data Structures, has been refocused on how to use data structures. It makes greater use of Java‚Äôs Collection Framework, including the LinkedList andStack classes and the List interface. It has been expanded to cover some advanced data structures, such as sets, maps, and binary search trees. The Essentials Edition AnEssentials Edition of the third edition, which will include Chapters 012, will be published as a separate title. The Essentials Edition will cover those topics (Chapters 0-9) that are covered in almost all introductory (CS1) courses, but it will also include topics (Exceptions, File I/O, and Recursion) that many CS1 instructors have requested. Why Start with Objects? The Third Edition still takes an objects-early approach to teaching Java, with the assumption that teaching beginners the ‚Äúbig picture‚Äù early gives them more time to master the principles of object-oriented programming. This approach seems now to have gained in popularity as more and more instructors have begun to appreciate the advantages of the object-oriented perspective. Object Orientation (OO) is a fundamental problem solving and design concept, not just another language detail that should be relegated to the middle or the end of the book (or course). If OO concepts are introduced late, it is much too easy to skip over them when push comes to shove in the course. The Ô¨Årst time I taught Java in our CS1 course I followed the same approach I had been taking in teaching C and C++ ‚Äî namely, start with the basic language features and structured programming concepts and then, somewhere around midterm, introduce object orientation. This approach was familiar, for it was one taken in most of the textbooks then available in both Java and C++. One problem with this approach was that many students failed to get the big picture. They could understand loops, if-else constructs, and arithmetic expressions, but they had difÔ¨Åculty decomposing a programming problem into a well-organized Java program. Also, it seemed that this procedural approach failed to take advantage of the strengths of Java‚Äôs object orientation. Why teach an object-oriented language if you‚Äôre going to treat it like C or Pascal? I was reminded of a similar situation that existed when Pascal was the predominant CS1 language. Back then the main hurdle for beginners was procedural abstraction ‚Äî learning the basic mechanisms of procedure call vi and parameter passing and learning how to design programs as a collection of procedures. Oh! Pascal! , my favorite introductory text, was typical of a ‚Äúprocedures early‚Äù approach. It covered procedures and parameters in Chapter 2, right after covering the assignment and I/O constructs in Chapter 1. It then covered program design and organization in Chapter 3. It didn‚Äôt get into loops, if-else, and other structured programming concepts until Chapter 4 and beyond. Today, the main hurdle for beginners is the concept of object abstraction . Beginning programmers must be able to see a program as a collection of interacting objects and must learn how to decompose programming problems into well-designed objects. Object orientation subsumes both procedural abstraction and structured programming concepts from the Pascal days. Teaching objects-early takes a top-down approach to these three important concepts. The sooner you begin to introduce objects and classes, the better the chances that students will master the important principles of object orientation. Java is a good language for introducing object orientation. Its object model is better organized than C++. In C++ it is easy to ‚Äúwork around‚Äù or completely ignore OO features and treat the language like C. In Java there are good opportunities for motivating the discussion of object orientation. For example, it‚Äôs almost impossible to discuss GUI-based Java applications without discussing inheritance and polymorphism. Thus rather than using contrived examples of OO concepts, instructors can use some of Java‚Äôs basic features ‚Äî the class library, Swing and GUI components ‚Äî to motivate these discussions in a natural way. Organization of the Text The book is still organized into three main parts. Part I (Chapters 0-4) introduces the basic concepts of object orientation and the basic features of the Java language. Part II (Chapters 5-9) focuses on remaining language elements, including data types, control structures, string and array processing, and inheritance and polymorphism. Part III (Chapters 10-16) covers advanced topics, including exceptions, Ô¨Åle I/O, recursion, GUIs, threads and concurrent programming, sockets and networking, data structures, servlets, and Java Server Pages. The Ô¨Årst two parts make up the topics that are typically covered in an introductory CS1 course. The chapters in Part III are self-contained and can be selectively added to the end of a CS1 course if time permits. The Ô¨Årst part (Chapters 0 through 4) introduces the basic concepts of object orientation, including objects, classes, methods, parameter passing, information hiding, and a little taste of inheritance, and polymorphism. The primary focus in these chapters is on introducing the basic idea that an object-oriented program is a collection of objects that communicate and cooperate with each other to solve problems. Java language elements are introduced as needed to reinforce this idea. Students are given the basic building blocks for constructing Java programs from scratch. Although the programs in the Ô¨Årst few chapters have limited functionality in terms of control structures and data types, the priority is placed vii Table 2: A one-semester course. Weeks Topics Chapters 1 Object Orientation, UML Chapter 0 Program Design and Development Chapter 1 2-3 Objects and Class DeÔ¨Ånitions Chapter 2 Methods and Parameters Chapter 3 Selection structure (if-else) 4 User Interfaces and I/O Chapter 4 5 Data Types and Operators Chapter 5 6‚Äì7 Control Structures (Loops) Chapter 6 Structured Programming 8 String Processing (loops) Chapter 7 9 Inheritance and Polymorphism Chapter 8 10 Array Processing Chapter 9 11 Recursion Chapter 12 12 Advanced Topic (Exceptions) Chapter 10 13 Advanced Topic (GUIs) Chapter 11 Advanced Topic (Threads) Chapter 15 on how objects are constructed and how they interact with each other through method calls and parameter passing. The second part (Chapters 5 through 9) focuses on the remaining language elements, including data types and operators (Chapter 5), control structures (Chapter 6), strings (Chapter 7), and arrays (Chapter 9). It also provides thorough coverage of inheritance and polymorphism, the primary mechanisms of object orientation: (Chapter 8). Part three (Chapters 10 through 16) covers a variety of advanced topics (Table 1). Topics from these chapters can be used selectively depending on instructor and student interest. Throughout the book, key concepts are introduced through simple, easy-to-grasp examples. Many of the concepts are used to create a set of games, which are used as a running example throughout the text. Our pedagogical approach focuses on design. Rather than starting of with language details, programming examples are carefully developed with an emphasis on the principles of object-oriented design. Table2 provides an example syllabus from our one-semester CS1 course. Our semester is 13 weeks (plus one reading week during which classes do not meet). We pick and choose from among the advanced topics during the last two weeks of the course, depending on the interests and skill levels of the students. Ralph Morelli June 25, 2017 viii Contents 0 Computers, Objects, and Java 1 0.1 Welcome . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 0.2 What Is a Computer? . . . . . . . . . . . . . . . . . . . . . . . 2 0.3 Networks, the Internet and the World Wide Web . . . . . . . 4 0.4 Why Study Programming? . . . . . . . . . . . . . . . . . . . . 6 0.5 Programming Languages . . . . . . . . . . . . . . . . . . . . 7 0.6 Why Java? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 0.7 What Is Object-Oriented Programming? . . . . . . . . . . . . 11 1 Java Program Design and Development 23 1.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 1.2 Designing Good Programs . . . . . . . . . . . . . . . . . . . . 24 1.3 Designing a Riddle Program . . . . . . . . . . . . . . . . . . . 26 1.4 Java Language Elements . . . . . . . . . . . . . . . . . . . . . 34 1.5 Editing, Compiling, and Running a Java Program . . . . . . 48 1.6 From the Java Library: System and PrintStream . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 2 Objects: Using, Creating, and DeÔ¨Åning 61 2.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 2.2 Using String Objects . . . . . . . . . . . . . . . . . . . . . . 62 2.3 Drawing Shapes with a Graphics Object (Optional) . . . . 66 2.4 Class DeÔ¨Ånition . . . . . . . . . . . . . . . . . . . . . . . . . . 69 2.5 CASE STUDY: Simulating a Two-Person Game . . . . . . . . 76 2.6 From the Java Library: java.util.Scanner . . . . . . . . . 90 3 Methods: Communicating with Objects 101 3.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102 3.2 Passing Information to an Object . . . . . . . . . . . . . . . . 102 3.3 Constructor Methods . . . . . . . . . . . . . . . . . . . . . . . 109 3.4 Retrieving Information from an Object . . . . . . . . . . . . . 114 3.5 Passing a Value and Passing a Reference . . . . . . . . . . . . 118 3.6 Flow of Control: Control Structures . . . . . . . . . . . . . . . 121 3.7 Testing an Improved OneRowNim . . . . . . . . . . . . . . . . 130 3.8 From the Java Library java.lang.Object . . . . . . . . . 135 3.9 Object-Oriented Design: Inheritance and Polymorphism . . 136 3.10 Drawing Lines and DeÔ¨Åning Graphical Methods (Optional) 138 4 Input/Output: Designing the User Interface 149 4.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150 ix x CONTENTS 4.2 The User Interface . . . . . . . . . . . . . . . . . . . . . . . . . 150 4.3 A Command-Line Interface . . . . . . . . . . . . . . . . . . . 151 4.4 A Graphical User Interface (GUI) . . . . . . . . . . . . . . . . 160 4.5 Case Study: The One Row Nim Game . . . . . . . . . . . . . 176 4.6 From the Java Library: java.io.File and File Input (Optional) . . . . . . . . . . . . . . . . . . . . . 183 5 Java Data and Operators 197 5.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198 5.2 Boolean Data and Operators . . . . . . . . . . . . . . . . . . . 199 5.3 Numeric Data and Operators . . . . . . . . . . . . . . . . . . 205 5.4 From the Java Library java.lang.Math . . . . . . . . . . . 216 5.5 Numeric Processing Examples . . . . . . . . . . . . . . . . . 217 5.6 From the Java Library java.text.NumberFormat . . . . . . . . . . . . . . . . . . 229 5.7 Character Data and Operators . . . . . . . . . . . . . . . . . . 231 5.8 Example: Character Conversions . . . . . . . . . . . . . . . . 235 5.9 Problem Solving = Representation + Action . . . . . . . . . . 237 6 Control Structures 241 6.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242 6.2 Flow of Control: Repetition Structures . . . . . . . . . . . . . 242 6.3 Counting Loops . . . . . . . . . . . . . . . . . . . . . . . . . . 243 6.4 Example: Car Loan . . . . . . . . . . . . . . . . . . . . . . . . 252 6.5 Graphics Example: Drawing a Checkerboard . . . . . . . . . 255 6.6 Conditional Loops . . . . . . . . . . . . . . . . . . . . . . . . 259 6.7 Example: Computing Averages . . . . . . . . . . . . . . . . . 266 6.8 Example: Data Validation . . . . . . . . . . . . . . . . . . . . 270 6.9 Principles of Loop Design . . . . . . . . . . . . . . . . . . . . 270 6.10 The switch Multiway Selection Structure . . . . . . . . . . . 273 6.11 OBJECT-ORIENTED DESIGN: Structured Programming . . . . . . . . . . . . . . . . . . . . . 277 7 Strings and String Processing 297 7.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 298 7.2 String Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . 298 7.3 Finding Things Within a String . . . . . . . . . . . . . . . . . 304 7.4 Example: Keyword Search . . . . . . . . . . . . . . . . . . . . 306 7.5 From the Java Library: java.lang.StringBuffer . . . . . . . . . 308 7.6 Retrieving Parts of Strings . . . . . . . . . . . . . . . . . . . . 310 7.7 Example: Processing Names and Passwords . . . . . . . . . 312 7.8 Processing Each Character in a String . . . . . . . . . . . . 313 7.9 Comparing Strings . . . . . . . . . . . . . . . . . . . . . . . . 317 7.10 From the Java Library: java.util.StringTokenizer . . . . . . . . . . . . . . . . . . . . . 323 7.11 Handling Text in a Graphics Context (Optional) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324 8 Inheritance and Polymorphism 337 8.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 338 8.2 Java‚Äôs Inheritance Mechanism . . . . . . . . . . . . . . . . . . 338 CONTENTS xi 8.3 Abstract Classes, Interfaces, and Polymorphism . . . . . . . . . . . . . . . . . . . . . . . . 347 8.4 Example: A Toggle Button . . . . . . . . . . . . . . . . . . . . 353 8.5 Example: The Cipher Class Hierarchy . . . . . . . . . . . . . 357 8.6 Case Study: A Two Player Game Hierarchy . . . . . . . . . . 363 8.7 Principles Of Object-Oriented Design . . . . . . . . . . . . . 384 9 Arrays and Array Processing 393 9.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 394 9.2 One-Dimensional Arrays . . . . . . . . . . . . . . . . . . . . . 394 9.3 Simple Array Examples . . . . . . . . . . . . . . . . . . . . . 401 9.4 Example: Counting Frequencies of Letters . . . . . . . . . . . 403 9.5 Array Algorithms: Sorting . . . . . . . . . . . . . . . . . . . . 406 9.6 Array Algorithms: Searching . . . . . . . . . . . . . . . . . . 414 9.7 Two-Dimensional Arrays . . . . . . . . . . . . . . . . . . . . . 417 9.8 Multidimensional Arrays (Optional) . . . . . . . . . . . . . . 426 9.9 OBJECT-ORIENTED DESIGN: Polymorphic Sorting (Optional) . . . . . . . . . . . . . . . . . 428 9.10 From the Java Library: java.util.Vector . . . . . . . . . . . . . 430 9.11 Case Study: An N-Player Computer Game . . . . . . . . . . 431 9.12 A GUI-Based Game (Optional Graphics) . . . . . . . . . . . . 437 10 Exceptions: When Things Go Wrong 459 10.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 460 10.2 Handling Exceptional Conditions . . . . . . . . . . . . . . . . 460 10.3 Java‚Äôs Exception Hierarchy . . . . . . . . . . . . . . . . . . . 462 10.4 Handling Exceptions Within a Program . . . . . . . . . . . . 466 10.5 Error Handling and Robust Program Design . . . . . . . . . . . . . . . . . . . . . . . . . . 477 10.6 Creating and Throwing Your Own Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487 10.7 From the Java Library: JOptionPane . . . . . . . . . . . . . 489 11 Files and Streams: Input/Output Techniques 499 11.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 500 11.2 Streams and Files . . . . . . . . . . . . . . . . . . . . . . . . . 500 11.3 CASE STUDY: Reading and Writing Text Files . . . . . . . . 505 11.4 The File Class . . . . . . . . . . . . . . . . . . . . . . . . . . 518 11.5 Example: Reading and Writing Binary Files . . . . . . . . . . 521 11.6 Object Serialization: Reading and Writing Objects . . . . . . 530 11.7 From the Java Library javax.swing.JFileChooser . . . . . . . . . . . . . . . . 535 11.8 Using File Data in Programs . . . . . . . . . . . . . . . . . . . 536 12 Recursive Problem Solving 545 12.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 546 12.2 Recursive DeÔ¨Ånition . . . . . . . . . . . . . . . . . . . . . . . 549 12.3 Recursive String Methods . . . . . . . . . . . . . . . . . . . . 551 12.4 Recursive Array Processing . . . . . . . . . . . . . . . . . . . 563 12.5 Example: Drawing (Recursive) Fractals . . . . . . . . . . . . 569 xii CONTENTS 12.6 OBJECT-ORIENTED DESIGN: Tail Recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . 573 12.7 OBJECT-ORIENTED DESIGN: Recursion or Iteration? . . . . . . . . . . . . . . . . . . . . . . 574 12.8 From the Java Library: javax.swing.JComboBox . . . . . . . . . . . . . . . . . . . . . 577 13 Graphical User Interfaces 591 13.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 592 13.2 Java GUIs: From AWT to Swing . . . . . . . . . . . . . . . . . 592 13.3 The Swing Component Set . . . . . . . . . . . . . . . . . . . . 595 13.4 OBJECT-ORIENTED DESIGN: Model-View-Controller Architecture . . . . . . . . . . . . . . 596 13.5 The Java Event Model . . . . . . . . . . . . . . . . . . . . . . 598 13.6 CASE STUDY: Designing a Basic GUI . . . . . . . . . . . . . 602 13.7 Containers and Layout Managers . . . . . . . . . . . . . . . . 614 13.8 Checkboxes, Radio Buttons, and Borders . . . . . . . . . . . 620 13.9 Menus and Scroll Panes . . . . . . . . . . . . . . . . . . . . . 629 14 Threads and Concurrent Programming 643 14.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 644 14.2 What Is a Thread? . . . . . . . . . . . . . . . . . . . . . . . . . 644 14.3 From the Java Library: java.lang.Thread . . . . . . . . . 648 14.4 Thread States and Life Cycle . . . . . . . . . . . . . . . . . . . 654 14.5 Using Threads to Improve Interface Responsiveness . . . . . . . . . . . . . . . . 656 14.6 CASE STUDY: Cooperating Threads . . . . . . . . . . . . . . 664 14.7 CASE STUDY: The Game of Pong . . . . . . . . . . . . . . . . 679 15 Sockets and Networking 693 15.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 694 15.2 An Overview of Networks . . . . . . . . . . . . . . . . . . . . 694 15.3 Using Multimedia Network Resources for a Graphical Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 700 15.4 From the Java Library: java.net.URL . . . . . . . . . . . . 701 15.5 The Slide Show Program . . . . . . . . . . . . . . . . . . . . . 704 15.6 Adding Text Network Resources for an Application . . . . . . . . . . . . . . . . . . . . . . . . . . . . 708 15.7 Client/Server Communication via Socket s . . . . . . . . . . 719 15.8 CASE STUDY: Generic Client/Server Classes . . . . . . . . . 724 15.9 Playing One Row Nim Over the Network . . . . . . . . . . . 732 15.10Java Network Security Restrictions . . . . . . . . . . . . . . . 741 15.11Java Servlets and Java Server Pages . . . . . . . . . . . . . . . 742 16 Data Structures: Lists, Stacks, and Queues 757 16.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 758 16.2 The Linked List Data Structure . . . . . . . . . . . . . . . . . 758 16.3 OBJECT-ORIENTED DESIGN: The List Abstract Data Type (ADT) . . . . . . . . . . . . . . . 770 16.4 The Stack ADT . . . . . . . . . . . . . . . . . . . . . . . . . . . 776 16.5 The Queue ADT . . . . . . . . . . . . . . . . . . . . . . . . . . 778 CONTENTS xiii 16.6 From the Java Library: The Java Collections Framework and Generic Types . . . . . . . . . . . . . . . . . . . . . . . . 782 16.7 Using the Set andMap Interfaces . . . . . . . . . . . . . . . 785 16.8 The Binary Search Tree Data Structure . . . . . . . . . . . . . 789 A Coding Conventions 801 B The Java Development Kit 809 C The ASCII and Unicode Character Sets 819 D Java Keywords 821 E Operator Precedence Hierarchy 823 F Java Inner Classes 825 G Java Autoboxing and Enumeration 831 H Java and UML Resources 837 xiv CONTENTS OBJECTIVES After studying this chapter, you will Understand basic computer terminology that will be used throughout the book. Become familiar with the notion of programming. Understand why Java is a good introductory programming language. Become familiar with Java objects and classes. Know some of the principles of the object-oriented programming approach. OUTLINE 0.1 Welcome 0.2 What Is a Computer? Special Topic: Processors Then and Now 0.3 Networks, the Internet and the World Wide Web 0.4 Why Study Programming? 0.5 Programming Languages 0.6 Why Java? 0.7 What Is Object-Oriented Programming? Chapter Summary ExercisesChapter 0 Computers, Objects, and Java 2 CHAPTER 0Computers, Objects, and Java 0.1 Welcome Welcome to Java, Java, Java , a book that introduces you to object-oriented programming using the Java language. When considering the purpose of this text, three important questions might come to mind: Why study programming? Why study Java? What is object-oriented programming? This chapter will address these questions. First, we provide a brief introduction to computers and the Internet and World Wide Web (WWW). Then, we address why someone would study programming and we examine types of programming languages. We introduce the Java programming language and conclude the chapter by exploring object-oriented programming principles and how Java is an object-oriented programming language. 0.2 What Is a Computer? Acomputer is a machine that performs calculations and processes information. A computer works under the control of a computer program, a set of instructions that tell a computer what to do. Hardware refers to the electronic and mechanical components of a computer. Software refers to the programs that control the hardware. Ageneral-purpose computer of the sort that we will be programming can store many different programs in its memory. That is what gives it the ability to perform a wide variety of functions, from word processing to browsing the Internet. This is in contrast to a special-purpose computer , such as the one that resides in your microwave oven or the one that controls your digital watch or calculator. These types of computers contain control programs that are Ô¨Åxed and cannot be changed. A computer‚Äôs hardware is organized into several main subsystems or components (Fig. 1). Figure 1: A diagram of the main functional components in a computer system. The arrows indicate the Ô¨Çow of information between various components. Secondary StorageMain Memory Input Devices Keyboard Mouse Optical ScannerOutput Devices Printer Monitor Audio SpeakersCentral Processing Unit (CPU) Disk Drive CD-ROM DVD Output devices provide a means by which information held in the computer can be displayed in some understandable or usable form. Common output devices include printers, monitors, and audio speakers. SECTION 0.2What Is a Computer? 3 Input devices bring data and information into the computer. Some of the more common input devices are the keyboard, mouse, microphone, and scanner. Primary memory ormain memory of a computer is used to store both data and programs. This type of memory, which is often called RAM , short for Random Access Memory , is built entirely out of electronic components‚Äîintegrated circuit chips‚Äîwhich makes it extremely fast. A computer‚Äôs main memory is volatile , which means that any information stored in it is lost when the computer‚Äôs power is turned off. In a sense, main memory acts as the computer‚Äôs scratch pad, storing both programs and data temporarily while a program is running. Secondary storage devices are used for long-term or permanent storage of relatively large amounts of information. These devices include hard drives or magnetic disks, compact disks (CDs), digital video disks (DVDs), and magnetic tapes. All of these devices are non-volatile , meaning that they retain information when the computer‚Äôs power is turned off. Compared to a computer‚Äôs primary memory, these devices are relatively slow. The central processing unit (CPU) is the computer‚Äôs main engine. The CPU is the computer‚Äôs microprocessor , such as the Intel Pentium processor, which serves as the foundation for most Windows PCs, or the Power-PC processor, which serves as the foundation for Macintosh computers. The CPU is designed to perform the fetch-execute cycle ,Fetch-execute cycle whereby it repeatedly gets the next machine instruction from memory and executes it. Under the direction of computer programs (software), the CPU issues signals that control the other components that make up the computer system. One portion of the CPU, known as the arithmeticlogic unit (ALU) , performs all calculations, such as addition and subtraction, and all logical comparisons, such as when one piece of data is compared to another to determine if they are equal. There are two main types of software: Application software refers to programs designed to provide a particular task or service, such as word processors, computer games, spreadsheet programs, and Web browsers. System software includes programs that perform the basic operations that make a computer usable. For example, an important piece of system software is the operating system , which contains programs that manage the data stored on the computer‚Äôs disks. An operating system assists application software in perfo