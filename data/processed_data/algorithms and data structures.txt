Algorithms and Data Structures With Applications to Graphics and Geometry This book is licensed under a Creative Commons Attribution 3.0 License Algorithms and Data Structures With Applications to Graphics and Geometry Jurg Nievergelt Klaus Hinrichs Copyright © 2011 Jurg Nievergelt Editor-In-Chief: Jurg Nievergelt Associate Editor: Marisa Drexel Ulrich Editorial Assistants: Jon Durden, Tessa Greenleaf, Kristyna Mauch Selph, Ernesto Serrano For any questions about this text, please email: drexel@uga.edu The Global Text Project is funded by the Jacobs Foundation, Zurich, Switzerland. This book is licensed under a Creative Commons Attribution 3.0 License . Algorithms and Data Structures 2 A Global Text Table of Contents Part I: Programming environments for motion, graphics, and geometry ................................. 7 1. Reducing a task to given primitives: programming motion ................................................... 9 A robot car, its capabilities, and the task to be performed .............................................................................. 9 Wall-following algorithm described informally ............................................................................................. 10 Algorithm specified in a high-level language .................................................................................................. 11 Algorithm programmed in the robot's language ............................................................................................ 12 The robot's program optimized ...................................................................................................................... 12 2. Graphics primitives and environments ................................................................................. 14 Turtle graphics: a basic environment ............................................................................................................. 14 QuickDraw: a graphics toolbox ...................................................................................................................... 16 A graphics frame program .............................................................................................................................. 19 3. Algorithm animation ............................................................................................................. 24 Computer-driven visualization: characteristics and techniques ................................................................... 24 A gallery of algorithm snapshots .................................................................................................................... 27 Part II: Programming concepts: beyond notation .................................................................... 33 4. Algorithms and programs as literature: substance and form .............................................. 34 Programming in the large versus programming in the small ........................................................................ 34 Documentation versus literature: is it meant to be read? .............................................................................. 35 Pascal and its dialects: lingua franca of computer science ............................................................................ 40 5. Divide-and-conquer and recursion ....................................................................................... 45 An algorithmic principle ................................................................................................................................. 45 Divide-and-conquer expressed as a diagram: merge sort ............................................................................. 46 Recursively defined trees ................................................................................................................................ 47 Recursive tree traversal .................................................................................................................................. 49 Recursion versus iteration: the Tower of Hanoi ............................................................................................ 50 The flag of Alfanumerica: an algorithmic novel on iteration and recursion ................................................. 52 6. Syntax..................................................................................................................................... 53 Syntax and semantics ..................................................................................................................................... 53 Grammars and their representation: syntax diagrams and EBNF ................................................................ 54 An overly simple syntax for simple expressions ............................................................................................. 57 Parenthesis-free notation for arithmetic expressions .................................................................................... 59 7. Syntax analysis ....................................................................................................................... 62 The role of syntax analysis .............................................................................................................................. 62 Syntax analysis of parenthesis-free expressions by counting ........................................................................ 63 Analysis by recursive descent ......................................................................................................................... 64 Turning syntax diagrams into a parser .......................................................................................................... 65 Part III: Objects, algorithms, programs .................................................................................... 67 8. Truth values, the data type 'set', and bit acrobatics ............................................................. 69 Bits and boolean functions ............................................................................................................................. 69 Swapping and crossovers: the versatile exclusive-or ..................................................................................... 70 The bit sum or "population count" .................................................................................................................. 71 9. Ordered sets........................................................................................................................... 78 Sequential search............................................................................................................................................ 78 Binary search.................................................................................................................................................. 79 In-place permutation ...................................................................................................................................... 82 10. Strings .................................................................................................................................. 87 Recognizing a pattern consisting of a single string ........................................................................................ 87 Recognizing a set of strings: a finite-state-machine interpreter ................................................................... 88 11. Matrices and graphs: transitive closure ............................................................................... 93 This book is licensed under a Creative Commons Attribution 3.0 License Paths in a graph.............................................................................................................................................. 93 Boolean matrix multiplication ....................................................................................................................... 94 Warshall's algorithm ....................................................................................................................................... 95 Minimum spanning tree in a graph ................................................................................................................ 97 12. Integers............................................................................................................................... 100 Operations on integers ................................................................................................................................. 100 The Euclidean algorithm .............................................................................................................................. 102 The prime number sieve of Eratosthenes ..................................................................................................... 103 Large integers............................................................................................................................................... 104 Modular number systems: the poor man's large integers ............................................................................ 105 Random numbers.......................................................................................................................................... 107 13. Reals.................................................................................................................................... 110 Floating-point numbers ................................................................................................................................ 110 Some dangers................................................................................................................................................. 112 Horner's method............................................................................................................................................ 113 Bisection........................................................................................................................................................ 114 Newton's method for computing the square root ......................................................................................... 115 14. Straight lines and circles ..................................................................................................... 119 Intersection.................................................................................................................................................... 119 Clipping......................................................................................................................................................... 122 Drawing digitized lines ................................................................................................................................. 123 The riddle of the braiding straight lines ....................................................................................................... 126 Digitized circles ............................................................................................................................................. 131 Part IV: Complexity of problems and algorithms ................................................................... 134 15. Computability and complexity ........................................................................................... 135 Models of computation: the ultimate RISC .................................................................................................. 135 Almost nothing is computable ...................................................................................................................... 138 The halting problem is undecidable ............................................................................................................. 139 Computable, yet unknown ............................................................................................................................ 140 Multiplication of complex numbers ............................................................................................................. 142 Complexity of matrix multiplication ............................................................................................................ 142 16. The mathematics of algorithm analysis ............................................................................. 146 Growth rates and orders of magnitude ......................................................................................................... 146 Asymptotics................................................................................................................................................... 147 Summation formulas .................................................................................................................................... 148 Recurrence relations ..................................................................................................................................... 150 Asymptotic performance of divide-and-conquer algorithms ....................................................................... 153 Permutations................................................................................................................................................. 154 Trees.............................................................................................................................................................. 155 17. Sorting and its complexity .................................................................................................. 158 What is sorting? How difficult is it? ............................................................................................................. 158 Types of sorting algorithms .......................................................................................................................... 160 Simple sorting algorithms that work in time Θ(n2) ..................................................................................... 163 A lower bound Ω(n · log n) ............................................................................................................................ 165 Quicksort....................................................................................................................................................... 166 Analysis for three cases: best, "typical", and worst ...................................................................................... 169 Is it possible to sort in linear time? ............................................................................................................... 174 Sorting networks........................................................................................................................................... 174 Part V: Data structures ............................................................................................................. 179 18. What is a data structure? ................................................................................................... 180 Data structures old and new ......................................................................................................................... 180 Algorithms and Data Structures 4 A Global Text The range of data structures studied ............................................................................................................ 181 Performance criteria and measures .............................................................................................................. 182 19. Abstract data types ............................................................................................................. 184 Concepts: What and why? ............................................................................................................................ 184 Stack.............................................................................................................................................................. 185 First-in-first-out queue ................................................................................................................................. 189 Priority queue............................................................................................................................................... 190 Dictionary...................................................................................................................................................... 191 20. Implicit data structures ..................................................................................................... 196 What is an implicit data structure? .............................................................................................................. 196 Array storage................................................................................................................................................. 197 Implementation of the fixed-length fifo queue as a circular buffer ............................................................ 202 Implementation of the fixed-length priority queue as a heap ..................................................................... 205 Heapsort ...................................................................................................................................................... 209 21. List structures ..................................................................................................................... 211 Lists, memory management, pointer variables ............................................................................................ 211 The fifo queue implemented as a one-way list ............................................................................................ 214 Tree traversal................................................................................................................................................ 214 Binary search trees....................................................................................................................................... 223 Height-balanced trees .................................................................................................................................. 228 22. Address computation ........................................................................................................ 239 Concepts and terminology ............................................................................................................................ 239 The special case of small key domains ........................................................................................................ 240 The special case of perfect hashing: table contents known a priori ............................................................ 241 Conventional hash tables: collision resolution ........................................................................................... 242 Choice of hash function: randomization ...................................................................................................... 246 Performance analysis .................................................................................................................................. 248 Extendible hashing ...................................................................................................................................... 249 A virtual radix tree: order-preserving extendible hashing .......................................................................... 251 23. Metric data structures ....................................................................................................... 254 Organizing the embedding space versus organizing its contents ................................................................ 254 Radix trees, tries .......................................................................................................................................... 255 Quadtrees and octtrees ................................................................................................................................ 255 Spatial data structures: objectives and constraints ...................................................................................... 257 The grid file................................................................................................................................................... 259 Simple geometric objects and their parameter spaces ................................................................................ 263 Region queries of arbitrary shape ................................................................................................................ 264 Evaluating region queries with a grid file .................................................................................................... 267 Interaction between query processing and data access ............................................................................... 267 Part VI: Interaction between algorithms and data structures: case studies in geometric computation................................................................................................................................ 271 24. Sample problems and algorithms ..................................................................................... 272 Geometry and geometric computation ......................................................................................................... 272 Convex hull: a multitude of algorithms ........................................................................................................ 273 The uses of convexity: basic operations on polygons ................................................................................... 277 Visibility in the plane: a simple algorithm whose analysis is not ................................................................ 279 25. Plane-sweep: a general-purpose algorithm for two-dimensional problems illustrated using line segment intersection .......................................................................................................... 286 The line segment intersection test ............................................................................................................... 286 The skeleton: Turning a space dimension into a time dimension .............................................................. 288 Data structures............................................................................................................................................. 288 This book is licensed under a Creative Commons Attribution 3.0 License Updating the y-table and detecting an intersection .................................................................................... 289 Sweeping across intersections ..................................................................................................................... 290 Degenerate configurations, numerical errors, robustness ........................................................................... 291 26. The closest pair .................................................................................................................. 293 The problem.................................................................................................................................................. 293 Plane-sweep applied to the closest pair problem ......................................................................................... 294 Implementation............................................................................................................................................ 295 Analysis......................................................................................................................................................... 297 Sweeping in three or more dimensions ....................................................................................................... 298 Algorithms and Data Structures 6 A Global Text Part I: Programming environments for motion, graphics, and geometry Part I of this text book will discuss: •simple programming environments •program design •informal versus formal notations •reducing a solution to primitive operations, and programming as an activity independent of language. The purpose of an artificial programming environment A program can be designed with the barest of tools, paper and pencil, or in the programmer's head. In the realm of such informal environments, a program design may contain vague concepts expressed in an informal notation. Before he or she can execute this program, the programmer needs a programming environment , typically a complex system with many distinct components: a computer and its operating system, utilities, and program libraries; text and program editors; various programming languages and their processors. Such real programming environments force programmers to express themselves in formal notations. Programming is the realization of a solution to a problem, expressed in terms of those operations provided by a given programming environment. Most programmers work in environments that provide very powerful operations and tools. The more powerful a programming environment, the simpler the programming task, at least to the expert who has achieved mastery of this environment. Even an experienced programmer may need several months to master a new programming environment, and a novice may give up in frustration at the multitude of concepts and details he or she must understand before writing the simplest program. The simpler a programming environment, the easier it is to write and run small programs, and the more work it is to write substantial, useful programs. In the early days of computing, before the proliferation of programming languages during the 1960s, most programmers worked in environments that were exceedingly simple by modern standards: Acquaintance with an assembler, a loader, and a small program library sufficed. The programs they wrote were small compared to what a professional programmer writes today. The simpler a programming environment is, the better suited it is for learning to program. Alas, today simple environments are hard to find! Even a home computer is equipped with complex software that is not easily ignored or bypassed. For the sake of education it is useful to invent artificial programming environments. Their only purpose is to illustrate some important concepts in the simplest possible setting and to facilitate insight. Part I of this book introduces such a toy This book is licensed under a Creative Commons Attribution 3.0 License programming environment suitable for programming graphics and motion, and illustrates how it can gradually be enriched to approach a simple but useful graphics environment. Textbooks on computer graphics. The computer-driven graphics screen is a powerful new medium for communication. Visualization often makes it possible to present the results of a computation in intuitively appealing ways that convey insights not easily gained in any other manner. To exploit this medium, every programmer must master basic visualization techniques. We refer the reader interested in a systematic introduction to computer graphics to such excellent textbooks as [BG 89], [FDFH 90], [NS 79], [Rog 85], [Wat 89], and [Wol 89]. Algorithms and Data Structures 8 A Global Text This book is licensed under a Creative Commons Attribution 3.0 License 1. Reducing a task to given primitives: programming motion Learning objectives: •primitives for specifying motion •expressing an algorithm in informal notations and in high- and low-level programming languages •program verification •program optimization A robot car, its capabilities, and the task to be performed Some aspects of programming can be learned without a computer, by inventing an artificial programming environment as a purely mental exercise. The example of a vehicle that moves under program control in a fictitious landscape is a microcosmos of programming lore. In this section we introduce important concepts that will reappear later in more elaborate settings. The environment. Consider a two-dimensional square grid, a portion of which is enclosed by a wall made up of horizontal and vertical line segments that run halfway between the grid points ( Exhibit 1.1). A robot car enclosed within the wall moves along this grid under computer control, one step at a time, from grid point to adjacent grid point. Before and after each step, the robot's state is described by a location (grid point) and a direction (north, east, south, or west). Exhibit 1.1: The robot's crosshairs show its current location on the grid. The robot is controlled by a program that uses the following commands: left Turn 90 degrees counterclockwise. right Turn 90 degrees clockwise. forward Move one step, to the next grid point in front of you goto # Send program control to the label #. if touch goto # If you are touching a wall to your front, send program control to the label #. Algorithms and Data Structures 9 A Global Text 1. Reducing a task to given primitives: programming motion A program for the robot is a sequence of commands with distinct labels. The labels serve merely to identify the commands and need not be arranged either consecutively or in increasing order. Execution begins with the first command and proceeds to successive commands in the order in which they appear, except when flow of control is redir