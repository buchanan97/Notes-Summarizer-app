The Little Book of Semaphores Allen B. Downey Version 2.2.1 The Little Book of Semaphores Second Edition Version 2.2.1 Copyright 2016 Allen B. Downey Permission is granted to copy, distribute and/or modify thi s document under the terms of the Creative Commons Attributio nNonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) at http://creativecommons.org/licenses/by-nc-sa/4.0 . The original form of this book is LaTeX source code. Compilin g this LaTeX source has the eﬀect of generating a device-independent rep resentation of a book, which can be converted to other formats and printed. This book was typeset by the author using latex, dvips and ps2 pdf, among other free, open-source programs. The LaTeX source for this book is available fromhttp://greenteapress.com/semaphores . Preface Most undergraduate Operating Systems textbooks have a modu le on Synchronization, which usually presents a set of primitives (mutex es, semaphores, monitors, and sometimes condition variables), and classical p roblems like readerswriters and producers-consumers. When I took the Operating Systems class at Berkeley, and taug ht it at Colby College, I got the impression that most students were able to understand the solutions to these problems, but few would have been able to p roduce them, or solve similar problems. One reason students don’t understand this material deeply i s that it takes more time, and more practice, than most classes can spare. Sy nchronization is just one of the modules competing for space in an Operating Sy stems class, and I’m not sure I can argue that it is the most important. But I do t hink it is one of the most challenging, interesting, and (done right) fun. Iwrotetheﬁrsteditionthisbookwiththegoalofidentifyin gsynchronization idioms and patterns that could be understood in isolation an d then assembled to solve complex problems. This was a challenge, because syn chronization code doesn’t compose well; as the number of components increases , the number of interactions grows unmanageably. Nevertheless, I found patterns in the solutions I saw, and di scovered at least some systematic approaches to assembling solutions t hat are demonstrably correct. I had a chance to test this approach when I taught Operating Sy stems at Wellesley College. I used the ﬁrst edition of The Little Book of Semaphores along with one of the standard textbooks, and I taught Synchr onization as a concurrent thread for the duration of the course. Each week I gave the students a few pages from the book, ending with a puzzle, and sometimes a hint. I told them not to look at the hint unless they were stumped. I also gave them some tools for testing their solutions: a sma ll magnetic whiteboard where they could write code, and a stack of magnet s to represent the threads executing the code. The results were dramatic. Given more time to absorb the mate rial, students demonstrated a depth of understanding I had not seen be fore. More importantly, most of them were able to solve most of the puzzl es. In some cases they reinvented classical solutions; in other cases t hey found creative new approaches. ii Preface When I moved to Olin College, I took the next step and created a half-class, called Synchronization, which covered The Little Book of Semaphores and also the implementation of synchronization primitives in x86 As sembly Language, POSIX, and Python. The students who took the class helped me ﬁnd errors in the ﬁrs t edition and several of them contributed solutions that were better than mine. At the end of the semester, I asked each of them to write a new, original pro blem (preferably with a solution). I have added their contributions to the sec ond edition. Also since the ﬁrst edition appeared, Kenneth Reek presente d the article “Design Patterns for Semaphores” at the ACM Special Interes t Group for Computer Science Education. He presents a problem, which I have cast as the Sushi Bar Problem, and two solutions that demonstrate patterns he calls “Pass the baton” and “I’ll do it for you.” Once I came to appreciate thes e patterns, I was able to apply them to some of the problems from the ﬁrst editio n and produce solutions that I think are better. One other change in the second edition is the syntax. After I w rote the ﬁrst edition, I learned Python, which is not only a great programm ing language; it also makes a great pseudocode language. So I switched from th e C-like syntax in the ﬁrst edition to syntax that is pretty close to executab le Python1. In fact, I have written a simulator that can execute many of the soluti ons in this book. Readers who are not familiar with Python will (I hope) ﬁnd it m ostly obvious. In cases where I use a Python-speciﬁc feature, I expla in the syntax and what it means. I hope that these changes make the book more rea dable. The pagination of this book might seem peculiar, but there is a method to my whitespace. After each puzzle, I leave enough space that t he hint appears on the next sheet of paper and the solution on the next sheet af ter that. When I use this book in my class, I hand it out a few pages at a time, an d students collect them in a binder. My pagination system makes it possi ble to hand out a problem without giving away the hint or the solution. Somet imes I fold and staple the hint and hand it out along with the problem so that s tudents can decide whether and when to look at the hint. If you print the bo ok single-sided, you can discard the blank pages and the system still works. This is a Free Book, which means that anyone is welcome to read , copy, modify and redistribute it, subject to the restrictions of t he license. I hope that people will ﬁnd this book useful, but I also hope they wil l help continue to develop it by sending in corrections, suggestions, and ad ditional material. Thanks! Allen B. Downey Needham, MA June 1, 2005 1The primary diﬀerence is that I sometimes use indentation to indicate co de that is protected by a mutex, which would cause syntax errors in Python. iii Contributor’s list The following are some of the people who have contributed to t his book: •Many of the problems in this book are variations of classical problems that appeared ﬁrst in technical articles and then in textboo ks. Whenever I know the origin of a problem or solution, I acknowledge it in the text. •I also thank the students at Wellesley College who worked wit h the ﬁrst edition of the book, and the students at Olin College who work ed with the second edition. •Se Won sent in a small but important correction in my presenta tion of Tanenbaum’s solution to the Dining Philosophers Problem. •Daniel Zingaro punched a hole in the Dancer’s problem, which provoked me to rewrite that section. I can only hope that it makes more s ense now. Daniel also pointed out an error in a previous version of my so lution to the H2O problem, and then wrote back a year later with some typos. •Thomas Hansen found a typo in the Cigarette smokers problem. •Pascal R¨ utten pointed out several typos, including my emba rrassing misspelling of Edsger Dijkstra. •Marcelo Johann pointed out an error in my solution to the Dini ng Savages problem, and ﬁxed it! •Roger Shipman sent a whole passel of corrections as well as an interesting variation on the Barrier problem. •Jon Cass pointed out an omission in the discussion of dining p hilosophers. •Krzysztof Ko´ sciuszkiewicz sent in several corrections, i ncluding a missing line in the Fifo class deﬁnition. •Fritz Vaandrager at the Radboud University Nijmegen in the N etherlands and his students Marc Schoolderman, Manuel Stampe and Lars L ockefeer used a tool called UPPAAL to check several of the solutions in this book and found errors in my solutions to the Room Party problem and the Modus Hall problem. •Eric Gorr pointed out an explanation in Chapter 3 that was not exactly right. •Jouni Lepp¨ aj¨ arvi helped clarify the origins of semaphore s. •Christoph Bartoschek found an error in a solution to the excl usive dance problem. •Eus found a typo in Chapter 3. iv Preface •Tak-Shing Chan found an out-of-bounds error in counter mutex.c. •Roman V. Kiseliov made several suggestions for improving th e appearance of the book, and helped me with some L ATEX issues. •Alejandro C´ espedes is working on the Spanish translation o f this book and found some typos. •Erich Nahum found a problem in my adaptation of Kenneth Reek’ s solution to the Sushi Bar Problem. •Martin Storsj¨ o sent a correction to the generalized smoker s problem. •Cris Hawkins pointed out an unused variable. •Adolfo Di Mare found the missing “and”. •Simon Ellis found a typo. •Benjamin Nash found a typo, an error in one solution, and a mal feature in another. •Alejandro Pulver found a problem with the Barbershop soluti on. Contents Preface i 1 Introduction 1 1.1 Synchronization . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1.2 Execution model . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1.3 Serialization with messages . . . . . . . . . . . . . . . . . . . . . 3 1.4 Non-determinism . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 1.5 Shared variables . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 1.5.1 Concurrent writes . . . . . . . . . . . . . . . . . . . . . . 4 1.5.2 Concurrent updates . . . . . . . . . . . . . . . . . . . . . 5 1.5.3 Mutual exclusion with messages . . . . . . . . . . . . . . 6 2 Semaphores 7 2.1 Deﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 2.2 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 2.3 Why semaphores? . . . . . . . . . . . . . . . . . . . . . . . . . . 9 3 Basic synchronization patterns 11 3.1 Signaling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 3.2 Sync.py . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 3.3 Rendezvous . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 3.3.1 Rendezvous hint . . . . . . . . . . . . . . . . . . . . . . . 13 3.3.2 Rendezvous solution . . . . . . . . . . . . . . . . . . . . . 15 3.3.3 Deadlock #1 . . . . . . . . . . . . . . . . . . . . . . . . . 15 3.4 Mutex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 3.4.1 Mutual exclusion hint . . . . . . . . . . . . . . . . . . . . 17 3.4.2 Mutual exclusion solution . . . . . . . . . . . . . . . . . . 19 3.5 Multiplex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 3.5.1 Multiplex solution . . . . . . . . . . . . . . . . . . . . . . 21 3.6 Barrier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 3.6.1 Barrier hint . . . . . . . . . . . . . . . . . . . . . . . . . . 23 3.6.2 Barrier non-solution . . . . . . . . . . . . . . . . . . . . . 25 3.6.3 Deadlock #2 . . . . . . . . . . . . . . . . . . . . . . . . . 27 3.6.4 Barrier solution . . . . . . . . . . . . . . . . . . . . . . . . 29 vi CONTENTS 3.6.5 Deadlock #3 . . . . . . . . . . . . . . . . . . . . . . . . . 31 3.7 Reusable barrier . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 3.7.1 Reusable barrier non-solution #1 . . . . . . . . . . . . . . 33 3.7.2 Reusable barrier problem #1 . . . . . . . . . . . . . . . . 35 3.7.3 Reusable barrier non-solution #2 . . . . . . . . . . . . . . 37 3.7.4 Reusable barrier hint . . . . . . . . . . . . . . . . . . . . . 39 3.7.5 Reusable barrier solution . . . . . . . . . . . . . . . . . . 41 3.7.6 Preloaded turnstile . . . . . . . . . . . . . . . . . . . . . . 43 3.7.7 Barrier objects . . . . . . . . . . . . . . . . . . . . . . . . 44 3.8 Queue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 3.8.1 Queue hint . . . . . . . . . . . . . . . . . . . . . . . . . . 47 3.8.2 Queue solution . . . . . . . . . . . . . . . . . . . . . . . . 49 3.8.3 Exclusive queue hint . . . . . . . . . . . . . . . . . . . . . 51 3.8.4 Exclusive queue solution . . . . . . . . . . . . . . . . . . . 53 4 Classical synchronization problems 55 4.1 Producer-consumer problem . . . . . . . . . . . . . . . . . . . . . 55 4.1.1 Producer-consumer hint . . . . . . . . . . . . . . . . . . . 57 4.1.2 Producer-consumer solution . . . . . . . . . . . . . . . . . 59 4.1.3 Deadlock #4 . . . . . . . . . . . . . . . . . . . . . . . . . 61 4.1.4 Producer-consumer with a ﬁnite buﬀer . . . . . . . . . . . 61 4.1.5 Finite buﬀer producer-consumer hint . . . . . . . . . . . . 63 4.1.6 Finite buﬀer producer-consumer solution . . . . . . . . . 65 4.2 Readers-writers problem . . . . . . . . . . . . . . . . . . . . . . . 65 4.2.1 Readers-writers hint . . . . . . . . . . . . . . . . . . . . . 67 4.2.2 Readers-writers solution . . . . . . . . . . . . . . . . . . . 69 4.2.3 Starvation . . . . . . . . . . . . . . . . . . . . . . . . . . . 71 4.2.4 No-starve readers-writers hint . . . . . . . . . . . . . . . . 73 4.2.5 No-starve readers-writers solution . . . . . . . . . . . . . 75 4.2.6 Writer-priority readers-writers hint . . . . . . . . . . . . . 77 4.2.7 Writer-priority readers-writers solution . . . . . . . . . . . 79 4.3 No-starve mutex . . . . . . . . . . . . . . . . . . . . . . . . . . . 81 4.3.1 No-starve mutex hint . . . . . . . . . . . . . . . . . . . . 83 4.3.2 No-starve mutex solution . . . . . . . . . . . . . . . . . . 85 4.4 Dining philosophers . . . . . . . . . . . . . . . . . . . . . . . . . 87 4.4.1 Deadlock #5 . . . . . . . . . . . . . . . . . . . . . . . . . 89 4.4.2 Dining philosophers hint #1 . . . . . . . . . . . . . . . . . 91 4.4.3 Dining philosophers solution #1 . . . . . . . . . . . . . . 93 4.4.4 Dining philosopher’s solution #2 . . . . . . . . . . . . . . 95 4.4.5 Tanenbaum’s solution . . . . . . . . . . . . . . . . . . . . 97 4.4.6 Starving Tanenbaums . . . . . . . . . . . . . . . . . . . . 99 4.5 Cigarette smokers problem . . . . . . . . . . . . . . . . . . . . . . 101 4.5.1 Deadlock #6 . . . . . . . . . . . . . . . . . . . . . . . . . 105 4.5.2 Smokers problem hint . . . . . . . . . . . . . . . . . . . . 107 4.5.3 Smoker problem solution . . . . . . . . . . . . . . . . . . 109 4.5.4 Generalized Smokers Problem . . . . . . . . . . . . . . . . 109 CONTENTS vii 4.5.5 Generalized Smokers Problem Hint . . . . . . . . . . . . . 111 4.5.6 Generalized Smokers Problem Solution . . . . . . . . . . . 113 5 Less classical synchronization problems 115 5.1 The dining savages problem . . . . . . . . . . . . . . . . . . . . . 115 5.1.1 Dining Savages hint . . . . . . . . . . . . . . . . . . . . . 117 5.1.2 Dining Savages solution . . . . . . . . . . . . . . . . . . . 119 5.2 The barbershop problem . . . . . . . . . . . . . . . . . . . . . . . 121 5.2.1 Barbershop hint . . . . . . . . . . . . . . . . . . . . . . . 123 5.2.2 Barbershop solution . . . . . . . . . . . . . . . . . . . . . 125 5.3 The FIFO barbershop . . . . . . . . . . . . . . . . . . . . . . . . 127 5.3.1 FIFO barbershop hint . . . . . . . . . . . . . . . . . . . . 129 5.3.2 FIFO barbershop solution . . . . . . . . . . . . . . . . . . 131 5.4 Hilzer’s Barbershop problem . . . . . . . . . . . . . . . . . . . . . 133 5.4.1 Hilzer’s barbershop hint . . . . . . . . . . . . . . . . . . . 134 5.4.2 Hilzer’s barbershop solution . . . . . . . . . . . . . . . . . 135 5.5 The Santa Claus problem . . . . . . . . . . . . . . . . . . . . . . 137 5.5.1 Santa problem hint . . . . . . . . . . . . . . . . . . . . . . 139 5.5.2 Santa problem solution . . . . . . . . . . . . . . . . . . . 141 5.6 Building H 2O. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143 5.6.1 H 2O hint. . . . . . . . . . . . . . . . . . . . . . . . . . . 145 5.6.2 H 2O solution . . . . . . . . . . . . . . . . . . . . . . . . . 147 5.7 River crossing problem . . . . . . . . . . . . . . . . . . . . . . . . 148 5.7.1 River crossing hint . . . . . . . . . . . . . . . . . . . . . . 149 5.7.2 River crossing solution . . . . . . . . . . . . . . . . . . . . 151 5.8 The roller coaster problem . . . . . . . . . . . . . . . . . . . . . . 153 5.8.1 Roller Coaster hint . . . . . . . . . . . . . . . . . . . . . . 155 5.8.2 Roller Coaster solution . . . . . . . . . . . . . . . . . . . . 157 5.8.3 Multi-car Roller Coaster problem . . . . . . . . . . . . . . 159 5.8.4 Multi-car Roller Coaster hint . . . . . . . . . . . . . . . . 161 5.8.5 Multi-car Roller Coaster solution . . . . . . . . . . . . . . 163 6 Not-so-classical problems 165 6.1 The search-insert-delete problem . . . . . . . . . . . . . . . . . . 165 6.1.1 Search-Insert-Delete hint . . . . . . . . . . . . . . . . . . 167 6.1.2 Search-Insert-Delete solution . . . . . . . . . . . . . . . . 169 6.2 The unisex bathroom problem . . . . . . . . . . . . . . . . . . . . 170 6.2.1 Unisex bathroom hint . . . . . . . . . . . . . . . . . . . . 171 6.2.2 Unisex bathroom solution . . . . . . . . . . . . . . . . . . 173 6.2.3 No-starve unisex bathroom problem . . . . . . . . . . . . 175 6.2.4 No-starve unisex bathroom solution . . . . . . . . . . . . 177 6.3 Baboon crossing problem . . . . . . . . . . . . . . . . . . . . . . 177 6.4 The Modus Hall Problem . . . . . . . . . . . . . . . . . . . . . . 178 6.4.1 Modus Hall problem hint . . . . . . . . . . . . . . . . . . 179 6.4.2 Modus Hall problem solution . . . . . . . . . . . . . . . . 181 viii CONTENTS 7 Not remotely classical problems 183 7.1 The sushi bar problem . . . . . . . . . . . . . . . . . . . . . . . . 183 7.1.1 Sushi bar hint . . . . . . . . . . . . . . . . . . . . . . . . . 185 7.1.2 Sushi bar non-solution . . . . . . . . . . . . . . . . . . . . 187 7.1.3 Sushi bar non-solution . . . . . . . . . . . . . . . . . . . . 189 7.1.4 Sushi bar solution #1 . . . . . . . . . . . . . . . . . . . . 191 7.1.5 Sushi bar solution #2 . . . . . . . . . . . . . . . . . . . . 193 7.2 The child care problem . . . . . . . . . . . . . . . . . . . . . . . . 194 7.2.1 Child care hint . . . . . . . . . . . . . . . . . . . . . . . . 195 7.2.2 Child care non-solution . . . . . . . . . . . . . . . . . . . 197 7.2.3 Child care solution . . . . . . . . . . . . . . . . . . . . . . 199 7.2.4 Extended child care problem . . . . . . . . . . . . . . . . 199 7.2.5 Extended child care hint . . . . . . . . . . . . . . . . . . . 201 7.2.6 Extended child care solution . . . . . . . . . . . . . . . . 203 7.3 The room party problem . . . . . . . . . . . . . . . . . . . . . . . 205 7.3.1 Room party hint . . . . . . . . . . . . . . . . . . . . . . . 207 7.3.2 Room party solution . . . . . . . . . . . . . . . . . . . . . 209 7.4 The Senate Bus problem . . . . . . . . . . . . . . . . . . . . . . . 211 7.4.1 Bus problem hint . . . . . . . . . . . . . . . . . . . . . . . 213 7.4.2 Bus problem solution #1 . . . . . . . . . . . . . . . . . . 215 7.4.3 Bus problem solution #2 . . . . . . . . . . . . . . . . . . 217 7.5 The Faneuil Hall problem . . . . . . . . . . . . . . . . . . . . . . 219 7.5.1 Faneuil Hall Problem Hint . . . . . . . . . . . . . . . . . . 221 7.5.2 Faneuil Hall problem solution . . . . . . . . . . . . . . . . 223 7.5.3 Extended Faneuil Hall Problem Hint . . . . . . . . . . . . 225 7.5.4 Extended Faneuil Hall problem solution . . . . . . . . . . 227 7.6 Dining Hall problem . . . . . . . . . . . . . . . . . . . . . . . . . 229 7.6.1 Dining Hall problem hint . . . . . . . . . . . . . . . . . . 231 7.6.2 Dining Hall problem solution . . . . . . . . . . . . . . . . 233 7.6.3 Extended Dining Hall problem . . . . . . . . . . . . . . . 234 7.6.4 Extended Dining Hall problem hint . . . . . . . . . . . . . 235 7.6.5 Extended Dining Hall problem solution . . . . . . . . . . 237 8 Synchronization in Python 239 8.1 Mutex checker problem . . . . . . . . . . . . . . . . . . . . . . . 240 8.1.1 Mutex checker hint . . . . . . . . . . . . . . . . . . . . . . 243 8.1.2 Mutex checker solution . . . . . . . . . . . . . . . . . . . 245 8.2 The coke machine problem . . . . . . . . . . . . . . . . . . . . . . 247 8.2.1 Coke machine hint . . . . . . . . . . . . . . . . . . . . . . 249 8.2.2 Coke machine solution . . . . . . . . . . . . . . . . . . . . 251 9 Synchronization in C 253 9.1 Mutual exclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . 253 9.1.1 Parent code . . . . . . . . . . . . . . . . . . . . . . . . . . 254 9.1.2 Child code . . . . . . . . . . . . . . . . . . . . . . . . . . 254 9.1.3 Synchronization errors . . . . . . . . . . . . . . . . . . . . 255 CONTENTS ix 9.1.4 Mutual exclusion hint . . . . . . . . . . . . . . . . . . . . 257 9.1.5 Mutual exclusion solution . . . . . . . . . . . . . . . . . . 259 9.2 Make your own semaphores . . . . . . . . . . . . . . . . . . . . . 261 9.2.1 Semaphore implementation hint . . . . . . . . . . . . . . 263 9.2.2 Semaphore implementation . . . . . . . . . . . . . . . . . 265 9.2.3 Semaphore implementation detail . . . . . . . . . . . . . . 267 A Cleaning up Python threads 271 A.1 Semaphore methods . . . . . . . . . . . . . . . . . . . . . . . . . 271 A.2 Creating threads . . . . . . . . . . . . . . . . . . . . . . . . . . . 271 A.3 Handling keyboard interrupts . . . . . . . . . . . . . . . . . . . . 272 B Cleaning up POSIX threads 275 B.1 Compiling Pthread code . . . . . . . . . . . . . . . . . . . . . . . 275 B.2 Creating threads . . . . . . . . . . . . . . . . . . . . . . . . . . . 276 B.3 Joining threads . . . . . . . . . . . . . . . . . . . . . . . . . . . . 278 B.4 Semaphores . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 278 x CONTENTS Chapter 1 Introduction 1.1 Synchronization In common use, “synchronization” means making two things ha ppen at the same time. In computer systems, synchronization is a little more general; it refers to relationships among events—any number of events, a nd any kind of relationship (before, during, after). Computer programmers are often concerned with synchronization constraints , which are requirements pertaining to the order of events. E xamples include: Serialization: Event A must happen before Event B. Mutual exclusion: Events A and B must not happen at the same time. In real life we often check and enforce synchronization cons traints using a clock. How do we know if A happened before B? If we know what tim e both events occurred, we can just compare the times. In computer systems, we often need to satisfy synchronizati on constraints without the beneﬁt of a clock, either because there is no univ ersal clock, or because we don’t know with ﬁne enough resolution when events occur. That’s what this book is about: software techniques for enfo rcing synchronization constraints. 1.2 Execution model In order to understand software synchronization, you have t o have a model of how computer programs run. In the simplest model, computers execute one instruction after another in sequence. In this model, synch ronization is trivial; we can tell the order of events by looking at the program. If St atement A comes before Statement B, it will be executed ﬁrst. 2 Introduction There are two ways things get more complicated. One possibil ity is that the computer is parallel, meaning that it has multiple proce ssors running at the same time. In that case it is not easy to know if a statement on o ne processor is executed before a statement on another. Another possibility is that a single processor is running mu ltiple threads of execution. A thread is a sequence of instructions that execu te sequentially. If there are multiple threads, then the processor can work on on e for a while, then switch to another, and so on. In general the programmer has no control over when each threa d runs; the operating system (speciﬁcally, the scheduler) makes those decisions. As a result, again, the programmer can’t tell when statements in diﬀeren t threads will be executed. For purposes of synchronization, there is no diﬀerence betw een the parallel model and the multithread model. The issue is the same—within one processor (or one thread) we know the order of execution, but between pr ocessors (or threads) it is impossible to tell. A real world example might make this clearer. Imagine that yo u and your friend Bob live in diﬀerent cities, and one day, around dinne r time, you start to wonder who ate lunch ﬁrst that day, you or Bob. How would you ﬁn d out? Obviously you could call him and ask what time he ate lunch. Bu t what if you started lunch at 11:59 by your clock and Bob started lunch at 12:01 by his clock? Can you be sure who started ﬁrst? Unless you are both ve ry careful to keep accurate clocks, you can’t. Computer systems face the same problem because, even though their clocks are usually accurate, there is always a limit to their precis ion. In addition, most of the time the computer does not keep track of what time t hings happen. There are just too many things happening, too fast, to record the exact time of everything. Puzzle: Assuming that Bob is willing to follow simple instru ctions, is there any way you can guarantee that tomorrow you will eat lunch before Bob? 1.3 Serialization with messages 3 1.3 Serialization with messages One solution is to instruct Bob not to eat lunch until you call . Then, make sure you don’t call until after lunch. This approach may seem trivial, but the underlying idea, message passing, is a real solution for many synchronization problems. At the risk of belaboring the obvious, consid er this timeline. Thread A (You) 1Eat breakfast 2Work 3Eat lunch 4Call BobThread B (Bob) 1Eat breakfast 2Wait for a call 3Eat lunch The ﬁrst column is a list of actions you perform; in other word s, your thread of execution. The second column is Bob’s thread of execution. W ithin a thread, we can always tell what order things happen. We can denote the order of events a1< a2< a3< a4 b1< b2< b3 where the relation a1< a2 means that a1 happened before a2. In general, though, there is no way to compare events from diﬀ erent threads; for example, we have no idea who ate breakfast ﬁrst (is a1< b1?). But with message passing (the phone call) we cantell who ate lunch ﬁrst (a3< b3). Assuming that Bob has no other friends, he won’t get a call until you call, so b2> a4 . Combining all the relations, we get b3> b2> a4> a3 which proves that you had lunch before Bob. Inthiscase, wewouldsaythatyouandBobatelunch sequentially , because we know the order of events, and you ate breakfast concurrently , because we don’t. Whenwetalkaboutconcurrentevents,itistemptingtosayth attheyhappen at the same time, or simultaneously. As a shorthand, that’s ﬁ ne, as long as you remember the strict deﬁnition: Twoeventsareconcurrentifwecannottellbylookingatthep rogram which will happen ﬁrst. Sometimes we can tell, after the program runs, which happene d ﬁrst, but often not, and even if we can, there is no guarantee that we wil l get the same result the next time. 4 Introduction 1.4 Non-determinism Concurrent programs are often non-deterministic , which means it is not possible to tell, by looking at the program, what will happen whe n it executes. Here is a simple example of a non-deterministic program: Thread A 1print "yes"Thread B 1print "no" Because the two threads run concurrently, the order of execu tion depends on the scheduler. During any given run of this program, the ou tput might be “yes no” or “no yes”. Non-determinism is one of the things that makes concurrent p rograms hard to debug. A program might work correctly 1000 times in a row, a nd then crash on the 1001st run, depending on the particular decisions of t he scheduler. These kinds of bugs are almost impossible to ﬁnd by testing; t hey can only be avoided by careful programming. 1.5 Shared variables Most of the time, most variables in most threads are local, meaning that they belong to a single thread and no other threads can access them . As long as that’s true, there tend to be few synchronization problems, because threads just don’t interact. But usually some variables are sharedamong two or more threads; this is one of the ways threads interact with each other. For examp le, one way to communicate information between threads is for one threa d to read a value written by another thread. If the threads are unsynchronized, then we cannot tell by loo king at the program whether the reader will see the value the writer writ es or an old value that was already there. Thus many applications enforce the c onstraint that the reader should not read until after the writer writes. Thi s is exactly the serialization problem in Section 1.3. Other ways that threads interact are concurrent writes (two or more writers) and concurrent updates (two or more threads performing a read followed by a write). The next two sections deal with these interactio ns. The other possible use of a shared variable, concurrent reads, does no t generally create a synchronization problem. 1.5.1 Concurrent writes In the following example, xis a shared variable accessed by two writers. 1.5 Shared variables 5 Thread A 1x = 5 2print xThread B 1x = 7 What value of xgets printed? What is the ﬁnal value of xwhen all these statements have executed? It depends on the order in which th e statements are executed, called the execution path . One possible path is a1< a2< b1, in which case the output of the program is 5, but the ﬁnal value is 7. Puzzle: What path yields output 5and ﬁnal value 5? Puzzle: What path yields output 7and ﬁnal value 7? Puzzle: Is there a path that yields output 7and ﬁnal value 5? Can you prove it? Answering questions like these is an important part of concu rrent programming: What paths are possible and what are the possible eﬀect s? Can we prove that a given (desirable) eﬀect is necessary or that an (undes irable) eﬀect is impossible? 1.5.2 Concurrent updates An update is an operation that reads the value of a variable, c omputes a new value based on the old value, and writes the new value. The mos t common kind of update is an increment, in which the new value is the old val ue plus one. The following example shows a shared variable, count, being updated concurrently by two threads. Thread A 1count = count + 1Thread B 1count = count + 1 At ﬁrst glance, it is not obvious that