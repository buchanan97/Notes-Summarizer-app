Think Complexity Version 2.6.3 Think Complexity Version 2.6.3 Allen B. Downey Green Tea Press Needham, Massachusetts Copyright Â©2016 Allen B. Downey. Green Tea Press 9 Washburn Ave Needham MA 02492 Permission is granted to copy, distribute, transmit and adapt this work under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License: http://thinkcomplex.com/license . If you are interested in distributing a commercial version of this work, please contact the author. The LATEX source for this book is available from https://github.com/AllenDowney/ThinkComplexity2 iv Contents Preface xi 0.1 Who is this book for? . . . . . . . . . . . . . . . . . . . . . . xii 0.2 Changes from the rst edition . . . . . . . . . . . . . . . . . xiii 0.3 Using the code . . . . . . . . . . . . . . . . . . . . . . . . . . xiii 1 Complexity Science 1 1.1 The changing criteria of science . . . . . . . . . . . . . . . . 3 1.2 The axes of scienti c models . . . . . . . . . . . . . . . . . . 4 1.3 Di erent models for di erent purposes . . . . . . . . . . . . 6 1.4 Complexity engineering . . . . . . . . . . . . . . . . . . . . . 7 1.5 Complexity thinking . . . . . . . . . . . . . . . . . . . . . . 8 2 Graphs 11 2.1 What is a graph? . . . . . . . . . . . . . . . . . . . . . . . . 11 2.2 NetworkX . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 2.3 Random graphs . . . . . . . . . . . . . . . . . . . . . . . . . 16 2.4 Generating graphs . . . . . . . . . . . . . . . . . . . . . . . . 17 2.5 Connected graphs . . . . . . . . . . . . . . . . . . . . . . . . 18 2.6 Generating ER graphs . . . . . . . . . . . . . . . . . . . . . 20 2.7 Probability of connectivity . . . . . . . . . . . . . . . . . . . 22 vi CONTENTS 2.8 Analysis of graph algorithms . . . . . . . . . . . . . . . . . . 24 2.9 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 3 Small World Graphs 27 3.1 Stanley Milgram . . . . . . . . . . . . . . . . . . . . . . . . . 27 3.2 Watts and Strogatz . . . . . . . . . . . . . . . . . . . . . . . 28 3.3 Ring lattice . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 3.4 WS graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 3.5 Clustering . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 3.6 Shortest path lengths . . . . . . . . . . . . . . . . . . . . . . 35 3.7 The WS experiment . . . . . . . . . . . . . . . . . . . . . . . 36 3.8 What kind of explanation is that? . . . . . . . . . . . . . . . 38 3.9 Breadth-First Search . . . . . . . . . . . . . . . . . . . . . . 39 3.10 Dijkstra's algorithm . . . . . . . . . . . . . . . . . . . . . . . 41 3.11 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 4 Scale-free networks 47 4.1 Social network data . . . . . . . . . . . . . . . . . . . . . . . 47 4.2 WS Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 4.3 Degree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 4.4 Heavy-tailed distributions . . . . . . . . . . . . . . . . . . . 53 4.5 Barab asi-Albert model . . . . . . . . . . . . . . . . . . . . . 55 4.6 Generating BA graphs . . . . . . . . . . . . . . . . . . . . . 57 4.7 Cumulative distributions . . . . . . . . . . . . . . . . . . . . 59 4.8 Explanatory models . . . . . . . . . . . . . . . . . . . . . . . 62 4.9 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63 CONTENTS vii 5 Cellular Automatons 67 5.1 A simple CA . . . . . . . . . . . . . . . . . . . . . . . . . . . 67 5.2 Wolfram's experiment . . . . . . . . . . . . . . . . . . . . . . 68 5.3 Classifying CAs . . . . . . . . . . . . . . . . . . . . . . . . . 69 5.4 Randomness . . . . . . . . . . . . . . . . . . . . . . . . . . . 71 5.5 Determinism . . . . . . . . . . . . . . . . . . . . . . . . . . . 72 5.6 Spaceships . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73 5.7 Universality . . . . . . . . . . . . . . . . . . . . . . . . . . . 76 5.8 Falsi ability . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 5.9 What is this a model of? . . . . . . . . . . . . . . . . . . . . 78 5.10 Implementing CAs . . . . . . . . . . . . . . . . . . . . . . . 80 5.11 Cross-correlation . . . . . . . . . . . . . . . . . . . . . . . . 82 5.12 CA tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84 5.13 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85 6 Game of Life 89 6.1 Conway's GoL . . . . . . . . . . . . . . . . . . . . . . . . . . 89 6.2 Life patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . 92 6.3 Conway's conjecture . . . . . . . . . . . . . . . . . . . . . . 92 6.4 Realism . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94 6.5 Instrumentalism . . . . . . . . . . . . . . . . . . . . . . . . . 95 6.6 Implementing Life . . . . . . . . . . . . . . . . . . . . . . . . 97 6.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99 7 Physical modeling 103 7.1 Di usion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103 7.2 Reaction-di usion . . . . . . . . . . . . . . . . . . . . . . . . 105 viii CONTENTS 7.3 Percolation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109 7.4 Phase change . . . . . . . . . . . . . . . . . . . . . . . . . . 110 7.5 Fractals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113 7.6 Fractals and Percolation Models . . . . . . . . . . . . . . . . 115 7.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116 8 Self-organized criticality 119 8.1 Critical Systems . . . . . . . . . . . . . . . . . . . . . . . . . 119 8.2 Sand Piles . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120 8.3 Implementing the Sand Pile . . . . . . . . . . . . . . . . . . 121 8.4 Heavy-tailed distributions . . . . . . . . . . . . . . . . . . . 125 8.5 Fractals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127 8.6 Pink noise . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131 8.7 The sound of sand . . . . . . . . . . . . . . . . . . . . . . . . 132 8.8 Reductionism and Holism . . . . . . . . . . . . . . . . . . . 134 8.9 SOC, causation, and prediction . . . . . . . . . . . . . . . . 137 8.10 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138 9 Agent-based models 141 9.1 Schelling's Model . . . . . . . . . . . . . . . . . . . . . . . . 142 9.2 Implementation of Schelling's model . . . . . . . . . . . . . . 143 9.3 Segregation . . . . . . . . . . . . . . . . . . . . . . . . . . . 145 9.4 Sugarscape . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147 9.5 Wealth inequality . . . . . . . . . . . . . . . . . . . . . . . . 150 9.6 Implementing Sugarscape . . . . . . . . . . . . . . . . . . . . 151 9.7 Migration and Wave Behavior . . . . . . . . . . . . . . . . . 154 9.8 Emergence . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155 CONTENTS ix 9.9 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157 10 Herds, Flocks, and Trac Jams 159 10.1 Trac jams . . . . . . . . . . . . . . . . . . . . . . . . . . . 159 10.2 Random perturbation . . . . . . . . . . . . . . . . . . . . . . 163 10.3 Boids . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164 10.4 The Boid algorithm . . . . . . . . . . . . . . . . . . . . . . . 165 10.5 Arbitration . . . . . . . . . . . . . . . . . . . . . . . . . . . 168 10.6 Emergence and free will . . . . . . . . . . . . . . . . . . . . 169 10.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171 11 Evolution 173 11.1 Simulating evolution . . . . . . . . . . . . . . . . . . . . . . 174 11.2 Fitness landscape . . . . . . . . . . . . . . . . . . . . . . . . 175 11.3 Agents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176 11.4 Simulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177 11.5 No di erentiation . . . . . . . . . . . . . . . . . . . . . . . . 178 11.6 Evidence of evolution . . . . . . . . . . . . . . . . . . . . . . 179 11.7 Di erential survival . . . . . . . . . . . . . . . . . . . . . . . 182 11.8 Mutation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183 11.9 Speciation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186 11.10 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189 11.11 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190 12 Evolution of cooperation 191 12.1 Prisoner's Dilemma . . . . . . . . . . . . . . . . . . . . . . . 192 12.2 The problem of nice . . . . . . . . . . . . . . . . . . . . . . . 193 x CONTENTS 12.3 Prisoner's dilemma tournaments . . . . . . . . . . . . . . . . 195 12.4 Simulating evolution of cooperation . . . . . . . . . . . . . . 196 12.5 The Tournament . . . . . . . . . . . . . . . . . . . . . . . . 198 12.6 The Simulation . . . . . . . . . . . . . . . . . . . . . . . . . 200 12.7 Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202 12.8 Conclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . 205 12.9 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207 A Reading list 209 Preface Complexity science is an interdisciplinary eld | at the intersection of mathematics, computer science and natural science | that focuses on complex systems , which are systems with many interacting components. One of the core tools of complexity science is discrete models, including networks and graphs, cellular automatons, and agent-based simulations. These tools are useful in the natural and social sciences, and sometimes in arts and humanities. For an overview of complexity science, see http://thinkcomplex.com/complex . Why should you learn about complexity science? Here are a few reasons: ÂˆComplexity science is useful, especially for explaining why natural and social systems behave the way they do. Since Newton, math-based physics has focused on systems with small numbers of components and simple interactions. These models are e ective for some applications, like celestial mechanics, and less useful for others, like economics. Complexity science provides a diverse and adaptable modeling toolkit. ÂˆMany of the central results of complexity science are surprising; a recurring theme of this book is that simple models can produce complicated behavior, with the corollary that we can sometimes explain complicated behavior in the real world using simple models. ÂˆAs I explain in Chapter 1, complexity science is at the center of a slow shift in the practice of science and a change in what we consider science to be. xii Chapter 0 Preface ÂˆStudying complexity science provides an opportunity to learn about diverse physical and social systems, to develop and apply programming skills, and to think about fundamental questions in the philosophy of science. By reading this book and working on the exercises you will have a chance to explore topics and ideas you might not encounter otherwise, practice programming in Python, and learn more about data structures and algorithms. Features of this book include: Technical details Most books about complexity science are written for a popular audience. They leave out technical details, which is frustrating for people who can handle them. This book presents the code, the math, and the explanations you need to understand how the models work. Further reading Throughout the book, I include pointers to further reading, including original papers (most of which are available electronically) and related articles from Wikipedia and other sources. Jupyter notebooks For each chapter I provide a Jupyter notebook that includes the code from the chapter, additional examples, and animations that let you see the models in action. Exercises and solutions At the end of each chapter I suggest exercises you might want to work on, with solutions. For most of the links in this book I use URL redirection. This mechanism has the drawback of hiding the link destination, but it makes the URLs shorter and less obtrusive. Also, and more importantly, it allows me to update the links without updating the book. If you nd a broken link, please let me know and I will change the redirection. 0.1 Who is this book for? The examples and supporting code for this book are in Python. You should know core Python and be familiar with its object-oriented features, speci cally using and de ning classes. 0.2 Changes from the rst edition xiii If you are not already familiar with Python, you might want to start with Think Python , which is appropriate for people who have never programmed before. If you have programming experience in another language, there are many good Python books to choose from, as well as online resources. I use NumPy, SciPy, and NetworkX throughout the book. If you are familiar with these libraries already, that's great, but I will also explain them when they appear. I assume that the reader knows some mathematics: I use logarithms in several places, and vectors in one example. But that's about it. 0.2 Changes from the rst edition For the second edition, I added two chapters, one on evolution, the other on the evolution of cooperation. In the rst edition, each chapter presented background on a topic and suggested experiments the reader could run. For the second edition, I have done those experiments. Each chapter presents the implementation and results as a worked example, then suggests additional experiments for the reader. For the second edition, I replaced some of my own code with standard libraries like NumPy and NetworkX. The result is more concise and more ecient, and it gives readers a chance to learn these libraries. Also, the Jupyter notebooks are new. For every chapter there are two notebooks: one contains the code from the chapter, explanatory text, and exercises; the other contains solutions to the exercises. Finally, all supporting software has been updated to Python 3 (but most of it runs unmodi ed in Python 2). 0.3 Using the code All code used in this book is available from a Git repository on GitHub: http: //thinkcomplex.com/repo . If you are not familiar with Git, it is a version xiv Chapter 0 Preface control system that allows you to keep track of the les that make up a project. A collection of les under Git's control is called a \repository". GitHub is a hosting service that provides storage for Git repositories and a convenient web interface. The GitHub homepage for my repository provides several ways to work with the code: ÂˆYou can create a copy of my repository by pressing the Fork button in the upper right. If you don't already have a GitHub account, you'll need to create one. After forking, you'll have your own repository on GitHub that you can use to keep track of code you write while working on this book. Then you can clone the repo, which means that you copy the les to your computer. ÂˆOr you can clone my repository without forking; that is, you can make a copy of my repo on your computer. You don't need a GitHub account to do this, but you won't be able to write your changes back to GitHub. ÂˆIf you don't want to use Git at all, you can download the les in a Zip le using the green button that says \Clone or download". I developed this book using Anaconda from Continuum Analytics, which is a free Python distribution that includes all the packages you'll need to run the code (and lots more). I found Anaconda easy to install. By default it does a user-level installation, not system-level, so you don't need administrative privileges. And it supports both Python 2 and Python 3. You can download Anaconda from https://continuum.io/downloads . The repository includes both Python scripts and Jupyter notebooks. If you have not used Jupyter before, you can read about it at https://jupyter.org . There are three ways you can work with the Jupyter notebooks: Run Jupyter on your computer If you installed Anaconda, you can install Jupyter by running the following command in a terminal or Command Window: $ conda install jupyter 0.3 Using the code xv Before you launch Jupyter, you should cdinto the directory that contains the code: $ cd ThinkComplexity2/code And then start the Jupyter server: $ jupyter notebook When you start the server, it should launch your default web browser or create a new tab in an open browser window. Then you can open and run the notebooks. Run Jupyter on Binder Binder is a service that runs Jupyter in a virtual machine. If you follow this link, http://thinkcomplex.com/binder , you should get a Jupyter home page with the notebooks for this book and the supporting data and scripts. You can run the scripts and modify them to run your own code, but the virtual machine you run them in is temporary. If you leave it idle, the virtual machine disappears along with any changes you made. View notebooks on GitHub GitHub provides a view of the notebooks you can can use to read the notebooks and see the results I generated, but you won't be able to modify or run the code. Good luck, and have fun! Allen B. Downey Professor of Computer Science Olin College of Engineering Needham, MA Contributor List If you have a suggestion or correction, please send email to downey@allendowney.com . If I make a change based on your feedback, I will add you to the contributor list (unless you ask to be omitted). Let me know what version of the book you are working with, and what format. If you include at least part of the sentence the error appears in, that makes it easy for me to search. Page and section numbers are ne, too, but not quite as easy to work with. Thanks! xvi Chapter 0 Preface ÂˆJohn Harley, Je Stanton, Colden Rouleau and Keerthik Omanakuttan are Computational Modeling students who pointed out typos. ÂˆJose Oscar Mur-Miranda found several typos. ÂˆPhillip Loh, Corey Dolphin, Noam Rubin and Julian Ceipek found typos and made helpful suggestions. ÂˆSebastian Sch oner sent two pages of corrections! ÂˆPhilipp Marek sent a number of corrections. ÂˆJason Woodard co-taught Complexity Science with me at Olin College, introduced me to NK models, and made many helpful suggestions and corrections. ÂˆDavi Post sent several corrections and suggestions. ÂˆGraham Taylor sent a pull request on GitHub that xed many typos. I would especially like to thank the technical reviewers, Vincent Knight and Eric Ma, who made many helpful suggestions, and the copy editor, Charles Roumeliotis, who caught many errors and inconsistencies. Other people who reported errors include Richard Hollands, Muhammad Najmi bin Ahmad Zabidi, Alex Hantman, and Jonathan Harford. Chapter 1 Complexity Science Complexity science is relatively new; it became recognizable as a eld, and was given a name, in the 1980s. But its newness is not because it applies the tools of science to a new subject, but because it uses di erent tools, allows di erent kinds of work, and ultimately changes what we mean by \science". To demonstrate the di erence, I'll start with an example of classical science: suppose someone asks you why planetary orbits are elliptical. You might invoke Newton's law of universal gravitation and use it to write a di erential equation that describes planetary motion. Then you can solve the di erential equation and show that the solution is an ellipse. QED! Most people nd this kind of explanation satisfying. It includes a mathematical derivation | so it has some of the rigor of a proof | and it explains a speci c observation, elliptical orbits, by appealing to a general principle, gravitation. Let me contrast that with a di erent kind of explanation. Suppose you move to a city like Detroit that is racially segregated, and you want to know why it's like that. If you do some research, you might nd a paper by Thomas Schelling called \Dynamic Models of Segregation", which proposes a simple model of racial segregation: Here is my description of the model, from Chapter 9: The Schelling model of the city is an array of cells where each cell represents a house. The houses are occupied by two kinds of 2 Chapter 1 Complexity Science \agents", labeled red and blue, in roughly equal numbers. About 10% of the houses are empty. At any point in time, an agent might be happy or unhappy, depending on the other agents in the neighborhood. In one version of the model, agents are happy if they have at least two neighbors like themselves, and unhappy if they have one or zero. The simulation proceeds by choosing an agent at random and checking to see whether it is happy. If so, nothing happens; if not, the agent chooses one of the unoccupied cells at random and moves. If you start with a simulated city that is entirely unsegregated and run the model for a short time, clusters of similar agents appear. As time passes, the clusters grow and coalesce until there are a small number of large clusters and most agents live in homogeneous neighborhoods. The degree of segregation in the model is surprising, and it suggests an explanation of segregation in real cities. Maybe Detroit is segregated because people prefer not to be greatly outnumbered and will move if the composition of their neighborhoods makes them unhappy. Is this explanation satisfying in the same way as the explanation of planetary motion? Many people would say not, but why? Most obviously, the Schelling model is highly abstract, which is to say not realistic. So you might be tempted to say that people are more complicated than planets. But that can't be right. After all, some planets have people on them, so they have to be more complicated than people. Both systems are complicated, and both models are based on simpli cations. For example, in the model of planetary motion we include forces between the planet and its sun, and ignore interactions between planets. In Schelling's model, we include individual decisions based on local information, and ignore every other aspect of human behavior. But there are di erences of degree. For planetary motion, we can defend the model by showing that the forces we ignore are smaller than the ones we include. And we can extend the model to include other interactions and 1.1 The changing criteria of science 3 show that the e ect is small. For Schelling's model it is harder to justify the simpli cations. Another di erence is that Schelling's model doesn't appeal to any physical laws, and it uses only simple computation, not mathematical derivation. Models like Schelling's don't look like classical science, and many people nd them less compelling, at least at rst. But as I will try to demonstrate, these models do useful work, including prediction, explanation, and design. One of the goals of this book is to explain how. 1.1 The changing criteria of science Complexity science is not just a di erent set of models; it is also a gradual shift in the criteria models are judged by, and in the kinds of models that are considered acceptable. For example, classical models tend to be law-based, expressed in the form of equations, and solved by mathematical derivation. Models that fall under the umbrella of complexity are often rule-based, expressed as computations, and simulated rather than analyzed. Not everyone nds these models satisfactory. For example, in Sync, Steven Strogatz writes about his model of spontaneous synchronization in some species of re ies. He presents a simulation that demonstrates the phenomenon, but then writes: I repeated the simulation dozens of times, for other random initial conditions and for other numbers of oscillators. Sync every time. [...] The challenge now was to prove it. Only an ironclad proof would demonstrate, in a way that no computer ever could, that sync was inevitable; and the best kind of proof would clarify why it was inevitable. Strogatz is a mathematician, so his enthusiasm for proofs is understandable, but his proof doesn't address what is, to me, the most interesting part of the phenomenon. In order to prove that \sync was inevitable", Strogatz makes several simplifying assumptions, in particular that each re y can see all the others. 4 Chapter 1 Complexity Science In my opinion, it is more interesting to explain how an entire valley of re ies can synchronize despite the fact that they cannot all see each other . How this kind of global behavior emerges from local interactions is the subject of Chapter 9. Explanations of these phenomena often use agent-based models, which explore (in ways that would be dicult or impossible with mathematical analysis) the conditions that allow or prevent synchronization. I am a computer scientist, so my enthusiasm for computational models is probably no surprise. I don't mean to say that Strogatz is wrong, but rather that people have di erent opinions about what questions to ask and what tools to use to answer them. These opinions are based on value judgments, so there is no reason to expect agreement. Nevertheless, there is rough consensus among scientists about which models are considered good science, and which others are fringe science, pseudoscience, or not science at all. A central thesis of this book is that the criteria this consensus is based on change over time, and that the emergence of complexity science re ects a gradual shift in these criteria. 1.2 The axes of scienti c models I have described classical models as based on physical laws, expressed in the form of equations, and solved by mathematical analysis; conversely, models of complex systems are often based on simple rules and implemented as computations. We can think of this trend as a shift over time along two axes: Equation-based !simulation-based Analysis!computation Complexity science is di erent in several other ways. I present them here so you know what's coming, but some of them might not make sense until you have seen the examples later in the book. 1.2 The axes of scienti c models 5 Continuous!discrete Classical models tend to be based on continuous mathematics, like calculus; models of complex systems are often based on discrete mathematics, including graphs and cellular automatons. Linear!nonlinear Classical models are often linear, or use linear approximations to nonlinear systems; complexity science is more friendly to nonlinear models. Deterministic!stochastic Classical models are usually deterministic, which may re ect underlying philosophical determinism, discussed in Chapter 5; complex models often include randomness. Abstract!detailed In classical models, planets are point masses, planes are frictionless, and cows are spherical (see http://thinkcomplex.com/ cow). Simpli cations like these are often necessary for analysis, but computational models can be more realistic. One, two!many Classical models are often limited to small numbers of components. For example, in celestial mechanics the two-body problem can be solved analytically; the three-body problem cannot. Complexity science often works with large numbers of components and larger number of interactions. Homogeneous!heterogeneous In classical models, the components and interactions tend to be identical; complex models more often include heterogeneity. These are generalizations, so we should not take them too seriously. And I don't mean to deprecate classical science. A more complicated model is not necessarily better; in fact, it is usually worse. And I don't mean to say that these changes are abrupt or complete. Rather, there is a gradual migration in the frontier of what is considered acceptable, respectable work. Some tools that used to be regarded with suspicion are now common, and some models that were widely accepted are now regarded with scrutiny. For example, when Appel and Haken proved the four-color theorem in 1976, they used a computer to enumerate 1,936 special cases that were, in some sense, lemmas of their proof. At the time, many mathematicians did not consider 6 Chapter 1 Complexity Science the theorem truly proved. Now computer-assisted proofs are common and generally (but not universally) accepted. Conversely, a substantial body of economic analysis is based on a model of human behavior called \Economic man", or, with tongue in cheek, Homo economicus . Research based on this model was highly regarded for several decades, especially if it involved mathematical virtuosity. More recently, this model is treated with skepticism, and models that include imperfect information and bounded rationality are hot topics. 1.3 Di erent models for di erent purposes Complex models are often appropriate for di erent purposes and interpretations: Predictive!explanatory Schelling's model of segregation might shed light on a complex social phenomenon, but it is not useful for prediction. On the other hand, a simple model of celestial mechanics can predict solar eclipses, down to the second, years in the future. Realism!instrumentalism Classical models lend themselves to a realist interpretation; for example, most people accept that electrons are real things that exist. Instrumentalism is the view that models can be useful even if the entities they postulate don't exist. George Box wrote what might be the motto of instrumentalism: \All models are wrong, but some are useful." Reductionism!holism Reductionism is the view that the behavior of a system can be explained by understanding its components. For example, the periodic table of the elements is a triumph of reductionism, because it explains the chemical behavior of elements with a model of electrons in atoms. Holism is the view that some phenomena that appear at the system level do not exist at the level of components, and cannot be explained in component-level terms. We get back to explanatory models in Chapter 4, instrumentalism in Chapter 6, and holism in Chapter 8. 1.4 Complexity engineering 7 1.4 Complexity engineering I have been talking about complex systems in the context of science, but complexity is also a cause, and e ect, of changes in engineering and the design of social systems: Centralized!decentralized Centralized systems are conceptually simple and easier to analyze, but d