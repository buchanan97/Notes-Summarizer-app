Python for Everybody Exploring Data Using Python 3 Dr. Charles R. Severance Credits Editorial Support: Elliott Hauser, Sue Blumenberg Cover Design: Aimee Andrion Printing History • 2024-Jan-01 Update examples to Python 3.12, remove references to Twitter APIs, rewrite Databases chapter • 2023-Jun-29 Many errata included, switch from Google APIs to OpenStreetMap APIs • 2016-Jul-05 First Complete Python 3.0 version • 2015-Dec-20 Initial Python 3.0 rough conversion Copyright Details Copyright 2009- Dr. Charles R. Severance. This work is licensed under a Creative Commons Attribution-NonCommercialShareAlike 3.0 Unported License. This license is available at http://creativecommons.org/licenses/by-nc-sa/3.0/ You can see what the author considers commercial and non-commercial uses of this material as well as license exemptions in the Appendix titled “Copyright Detai l”. iii Preface Remixing an Open Book It is quite natural for academics who are continuously told to “publish or peri sh” to want to always create something from scratch that is their own fresh crea tion. This book is an experiment in not starting from scratch, but instead “remixi ng” the book titled Think Python: How to Think Like a Computer Scientist written by Allen B. Downey, Jeﬀ Elkner, and others. In December of 2009, I was preparing to teach SI502 - Networked Programming at the University of Michigan for the ﬁfth semester in a row and decided it was time to write a Python textbook that focused on exploring data instead of understanding algorithms and abstractions. My goal in SI502 is to teach people lifelong data handling skills using Python. Few of my students were planning to be professional computer programmers. Instead, they planned to be librarians, managers, lawyers, biologists, economists, etc., who happened to want to skillfully use technolog y in their chosen ﬁeld. I never seemed to ﬁnd the perfect data-oriented Python book for my course, so I set out to write just such a book. Luckily at a faculty meeting three weeks befor e I was about to start my new book from scratch over the holiday break, Dr. At ul Prakash showed me the Think Python book which he had used to teach his Python course that semester. It is a well-written Computer Science text with a focus on short, direct explanations and ease of learning. The overall book structure has been changed to get to doing data analysis problems as quickly as possible and have a series of running examples and exercises about data analysis from the very beginning. Chapters 2–10 are similar to the Think Python book, but there have been major changes. Number-oriented examples and exercises have been replaced with dataoriented exercises. Topics are presented in the order needed to build increasingly sophisticated data analysis solutions. Some topics like tryandexcept are pulled forward and presented as part of the chapter on conditionals. Functions are given very light treatment until they are needed to handle program complexity rather than introduced as an early lesson in abstraction. Nearly all user-deﬁned functions have been removed from the example code and exercises outside of Chapter 4. The word “recursion”1does not appear in the book at all. In chapters 1 and 11–16, all of the material is brand new, focusing on real-worl d uses and simple examples of Python for data analysis including regular expressions for searching and parsing, automating tasks on your computer, retrieving data across the network, scraping web pages for data, object-oriented programming, using web services, parsing XML and JSON data, creating and using databases using Structured Query Language, and visualizing data. The ultimate goal of all of these changes is to shift from a Computer Science to an Informatics focus and to only include topics into a ﬁrst technology class that can be useful even if one chooses not to become a professional programmer. 1Except, of course, for this line. iv Students who ﬁnd this book interesting and want to further explore should look at Allen B. Downey’s Think Python book. Because there is a lot of overlap between the two books, students will quickly pick up skills in the additional a reas of technical programming and algorithmic thinking that are covered in Think Python . And given that the books have a similar writing style, they should be able to move quickly through Think Python with a minimum of eﬀort. As the copyright holder of Think Python , Allen has given me permission to change the book’s license on the material from his book that remains in this book f rom the GNU Free Documentation License to the more recent Creative Commons Attribution — Share Alike license. This follows a general shift in open documentation licenses moving from the GFDL to the CC-BY-SA (e.g., Wikipedia). Using the CC-BY-SA license maintains the book’s strong copyleft tradition while mak ing it even more straightforward for new authors to reuse this material as they see ﬁt. I feel that this book serves as an example of why open materials are so impo rtant to the future of education, and I want to thank Allen B. Downey and Cambridge University Press for their forward-looking decision to make the book avai lable under an open copyright. I hope they are pleased with the results of my eﬀorts and I hope that you, the reader, are pleased with ourcollective eﬀorts. I would like to thank Allen B. Downey and Lauren Cowles for their help, patience, and guidance in dealing with and resolving the copyright issues around this book. Charles Severance www.dr-chuck.com Ann Arbor, MI, USA September 9, 2013 Charles Severance is a Clinical Associate Professor at the University of Mic higan School of Information. Contents 1 Why should you learn to write programs? 1 1.1 Creativity and motivation . . . . . . . . . . . . . . . . . . . . . . . 2 1.2 Computer hardware architecture . . . . . . . . . . . . . . . . . . . 3 1.3 Understanding programming . . . . . . . . . . . . . . . . . . . . . 4 1.4 Words and sentences . . . . . . . . . . . . . . . . . . . . . . . . . . 5 1.5 Conversing with Python . . . . . . . . . . . . . . . . . . . . . . . . 6 1.6 Terminology: Interpreter and compiler . . . . . . . . . . . . . . . . 8 1.7 Writing a program . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 1.8 What is a program? . . . . . . . . . . . . . . . . . . . . . . . . . . 10 1.9 The building blocks of programs . . . . . . . . . . . . . . . . . . . 11 1.10 What could possibly go wrong? . . . . . . . . . . . . . . . . . . . . 12 1.11 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 1.12 The learning journey . . . . . . . . . . . . . . . . . . . . . . . . . . 15 1.13 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 1.14 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 2 Variables, expressions, and statements 19 2.1 Values and types . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 2.2 Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 2.3 Variable names and keywords . . . . . . . . . . . . . . . . . . . . . 21 2.4 Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 2.5 Operators and operands . . . . . . . . . . . . . . . . . . . . . . . . 22 2.6 Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 2.7 Order of operations . . . . . . . . . . . . . . . . . . . . . . . . . . 23 2.8 Modulus operator . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 2.9 String operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 v vi CONTENTS 2.10 Asking the user for input . . . . . . . . . . . . . . . . . . . . . . . 25 2.11 Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 2.12 Choosing mnemonic variable names . . . . . . . . . . . . . . . . . 27 2.13 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 2.14 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 2.15 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 3 Conditional execution 31 3.1 Boolean expressions . . . . . . . . . . . . . . . . . . . . . . . . . . 31 3.2 Logical operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 3.3 Conditional execution . . . . . . . . . . . . . . . . . . . . . . . . . 32 3.4 Alternative execution . . . . . . . . . . . . . . . . . . . . . . . . . 34 3.5 Chained conditionals . . . . . . . . . . . . . . . . . . . . . . . . . . 34 3.6 Nested conditionals . . . . . . . . . . . . . . . . . . . . . . . . . . 35 3.7 Catching exceptions using try and except . . . . . . . . . . . . . . 36 3.8 Short-circuit evaluation of logical expressions . . . . . . . . . . . . 38 3.9 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 3.10 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 3.11 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 4 Functions 43 4.1 Function calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 4.2 Built-in functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 4.3 Type conversion functions . . . . . . . . . . . . . . . . . . . . . . . 44 4.4 Math functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 4.5 Random numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 4.6 Adding new functions . . . . . . . . . . . . . . . . . . . . . . . . . 47 4.7 Deﬁnitions and uses . . . . . . . . . . . . . . . . . . . . . . . . . . 48 4.8 Flow of execution . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 4.9 Parameters and arguments . . . . . . . . . . . . . . . . . . . . . . 49 4.10 Fruitful functions and void functions . . . . . . . . . . . . . . . . . 51 4.11 Why functions? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 4.12 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 4.13 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 4.14 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 CONTENTS vii 5 Iteration 57 5.1 Updating variables . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 5.2 The while statement . . . . . . . . . . . . . . . . . . . . . . . . . 57 5.3 Inﬁnite loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58 5.4 Finishing iterations with continue . . . . . . . . . . . . . . . . . . 59 5.5 Deﬁnite loops using for. . . . . . . . . . . . . . . . . . . . . . . . 60 5.6 Loop patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 5.6.1 Counting and summing loops . . . . . . . . . . . . . . . . . 61 5.6.2 Maximum and minimum loops . . . . . . . . . . . . . . . . 62 5.7 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64 5.8 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64 5.9 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64 6 Strings 67 6.1 A string is a sequence . . . . . . . . . . . . . . . . . . . . . . . . . 67 6.2 Getting the length of a string using len . . . . . . . . . . . . . . . 68 6.3 Traversal through a string with a loop . . . . . . . . . . . . . . . . 68 6.4 String slices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 6.5 Strings are immutable . . . . . . . . . . . . . . . . . . . . . . . . . 70 6.6 Looping and counting . . . . . . . . . . . . . . . . . . . . . . . . . 70 6.7 The inoperator . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71 6.8 String comparison . . . . . . . . . . . . . . . . . . . . . . . . . . . 71 6.9 String methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71 6.10 Parsing strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74 6.11 Formatted String Literals . . . . . . . . . . . . . . . . . . . . . . . 74 6.12 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75 6.13 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76 6.14 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76 7 Files 79 7.1 Persistence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79 7.2 Opening ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79 7.3 Text ﬁles and lines . . . . . . . . . . . . . . . . . . . . . . . . . . . 81 7.4 Reading ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82 7.5 Searching through a ﬁle . . . . . . . . . . . . . . . . . . . . . . . . 83 viii CONTENTS 7.6 Letting the user choose the ﬁle name . . . . . . . . . . . . . . . . . 85 7.7 Using try, except, andopen . . . . . . . . . . . . . . . . . . . . 86 7.8 Writing ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87 7.9 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88 7.10 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89 7.11 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89 8 Lists 91 8.1 A list is a sequence . . . . . . . . . . . . . . . . . . . . . . . . . . . 91 8.2 Lists are mutable . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92 8.3 Traversing a list . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92 8.4 List operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93 8.5 List slices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94 8.6 List methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94 8.7 Deleting elements . . . . . . . . . . . . . . . . . . . . . . . . . . . 95 8.8 Lists and functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 96 8.9 Lists and strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97 8.10 Parsing lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98 8.11 Objects and values . . . . . . . . . . . . . . . . . . . . . . . . . . . 99 8.12 Aliasing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100 8.13 List arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100 8.14 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102 8.15 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 8.16 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 9 Dictionaries 109 9.1 Dictionary as a set of counters . . . . . . . . . . . . . . . . . . . . 111 9.2 Dictionaries and ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . 112 9.3 Looping and dictionaries . . . . . . . . . . . . . . . . . . . . . . . 114 9.4 Advanced text parsing . . . . . . . . . . . . . . . . . . . . . . . . . 115 9.5 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116 9.6 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117 9.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117 CONTENTS ix 10 Tuples 119 10.1 Tuples are immutable . . . . . . . . . . . . . . . . . . . . . . . . . 119 10.2 Comparing tuples . . . . . . . . . . . . . . . . . . . . . . . . . . . 120 10.3 Tuple assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122 10.4 Dictionaries and tuples . . . . . . . . . . . . . . . . . . . . . . . . 123 10.5 Multiple assignment with dictionaries . . . . . . . . . . . . . . . . 124 10.6 The most common words . . . . . . . . . . . . . . . . . . . . . . . 125 10.7 Using tuples as keys in dictionaries . . . . . . . . . . . . . . . . . . 126 10.8 Sequences: strings, lists, and tuples - Oh My! . . . . . . . . . . . . 126 10.9 List comprehension . . . . . . . . . . . . . . . . . . . . . . . . . . 127 10.10 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128 10.11 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128 10.12 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128 11 Regular expressions 131 11.1 Character matching in regular expressions . . . . . . . . . . . . . . 132 11.2 Extracting data using regular expressions . . . . . . . . . . . . . . 133 11.3 Combining searching and extracting . . . . . . . . . . . . . . . . . 136 11.4 Escape character . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140 11.5 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140 11.6 Bonus section for Unix / Linux users . . . . . . . . . . . . . . . . . 141 11.7 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142 11.8 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142 11.9 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143 12 Networked programs 145 12.1 Hypertext Transfer Protocol - HTTP . . . . . . . . . . . . . . . . 145 12.2 The world’s simplest web browser . . . . . . . . . . . . . . . . . . 146 12.3 Retrieving an image over HTTP . . . . . . . . . . . . . . . . . . . 148 12.4 Retrieving web pages with urllib . . . . . . . . . . . . . . . . . . 150 12.5 Reading binary ﬁles using urllib . . . . . . . . . . . . . . . . . . 151 12.6 Parsing HTML and scraping the web . . . . . . . . . . . . . . . . 152 12.7 Parsing HTML using regular expressions . . . . . . . . . . . . . . 152 12.8 Parsing HTML using BeautifulSoup . . . . . . . . . . . . . . . . . 154 12.9 Bonus section for Unix / Linux users . . . . . . . . . . . . . . . . . 157 12.10 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157 12.11 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158 x CONTENTS 13 Using Web Services 159 13.1 eXtensible Markup Language - XML . . . . . . . . . . . . . . . . . 159 13.2 Parsing XML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160 13.3 Looping through nodes . . . . . . . . . . . . . . . . . . . . . . . . 161 13.4 JavaScript Object Notation - JSON . . . . . . . . . . . . . . . . . 162 13.5 Parsing JSON . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163 13.6 Application Programming Interfaces . . . . . . . . . . . . . . . . . 164 13.7 Security and API usage . . . . . . . . . . . . . . . . . . . . . . . . 165 13.8 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166 14 Object-oriented programming 167 14.1 Managing larger programs . . . . . . . . . . . . . . . . . . . . . . . 167 14.2 Getting started . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168 14.3 Using objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168 14.4 Starting with programs . . . . . . . . . . . . . . . . . . . . . . . . 169 14.5 Subdividing a problem . . . . . . . . . . . . . . . . . . . . . . . . . 171 14.6 Our ﬁrst Python object . . . . . . . . . . . . . . . . . . . . . . . . 171 14.7 Classes as types . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174 14.8 Object lifecycle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175 14.9 Multiple instances . . . . . . . . . . . . . . . . . . . . . . . . . . . 176 14.10 Inheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177 14.11 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178 14.12 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179 15 Using Databases and SQL 181 15.1 What is a database? . . . . . . . . . . . . . . . . . . . . . . . . . . 181 15.2 Database concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . 181 15.3 Database Browser for SQLite . . . . . . . . . . . . . . . . . . . . . 182 15.4 Creating a database table . . . . . . . . . . . . . . . . . . . . . . . 182 15.5 Structured Query Language summary . . . . . . . . . . . . . . . . 185 15.6 Multiple tables and basic data modeling . . . . . . . . . . . . . . . 187 15.7 Data model diagrams . . . . . . . . . . . . . . . . . . . . . . . . . 189 15.8 Automatically creating primary keys . . . . . . . . . . . . . . . . . 190 15.9 Logical keys for fast lookup . . . . . . . . . . . . . . . . . . . . . . 191 15.10 Adding constraints to the database . . . . . . . . . . . . . . . . . . 192 CONTENTS xi 15.11 Sample multi-table application . . . . . . . . . . . . . . . . . . . . 193 15.12 Many to many relationships in databases . . . . . . . . . . . . . . 196 15.13 Modeling data at the many-to-many connection . . . . . . . . . . 200 15.14 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201 15.15 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202 15.16 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202 16 Visualizing data 205 16.1 Building a OpenStreetMap from geocoded data . . . . . . . . . . . 205 16.2 Visualizing networks and interconnections . . . . . . . . . . . . . . 207 16.3 Visualizing mail data . . . . . . . . . . . . . . . . . . . . . . . . . 210 A Contributions 217 A.1 Translations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217 A.2 Contributor List for Python for Everybody . . . . . . . . . . . . . 217 A.3 Contributor List for Python for Informatics . . . . . . . . . . . . . 218 A.4 Preface for “Think Python” . . . . . . . . . . . . . . . . . . . . . . 218 A.4.1 The strange history of “Think Python” . . . . . . . . . . . 218 A.4.2 Acknowledgements for “Think Python” . . . . . . . . . . . 219 A.5 Contributor List for “Think Python” . . . . . . . . . . . . . . . . . 220 B Copyright Detail 221 xii CONTENTS Chapter 1 Why should you learn to write programs? Writing programs (or programming) is a very creative and rewarding activi ty. You can write programs for many reasons, ranging from making your living to solving a diﬃcult data analysis problem to having fun to helping someone else solve a problem. This book assumes that everyone needs to know how to program, and that once you know how to program you will ﬁgure out what you want to do with your newfound skills. We are surrounded in our daily lives with computers ranging from laptops to cell phones. We can think of these computers as our “personal assistants” who can take care of many things on our behalf. The hardware in our current-day computers is essentially built to continuously ask us the question, “What would you like m e to do next?” Programmers add an operating system and a set of applications to the hardware and we end up with a Personal Digital Assistant that is quite helpful and capable of helping us do many diﬀerent things. Our computers are fast and have vast amounts of memory and could be very helpful to us if we only knew the language to speak to explain to the computer what we would like it to “do next”. If we knew this language, we could tell the computer to do tasks on our behalf that were repetitive. Interestingly, the kinds of thing s computers can do best are often the kinds of things that we humans ﬁnd boring and mind-numbing. What Next? What Next? What Next? What Next? What Next? What Next? Figure 1.1: Personal Digital Assistant 2 CHAPTER 1. WHY SHOULD YOU LEARN TO WRITE PROGRAMS? Pick Pick Me! Pick Pick Me! Pick Buy Me :) Figure 1.2: Programmers Talking to You For example, look at the ﬁrst three paragraphs of this chapter and tell me the most commonly used word and how many times the word is used. While you were able to read and understand the words in a few seconds, counting them is almost painful because it is not the kind of problem that human minds are designed to solve. For a computer, the opposite is true, reading and understanding text from a piece of paper is hard for a computer to do but counting the words and telling you how many times the most used word was used is very easy for the computer: python words.py Enter file: words.txt to16 Our “personal information analysis assistant” quickly told us that the word “to” was used sixteen times in the ﬁrst three paragraphs of this chapter. This very fact that computers are good at things that humans are not is why you need to become skilled at talking “computer language”. Once you learn this new language, you can delegate mundane tasks to your partner (the computer), leaving more time for you to do the things that you are uniquely suited for. You bring creativity, intuition, and inventiveness to this partnership. 1.1 Creativity and motivation While this book is not intended for professional programmers, professional pr ogramming can be a very rewarding job both ﬁnancially and personally. Building useful, elegant, and clever programs for others to use is a very creative activit y. Your computer or Personal Digital Assistant (PDA) usually contains many different programs from many diﬀerent groups of programmers, each competing fo r your attention and interest. They try their best to meet your needs and give you a great user experience in the process. In some situations, when you choose a piece of software, the programmers are directly compensated because of your choice. If we think of programs as the creative output of groups of programmers, perhaps the following ﬁgure is a more sensible version of our PDA: For now, our primary motivation is not to make money or please end users, but instead for us to be more productive in handling the data and information that we will encounter in our lives. When you ﬁrst start, you will be both the progra mmer and the end user of your programs. As you gain skill as a programmer and programming feels more creative to you, your thoughts may turn toward developing programs for others. 1.2. COMPUTER HARDWARE ARCHITECTURE 3 Input and Output Devices Software Main Memory Central Processing Unit What Next? Network Secondary Memory Figure 1.3: Hardware Architecture 1.2 Computer hardware architecture Before we start learning the language we speak to give instructions to computer s to develop software, we need to learn a small amount about how computers are built. If you were to take apart your computer or cell phone and look deep inside, you would ﬁnd the following parts: The high-level deﬁnitions of these parts are as follows: • The Central Processing Unit (or CPU) is the part of the computer that is built to be obsessed with “what is next?” If your computer is rated at 3.0 Gigahertz, it means that the CPU will ask “What next?” three billion times per second. You are going to have to learn how to talk fast to keep up with the CPU. • The Main Memory is used to store information that the CPU needs in a hurry. The main memory is nearly as fast as the CPU. But the information stored in the main memory vanishes when the computer is turned oﬀ. • The Secondary Memory is also used to store information, but it is much slower than the main memory. The advantage of the secondary memory is that it can store information even when there is no power to the computer. Examples of secondary memory are disk drives or ﬂash memory (typically found in USB sticks and portable music players). • The Input and Output Devices are simply our screen, keyboard, mouse, microphone, speaker, touchpad, etc. They are all of the ways we interact with the computer. • These days, most computers also have a Network Connection to retrieve information over a network. We can think of the network as a very slow place to store and retrieve data that might not always be “up”. So in a sense, the network is a slower and at times unreliable form of Secondary Memory . While most of the detail of how these components work is best left to computer builders, it helps to have some terminology so we can talk about these diﬀerent parts as we write our programs. 4 CHAPTER 1. WHY SHOULD YOU LEARN TO WRITE PROGRAMS? Input and Output Devices Software Main Memory Central Processing Unit What Next? Network Secondary Memory Figure 1.4: Where Are You? As a programmer, your job is to use and orchestrate each of these resources to solve the problem that you need to solve and analyze the data you get from the solution. As a programmer you will mostly be “talking” to the CPU and t elling it what to do next. Sometimes you will tell the CPU to use the main memory, secondary memory, network, or the input/output devices. You need to be the person who answers the CPU’s “What next?” question. But it would be very uncomfortable to shrink you down to 5mm tall and insert you int o the computer just so you could issue a command three billion times per second. So instead, you must write down your instructions in advance. We call these stored instructions a program and the act of writing these instructions down and getting the instructions to be correct programming . 1.3 Understanding programming In the rest of this book, we will try to turn you into a person who is ski lled in the art of programming. In the end you will be a programmer - perhaps not a professional programmer, but at least you will have the skills to look at a data/infor mation analysis problem and develop a program to solve the problem. In a sense, you need two skills to be a programmer: • First, you need to know the programming language (Python) - you need to know the vocabulary and the grammar. You need to be able to spell the words in this new language properly and know how to construct well-formed “sentences” in this new language. • Second, you need to “tell a story”. In writing a story, you combine words and sentences to convey an idea to the reader. There is a skill and art in constructing the story, and skill in story writing is improved by doing som e writing and getting some feedback. In programming, our program is the “story” and the problem you are trying to solve is the “idea”. Once you learn one programming language such as Python, you will ﬁnd it much easier to learn a second programming language such as JavaScript or C++. The 1.4. WORDS AND SENTENCES 5 new programming language has very diﬀerent vocabulary and grammar but the problem-solving skills will be the same across all programming languages . You will learn the “vocabulary” and “sentences” of Python pretty quickly. It w ill take longer for you