Deep into Pharo Alexandre Bergel Damien Cassou Stéphane Ducasse Jannik Laval ii This book is available as a free download from: http://deepintopharo.com Copyright © 2013 by Alexandre Bergel, Damien Cassou, Stéphane Ducasse and Jannik Laval. The contents of this book are protected under Creative Commons Attribution-ShareAlike 3.0 Unported license. You are free: to Share — to copy, distribute and transmit the work to Remix — to adapt the work Under the following conditions: Attribution. You must attribute the work in the manner speciﬁed by the author or licensor (but not in any way that suggests that they endorse you or your use of the work). Share Alike. If you alter, transform, or build upon this work, you may distribute the resulting work only under the same, similar or a compatible license. • For any reuse or distribution, you must make clear to others the license terms of this work. The best way to do this is with a link to this web page: creativecommons.org/licenses/ by-sa/3.0/ • Any of the above conditions can be waived if you get permission from the copyright holder. • Nothing in this license impairs or restricts the author’s moral rights. Your fair dealing and other rights are in no way affected by the above. This is a human-readable summary of the Legal Code (the full license): creativecommons.org/licenses/by-sa/3.0/legalcode Published by Square Bracket Associates, Switzerland. http://SquareBracketAssociates.org ISBN 978-3-9523341-6-4 First Edition, August, 2013. Cover art by Jérôme Bergel (jeromebergel@gmail.com). Contents 1 Preface 1 I Libraries 2 Zero Conﬁguration Scripts and Command-Line Handlers 7 2.1 Getting the VM and the Image . . . . . . . . . . . . 7 2.2 Getting the VM only . . . . . . . . . . . . . . . . 9 2.3 Handling command line options . . . . . . . . . . . 9 2.4 Anatomy of a handler . . . . . . . . . . . . . . . 12 2.5 Using ZeroConf script with Jenkins . . . . . . . . . . 13 2.6 Chapter summary. . . . . . . . . . . . . . . . . 14 3 Files with FileSystem 15 3.1 Getting started . . . . . . . . . . . . . . . . . . 15 3.2 Navigating a ﬁle system . . . . . . . . . . . . . . 16 3.3 Opening read and write Streams . . . . . . . . . . . 19 3.4 Renaming, copying and deleting ﬁles and directories . . . . 20 3.5 The main entry point: FileReference . . . . . . . . . . 21 3.6 Looking at FileSystem internals . . . . . . . . . . . . 27 3.7 Chapter summary. . . . . . . . . . . . . . . . . 29 4 Sockets 31 4.1 Basic Concepts . . . . . . . . . . . . . . . . . . 31 4.2 TCP Client . . . . . . . . . . . . . . . . . . . 33 4.3 TCP Server . . . . . . . . . . . . . . . . . . . 37 iv Contents 4.4 SocketStream . . . . . . . . . . . . . . . . . . 43 4.5 Tips for Networking Experiments . . . . . . . . . . . 48 4.6 Chapter summary. . . . . . . . . . . . . . . . . 49 5 The Settings Framework 51 5.1 Settings architecture . . . . . . . . . . . . . . . . 51 5.2 The Settings Browser. . . . . . . . . . . . . . . . 53 5.3 Declaring a setting . . . . . . . . . . . . . . . . 56 5.4 Organizing your settings . . . . . . . . . . . . . . 61 5.5 Providing more precise value domain . . . . . . . . . 65 5.6 Launching a script . . . . . . . . . . . . . . . . 68 5.7 Start-up actions management . . . . . . . . . . . . 69 5.8 Extending the Settings Browser . . . . . . . . . . . . 71 5.9 Chapter summary. . . . . . . . . . . . . . . . . 75 6 Regular Expressions in Pharo 77 6.1 Tutorial example — generating a site map . . . . . . . . 78 6.2 Regex syntax . . . . . . . . . . . . . . . . . . 85 6.3 Regex API . . . . . . . . . . . . . . . . . . . 90 6.4 Implementation notes by Vassili Bykov . . . . . . . . . 96 6.5 Chapter summary. . . . . . . . . . . . . . . . . 97 II Source Management 7 Versioning Your Code with Monticello 101 7.1 Basic usage . . . . . . . . . . . . . . . . . . . 102 7.2 Exploring Monticello repositories . . . . . . . . . . . 113 7.3 Advanced topics . . . . . . . . . . . . . . . . . 115 7.4 Getting a change set from two versions . . . . . . . . . 120 7.5 Kinds of repositories . . . . . . . . . . . . . . . . 121 7.6 The .mcz ﬁle format . . . . . . . . . . . . . . . . 124 7.7 Chapter summary. . . . . . . . . . . . . . . . . 126 8 Gofer: Scripting Package Loading 129 8.1 Preamble: Package management system. . . . . . . . . 129 v 8.2 What is Gofer? . . . . . . . . . . . . . . . . . . 132 8.3 Using Gofer . . . . . . . . . . . . . . . . . . . 133 8.4 Gofer actions . . . . . . . . . . . . . . . . . . 135 8.5 Some useful scripts . . . . . . . . . . . . . . . . 141 8.6 Chapter summary. . . . . . . . . . . . . . . . . 144 9 Managing Projects with Metacello 147 9.1 Introduction . . . . . . . . . . . . . . . . . . . 147 9.2 One tool for each job . . . . . . . . . . . . . . . . 148 9.3 Metacello features. . . . . . . . . . . . . . . . . 149 9.4 A simple case study . . . . . . . . . . . . . . . . 151 9.5 Loading a Metacello Conﬁguration . . . . . . . . . . 154 9.6 Managing dependencies between packages . . . . . . . 155 9.7 Baselines . . . . . . . . . . . . . . . . . . . . 157 9.8 Groups. . . . . . . . . . . . . . . . . . . . . 160 9.9 Dependencies between projects . . . . . . . . . . . . 163 9.10 About dependency granularity . . . . . . . . . . . . 169 9.11 Executing code before and after installation . . . . . . . 171 9.12 Platform speciﬁc package . . . . . . . . . . . . . . 172 9.13 Milestoning development: symbolic versions . . . . . . . 176 9.14 Load types . . . . . . . . . . . . . . . . . . . 181 9.15 Conditional loading . . . . . . . . . . . . . . . . 183 9.16 Project version attributes . . . . . . . . . . . . . . 185 9.17 Chapter summary. . . . . . . . . . . . . . . . . 186 III Frameworks 10 Glamour 191 10.1 Installation and ﬁrst browser . . . . . . . . . . . . . 191 10.2 Presentation, Transmission and Ports . . . . . . . . . . 194 10.3 Composing and Interaction . . . . . . . . . . . . . 200 10.4 Chapter summary. . . . . . . . . . . . . . . . . 207 11 Agile Visualization with Roassal 209 11.1 Installation and ﬁrst visualization . . . . . . . . . . . 209 vi Contents 11.2 Roassal core model . . . . . . . . . . . . . . . . 212 11.3 Detailing shapes . . . . . . . . . . . . . . . . . 218 11.4 Edges: linking elements . . . . . . . . . . . . . . 221 11.5 Layouts . . . . . . . . . . . . . . . . . . . . 224 11.6 Events and Callbacks . . . . . . . . . . . . . . . 230 11.7 The interaction hierarchy . . . . . . . . . . . . . . 231 11.8 Understanding a View’s Camera . . . . . . . . . . . 234 11.9 Beyond Pharo . . . . . . . . . . . . . . . . . . 238 11.10 Chapter summary. . . . . . . . . . . . . . . . . 239 12 Scripting Visualizations with Mondrian 241 12.1 Installation and ﬁrst visualization . . . . . . . . . . . 241 12.2 Starting with Mondrian. . . . . . . . . . . . . . . 242 12.3 Visualizing the Collection framework . . . . . . . . . 247 12.4 Reshaping nodes . . . . . . . . . . . . . . . . . 248 12.5 Multiple edges . . . . . . . . . . . . . . . . . . 249 12.6 Colored shapes . . . . . . . . . . . . . . . . . . 251 12.7 More on colors . . . . . . . . . . . . . . . . . . 252 12.8 Popup view . . . . . . . . . . . . . . . . . . . 253 12.9 Subviews . . . . . . . . . . . . . . . . . . . . 255 12.10 Forwarding events . . . . . . . . . . . . . . . . 256 12.11 Events . . . . . . . . . . . . . . . . . . . . . 257 12.12 Interaction . . . . . . . . . . . . . . . . . . . 257 12.13 Chapter summary. . . . . . . . . . . . . . . . . 259 IV Language 13 Handling Exceptions 263 13.1 Introduction . . . . . . . . . . . . . . . . . . . 263 13.2 Ensuring execution . . . . . . . . . . . . . . . . 264 13.3 Handling non-local returns . . . . . . . . . . . . . 265 13.4 Exception handlers . . . . . . . . . . . . . . . . 266 13.5 Error codes — don’t do this! . . . . . . . . . . . . . 268 13.6 Specifying which exceptions will be handled . . . . . . . 269 vii 13.7 Signaling an exception . . . . . . . . . . . . . . . 271 13.8 Finding handlers . . . . . . . . . . . . . . . . . 273 13.9 Handling exceptions . . . . . . . . . . . . . . . . 275 13.10 Comparing outer with pass . . . . . . . . . . . . . . 281 13.11 Exceptions and ensure:/ifCurtailed: interaction . . . . . . . 282 13.12 Example: Deprecation . . . . . . . . . . . . . . . 284 13.13 Example: Halt implementation . . . . . . . . . . . . 285 13.14 Speciﬁc exceptions . . . . . . . . . . . . . . . . 286 13.15 When not to use exceptions . . . . . . . . . . . . . 288 13.16 Exceptions implementation . . . . . . . . . . . . . 289 13.17 Ensure:’s implementation . . . . . . . . . . . . . . 295 13.18 Chapter summary. . . . . . . . . . . . . . . . . 300 14 Blocks: a Detailed Analysis 303 14.1 Basics . . . . . . . . . . . . . . . . . . . . . 304 14.2 Variables and blocks . . . . . . . . . . . . . . . . 306 14.3 Variables can outlive their deﬁning method . . . . . . . 313 14.4 Returning from inside a block . . . . . . . . . . . . 314 14.5 Contexts: representing method execution . . . . . . . . 320 14.6 Message execution . . . . . . . . . . . . . . . . 323 14.7 Chapter conclusion . . . . . . . . . . . . . . . . 326 15 Exploring Little Numbers 329 15.1 Power of 2 and Numbers . . . . . . . . . . . . . . 329 15.2 Bit shifting is multiplying by 2 powers . . . . . . . . . 331 15.3 Bit manipulation and access . . . . . . . . . . . . . 333 15.4 Ten’s complement of a number . . . . . . . . . . . . 335 15.5 Negative numbers . . . . . . . . . . . . . . . . 336 15.6 Two’s complement of a number . . . . . . . . . . . . 337 15.7 SmallIntegers in Pharo . . . . . . . . . . . . . . . 340 15.8 Hexadecimal . . . . . . . . . . . . . . . . . . 342 15.9 Chapter summary. . . . . . . . . . . . . . . . . 342 viii Contents 16 Fun with Floats 345 16.1 Never test equality on ﬂoats . . . . . . . . . . . . . 345 16.2 Dissecting a Float . . . . . . . . . . . . . . . . . 347 16.3 With ﬂoats, printing is inexact . . . . . . . . . . . . 351 16.4 Float rounding is also inexact . . . . . . . . . . . . 352 16.5 Fun with inexact representations . . . . . . . . . . . 353 16.6 Chapter summary. . . . . . . . . . . . . . . . . 354 V Tools 17 Proﬁling Applications 357 17.1 What does proﬁling mean? . . . . . . . . . . . . . 357 17.2 A simple example . . . . . . . . . . . . . . . . . 358 17.3 Code proﬁling in Pharo. . . . . . . . . . . . . . . 359 17.4 Read and interpret the results . . . . . . . . . . . . 362 17.5 Illustrative analysis . . . . . . . . . . . . . . . . 367 17.6 Counting messages . . . . . . . . . . . . . . . . 369 17.7 Memorized Fibonacci . . . . . . . . . . . . . . . 369 17.8 SpaceTally for memory consumption per Class . . . . . . 371 17.9 Few advices . . . . . . . . . . . . . . . . . . . 372 17.10 How MessageTally is implemented? . . . . . . . . . . 372 17.11 Chapter summary. . . . . . . . . . . . . . . . . 373 18 PetitParser: Building Modular Parsers 375 18.1 Writing parsers with PetitParser . . . . . . . . . . . 375 18.2 Composite grammars with PetitParser . . . . . . . . . 384 18.3 Testing a grammar . . . . . . . . . . . . . . . . 389 18.4 Case Study: A JSON Parser . . . . . . . . . . . . . 391 18.5 PetitParser Browser . . . . . . . . . . . . . . . . 397 18.6 Packrat Parsers . . . . . . . . . . . . . . . . . . 409 18.7 Chapter summary. . . . . . . . . . . . . . . . . 409 19 Biographies 411 Chapter 1 Preface “Smalltalk is well known as an excellent tool for agile and exploratory programming. In this book the authors present a new dialect of Smalltalk called Pharo that has been speciﬁcally designed for inventive developers. The authors are key members of the Pharo team and accomplished Object Oriented educators, researchers and designers. Numerous Smalltalk projects from the authors and others have been ported to Pharo. Enjoy Deep Into Pharo” - Dave Thomas1Using a programming language is so far the most convenient way for a human to tell a computer what it should do. Pharo is an object-oriented programming language, highly inﬂuenced by Smalltalk. Pharo is more than a syntax and a bunch of semantics rules as most programming languages are. Pharo comes with an extensible and ﬂexible programming environment. Thanks to its numerous object-oriented libraries and frameworks, Pharo shines for modeling and visualizing data, scripting, networking and many other ranges of applications. The very light syntax and the malleable object model of Pharo are commonly praised. Both early learners and experienced programmers enjoy the “everything is an object” paradigm. The simplicity and expressiveness of Pharo as well as a living environment empowers programmers with a wonderful and unique experience. Deep into Pharo is the second volume of a book series initiated with Pharo by Example2. Deep into Pharo, the book you are reading, accompa1David ( http://www.davethomas.net ) is a well-known ﬁgure in modern software development and object technology. Thomas is perhaps best known as the founder and past CEO of Object Technology International, Inc., now IBM OTI Labs. OTI was responsible for initial development of the Eclipse open source IDE and the Visual Age Java development environment. 2freely available from http://pharobyexample.org 2 Preface nies the reader for a fantastic journey into exciting parts of Pharo. It covers new libraries such as FileSystem, frameworks such as Roassal and Glamour, complex of the system aspects such as exceptions and blocks. The book is divided into 5 parts and 17 chapters. The ﬁrst part deals with truly object-oriented libraries. The second part is about source code management. The third part is about advanced frameworks. The fourth part covers advanced topics of the language, in particular exception, blocks and numbers. The ﬁfth and last part is about tooling, including proﬁling and parsing. Pharo is supported by a strong community that grows daily. Pharo’s community is active, innovative, and is always pushing limits of software engineering. The Pharo community consists of software engineering software, casual programmers but also high-level consultants, researchers, and teachers. This book exists because of the Pharo community and we naturally dedicate this book to this group of people that many of us consider as our second family. Acknowledgments We would like to thank various people who have contributed to this book. In particular, we would like to thank: • Camillo Bruni for his participation in the Zero Conﬁguration chapter. • Noury Bouraqadi and Luc Fabresse for the Socket chapter. • Alain Plantec for his effort in the Setting Framework chapter and his effort to integrate it into Pharo. • Oscar Nierstrasz for writing and co-editing some chapters such as Regex and Monticello. • Dale Henrichs and Mariano Martinez Peck for their participation in the Metacello chapter. • Tudor Doru Girba for the Glamour chapter and the ﬁrst documentation. • Clément Bera for his effort on the Exception chapter. • Nicolas Cellier for his participation in the Fun with Floats chapter. • Lukas Renggli for PetitParser and his work on the refactoring engine and smallLint rules. • Jan Kurs and Guillaume Larcheveque for their participation in the PetitParser chapter. • Colin Putney for the initial version of FileSystem and Camillo Bruni for his review of FileSystem and his rewrite of the Pharo Core. • Vanessa Peña for her participation in the Roassal and Mondrian chapters. • Renato Cerro for his help in proofreading and editing. • You, for your questions, support, bug ﬁxes, contribution, and encouragement. We would like to also thank Hernan Wilkinson and Carlos Ferro for their reviews, Nicolas Cellier for the feedback on the number chapter, and Vassili Bykov for permission to adapt his Regex documentation We thank Inria Lille Nord Europe for supporting this open-source project and for hosting the web site of this book. We also thank Object Proﬁle for sponsoring the cover. And last but not least, we also thank the Pharo community for its enthusiastic support of this project, and for informing us of the errors found in the ﬁrst edition of this book. We are also grateful to our respective institutions and national research agencies for their support and offered facilities. In particular, we thank Program U-INICIA 11/06 VID 2011, University of Chile, and FONDECYT project 1120094. We also thank the Plomo Équipe Associée. Part I Libraries Chapter 2 Zero Conﬁguration Scripts and Command-Line Handlers with the participation of: Camillo Bruni (camillobruni@gmail.com) Weren’t you fed up not be able to install Pharo from a single command line or to pass it arguments? Using a nice debugger and an interactive environment development does not mean that Pharo developers do not value automatic scripts and love the command line. Yes we do and we want the best of both worlds! We really wanted it to free our mind of retaining arbitrary information. A zero conﬁguration is a script that automatically downloads everything you need to get started. Since version 2.0, Pharo also supports a way to deﬁne and handle command line arguments. This chapter shows how to get the zeroconf scripts for Pharo as well as how you can pass arguments to the environment from the command-line. 2.1 Getting the VM and the Image First here is a way to download a zero conﬁguration script to download the latest 2.0 Pharo image and vm. wget get.pharo.org/20+vm If you do not have wget installed you can use curl-Linstead. 8 Zero Conﬁguration Scripts and Command-Line Handlers To execute the script that we just downloaded, you should change its permissions using chmod a+x or invoke it via bash as follows. Conﬁgurations. There is a plethora of conﬁgurations available. The URL for each script can be easily built from an image version and a vm following the expression: get.pharo.org/$IMAGE+$VM Possible values for $IMAGE are: 12 13 14 20 30 stable alpha Possible values for $VM are: vm vmS vmLatest vmSLatest Of course, one can just download an image as well get.pharo.org/$IMAGE or just the VM get.pharo.org/$VM Looking at the help. Now let’s have a look at the script help. bash 20+vm --help The help says that the 20+vm command downloads the current virtual machine and puts it into the pharo-vm folder. In addition, it creates several scripts: pharo to launch the system, pharo-uia script to launch the image in UI mode. Finally, it also downloads the latest image and changes ﬁles. This script downloads the latest Pharo 20 Image. This script downloads the latest Pharo VM. The following artifacts are created: Pharo.changes A changes ﬁle for the Pharo Image Pharo.image A Pharo image, to be opened with the Pharo VM pharo Script to run the downloaded VM in headless mode pharo-ui Script to run the downloaded VM in UI mode pharo-vm/ Directory containing the VM Grabbing and executing it. If you just want to directly execute the script you can also do the following wget-O-get.pharo.org/20+vm | bash The option -O-will output the downloaded bash ﬁle to standard out, so we can pipe it to bash. If you do not like the log of web, use --quiet. wget--quiet-O-get.pharo.org/20+vm | bash Note for the believers in automated tasks. The scripts are fetched automatically from our Jenkins server ( https://ci.inria.fr/pharo/job/Scripts-download/ ) from the gitorious server https://gitorious.org/pharo-build/pharo-build . Yes we believe in automated tasks that free our energy. Getting the VM only 9 2.2 Getting the VM only You can also use different scripts. For example get.pharo.org/vm only downloads the latest vm. wget-O-get.pharo.org/vm | bash As any script you can always check its help message. This script downloads the latest Pharo VM. The following artifacts are created: pharo Script to run the downloaded VM in headless mode pharo-ui Script to run the downloaded VM in UI mode pharo-vm/ Directory containing the VM Figure 2.1 shows the list of scripts available that you can get at http://get.pharo.org . 2.3 Handling command line options We have a brand new and nice way to handle command line arguments. It is self-documented and easily extendable. Let us have a look at how the command line is handled. As usual we will start by showing you how to ﬁnd your way alone. How to ﬁnd our way Because we highly value self-documentation, just use the --help option to get an explanation. ./pharo Pharo.image --help It will produce the following output. Usage: [<subcommand>] [ --help] [ --copyright] [ --version] [ --list] --help print this help message --copyright print the copyrights --version print the version for the image and the vm --list list a description of all active command line handlers <subcommand> a valid subcommand in --list Documentation: A DefaultCommandLineHandler handles default command line arguments and options. The DefaultCommandLineHandler is activated before all other handlers. It ﬁrst checks if another handler is available. If so it will activate the found handler. 10 Zero Conﬁguration Scripts and Command-Line Handlers Figure 2.1: All the scripts are available at http://get.pharo.org . System version and handler list Two of the default options are important versions and list. Let us have a look at them now. Getting system version. A typical and important command line option is --version . Please use it when you report bugs and deviant behavior. ./pharo Pharo.image --version M: NBCoInterpreter NativeBoost -CogPlugin -IgorStasenko.15 uuid: 44b6b681 -38f14a9e-b6ee-8769b499576a Dec 18 2012 Handling command line options 11 NBCogit NativeBoost -CogPlugin -IgorStasenko.15 uuid: 44b6b681 -38f1-4a9e-b6ee8769b499576a Dec 18 2012 git://gitorious.org/cogvm/blessed.git Commit: 452863 bdfba2ba0b188e7b172e9bc597a2caa928 Date: 2012 -12-07 16:49:46 +0100 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #5922 The--version argument gives the version of the virtual machine. If you wish to obtain the version of the image, then you need to open the image, use the World menu, and select About. List of available handlers. The command line option --listlists of the current option handlers. This list depends on the handlers that are currently loaded in the system. In particular, it means that you can simply add a handler for your speciﬁc situation and wishes. The following list shows the available handlers. ./pharo Pharo.image --list Currently installed Command Line Handlers: st Loads and executes .st source ﬁles Fuel Loads fuel ﬁles conﬁg Install and inspect Metacello Conﬁgurations from the command line save Rename the image and changes ﬁle test A command line test runner update Load updates printVersion Print image version eval Directly evaluates passed in one line scripts Loading Metacello Conﬁguration. To get some explanation about the use of the conﬁg option, just request its associated help as follows: ./pharo Pharo.image conﬁg --help Note that this help is the one of the associated handler, not one of the command line generic system. Usage: conﬁg [ --help] <repository url> [<conﬁguration>] [ --install[=<version>]] [ -- group=<group>] [ --username=<username>] [ --password=<password>] --help show this help message <repository url> A Monticello repository name <conﬁguration> A valid Metacello Conﬁguration name <version> A valid version for the given conﬁguration <group> A valid Metacello group name <username> An optional username to access the conﬁguration's repository <password> An optional password to access the conﬁguration's repository 12 Zero Conﬁguration Scripts and Command-Line Handlers Examples: # display this help message pharo Pharo.image conﬁg # list all conﬁgurations of a repository pharo Pharo.image conﬁg $MC_REPOS_URL # list all the available versions of a confgurtation pharo Pharo.image conﬁg $MC_REPOS_URL ConﬁgurationOfFoo # install the stable version pharo Pharo.image conﬁg $MC_REPOS_URL ConﬁgurationOfFoo --install #install a speciﬁc version '1.5' pharo Pharo.image conﬁg $MC_REPOS_URL ConﬁgurationOfFoo --install=1.5 #install a speciﬁc version '1.5' and only a speciﬁc group 'Tests' pharo Pharo.image conﬁg $MC_REPOS_URL ConﬁgurationOfFoo --install=1.5 -- group=Tests 2.4 Anatomy of a handler As we mentioned, the command line mechanism is open and can be extended. We will look now how at the handler for the eval option is deﬁned. Evaluating Pharo Expressions. You can use the command line to evaluate expressions as follows: ./pharo Pharo.image eval '1+2' ./pharo Pharo.image eval --help Usage: eval [ --help] <smalltalk expression> --help list this help message <smallltalk expression> a valid Smalltalk expression which is evaluated and the result is printed on stdout Documentation: A CommandLineHandler that reads a string from the command line, outputs the evaluated result and quits the image. This handler either evaluates the arguments passed to the image: $PHARO_VM my.image eval 1 + 2 or it can read directly from stdin: echo "1+2" | $PHARO_VM my.image eval Using ZeroConf script with Jenkins 13 Now the handler is deﬁned as follows: First we deﬁne a subclass of CommandLineHandler. Here BasicCodeLoader is a subclass of CommandLineHandler and EvaluateCommandLineHandler is a subclass of BasicCodeLoader . BasicCodeLoader subclass: #EvaluateCommandLineHandler instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'System -CommandLine' We then deﬁne the commandName on the class side as well as the method isResponsibleFor: . EvaluateCommandLineHandler class>>commandName ^ 'eval' EvaluateCommandLineHandler class>>isResponsibleFor: commandLineArguments "directly handle top -level-e and --evaluate options" commandLineArguments withFirstArgument: [ :arg| (#('-e' '--evaluate') includes: arg) ifTrue: [ ^ true ]]. ^ commandLineArguments includesSubCommand: self commandName EvaluateCommandLineHandler class>>description ^ 'Directly evaluates passed in one line scripts' Then we deﬁne the method activate which will be executed when the option matches. EvaluateCommandLineHandler>>activate self activateHelp. self arguments ifEmpty: [ ^ self evaluateStdIn ]. self evaluateArguments. self quit. In particular we deﬁne a class comment since this is this class comment that will be printed when the help is requested. If you want your image saved at the end of an evaluation script, use the --save option just after eval. 2.5 Using ZeroConf script with Jenkins Now that we have such scripts and the possibility to specify option, we can write Jenkins scripts which rely on BASH as least as possible. 14 Zero Conﬁguration Scripts and Command-Line Handlers For example here is the command that we use in Jenkins for the project XMLWriter (which is hosted on PharoExtras). # Jenkins puts all the params after a / in the job name as well :( export JOB_NAME=`dirname $JOB_NAME` wget--quiet-O-get.pharo.org/$PHARO+$VM | bash ./pharo Pharo.image save $JOB_NAME --delete -old ./pharo $JOB_NAME.image --version > version.txt REPO=http://smalltalkhub.com/mc/PharoExtras/$JOB_NAME/main ./pharo $JOB_NAME.image conﬁg $REPO ConﬁgurationOf$JOB_NAME --install= $VERSION --group='Tests' ./pharo $JOB_NAME.image test --junit-xml-output "XML-Writer -.*" zip-r $JOB_NAME.zip $JOB_NAME.image $JOB_NAME.changes 2.6 Chapter summary You can now really easily access to the latest version of Pharo and build scripts. In addition, the command-line handler opens new horizons to be used in shell scripts. Chapter 3 Files with FileSystem with the participation of: Max Leske (maxleske@gmail.com) The library for dealing with ﬁles in Pharo is called FileSystem. It offers an expressive and elegant object-oriented design. This chapter presents the key aspects of the API to cover most of the needs one may have. FileSystem is the result of long and hard work from many people. FileSystem was originally developed by Colin Putney and the library is distributed under the MIT license, as for most components of Pharo. Camillo Bruni made some changes to the original design. Camillo Bruni integrated it into Pharo with the help of Esteban Lorenzano and Guillermo Polito. This chapter would not exist without the previous work of all the contributors of FileSystem. We are grateful to all of them. 3.1 Getting started The framework supports different “kinds” of ﬁlesystems that are interchangeable and may transparently work with each other. The probably most common usage of FileSystem is to directly work with ﬁles stored on your hard-drive. We are going to work with that one for now. The class FileSystem offers factory class-methods to offer access to different ﬁlesystems. Sending the message disktoFileSystem , returns a ﬁle system as on your physical hard-drive. Sending memory creates a new ﬁle system stored in memory image. | working | working := FileSystem disk workingDirectory. −→ /Users/ducasse/Workspace/FirstCircle/Pharo/20 16 Files with FileSystem working := FileSystem disk workingDirectory class −→ FileReference The message workingDirectory above returns a reference to the directory containing your Pharo image. A reference is an instance of the class FileReference . References are the central objects of the framework and provide the primary mechanisms for working with ﬁles and directories. FileSystem deﬁnes four classes that are important for the end-user: FileSystem ,FileReference ,FileLocator , and FileSystemDirectoryEntry .FileSystem offers factory methods to create a new ﬁle system. A FileReference is a reference to a folder or a ﬁle and offers methods to navigate and perform operations. AFileLocator is a late binding reference. When asked to perform concrete operation, a ﬁle locator looks up the current location of the origin, and resolve the path against it. A FileSystemDirectoryEntry allows one to get the additional information of a ﬁle or a directory. These classes belong to the ’FileSystemCore’ package, and are explained below in the chapter. You should not use platform speciﬁc classes such as UnixStore or WindowsStore , these are internal classes. All code snippets below work on FileReference instances. 3.2 Navigating a ﬁle system Now let’s play with FileSystem. Immediate children. To list the immediate children