How to Think Like a Computer Scientist Learning with Python ii How to Think Like a Computer Scientist Learning with Python Allen Downey Jeﬀrey Elkner Chris Meyers Green Tea Press Wellesley, Massachusetts Copyright c/circlecopyrt2002 Allen Downey, Jeﬀrey Elkner, and Chris Meyers. Edited by Shannon Turlington and Lisa Cutler. Cover design by Rebec ca Gimenez. Printing history: April 2002: First edition. August 2008: Second printing. Green Tea Press 1 Grove St. P.O. Box 812901 Wellesley, MA 02482 Permission is granted to copy, distribute, and/or modify this docum ent under the terms of the GNU Free Documentation License, Version 1.1 or any later version published by the Free Software Foundation; with the Invariant Sections being “Forew ord,” “Preface,” and “Contributor List,” with no Front-Cover Texts, and with no Back- Cover Texts. A copy of the license is included in the appendix entitled “GNU Fre e Documentation License.” The GNU Free Documentation License is available from www.gnu.org or by writing to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA. The original form of this book is LATEX source code. Compiling this LATEX source has the eﬀect of generating a device-independent representation of a t extbook, which can be converted to other formats and printed. The LATEX source for this book is available from http://www.thinkpython.com Publisher’s Cataloging-in-Publication (provided by Quality Books, Inc.) Downey, Allen How to think like a computer scientist : learning with Python / Allen Downey, Jeﬀrey Elkner, Chris Meyers. – 1st ed. p. cm. Includes index. ISBN 0-9716775-0-6 LCCN 2002100618 1. Python (Computer program language) I. Elkner, Jeﬀrey. II. Meyers, Chris. III. Title QA76.73.P98D69 2002 005.13’3 QBI02-200031 Foreword By David Beazley As an educator, researcher, and book author, I am delighted to see the completion of this book. Python is a fun and extremely easy-to-use programming language that has steadily gained in popularity over the last few years. Developed over ten years ago by Guido van Rossum, Python’s simple syntax and overall feel i s largely derived from ABC, a teaching language that was developed in the 1980’s . However, Python was also created to solve real problems and it borrows a wi de variety of features from programming languages such as C++, Java, Modula-3, and Scheme. Because of this, one of Python’s most remarkable features is its broad appeal to professional software developers, scientists, researchers, artists, and educators. Despite Python’s appeal to many diﬀerent communities, you may still wonder “why Python?” or “why teach programming with Python?” Answering these questions is no simple task—especially when popular opinion is on the side of more masochistic alternatives such as C++ and Java. However, I think the mo st direct answer is that programming in Python is simply a lot of fun and more productive. When I teach computer science courses, I want to cover important concepts in addition to making the material interesting and engaging to students. Unfortunately, there is a tendency for introductory programming courses to focus far too much attention on mathematical abstraction and for students to become frustrated with annoying problems related to low-level details of syntax, compila tion, and the enforcement of seemingly arcane rules. Although such abstraction and formalism is important to professional software engineers and students w ho plan to continue their study of computer science, taking such an approach in an introductory course mostly succeeds in making computer science boring. When I teach a course, I don’t want to have a room of uninspired students. I would much rather see them trying to solve interesting problems by exploring diﬀerent ideas, taking unconventional approaches, breaking the rules, and learning from their mistakes. vi Foreword In doing so, I don’t want to waste half of the semester trying to sort out obscur e syntax problems, unintelligible compiler error messages, or the several hundred ways that a program might generate a general protection fault. One of the reasons why I like Python is that it provides a really nice balance between the practical and the conceptual. Since Python is interpreted, beginners can pick up the language and start doing neat things almost immediately without getting lost in the problems of compilation and linking. Furthermore, Pytho n comes with a large library of modules that can be used to do all sorts of task s ranging from web-programming to graphics. Having such a practical focus is a great way to engage students and it allows them to complete signiﬁcant projects. However, Python can also serve as an excellent foundation for introducing importa nt computer science concepts. Since Python fully supports procedures and classes, students can be gradually introduced to topics such as procedural abstraction, data structures, and object-oriented programming—all of which are applicable to later courses on Java or C++. Python even borrows a number of features from functional programming languages and can be used to introduce concepts that would be covered in more detail in courses on Scheme and Lisp. In reading Jeﬀrey’s preface, I am struck by his comments that Python allowed him to see a “higher level of success and a lower level of frustration” and that he was able to “move faster with better results.” Although these comments refer to his introductory course, I sometimes use Python for these exact same reasons in advanced graduate level computer science courses at the University of Chicago. In these courses, I am constantly faced with the daunting task of covering a lot o f diﬃcult course material in a blistering nine week quarter. Although it is certainly possible for me to inﬂict a lot of pain and suﬀering by using a language like C++, I have often found this approach to be counterproductive—especially when the course is about a topic unrelated to just “programming.” I ﬁnd that using Python allows me to better focus on the actual topic at hand while allowing students to complete substantial class projects. Although Python is still a young and evolving language, I believe that it has a bright future in education. This book is an important step in that direction. David Beazley University of Chicago Author of the Python Essential Reference Preface By Jeﬀ Elkner This book owes its existence to the collaboration made possible by the Int ernet and the free software movement. Its three authors—a college professor, a high school teacher, and a professional programmer—have yet to meet face to face, but we have been able to work closely together and have been aided by many wonderful folks who have donated their time and energy to helping make this book better. We think this book is a testament to the beneﬁts and future possibilities of this kind of collaboration, the framework for which has been put in place by Richar d Stallman and the Free Software Foundation. How and why I came to use Python In 1999, the College Board’s Advanced Placement (AP) Computer Science exam was given in C++ for the ﬁrst time. As in many high schools throughout the country, the decision to change languages had a direct impact on the computer science curriculum at Yorktown High School in Arlington, Virginia, where I teac h. Up to this point, Pascal was the language of instruction in both our ﬁrst-y ear and AP courses. In keeping with past practice of giving students two years of exposure to the same language, we made the decision to switch to C++ in the ﬁrst-year course for the 1997-98 school year so that we would be in step with the Coll ege Board’s change for the AP course the following year. Two years later, I was convinced that C++ was a poor choice to use for introduci ng students to computer science. While it is certainly a very powerful programming language, it is also an extremely diﬃcult language to learn and teach. I found myself constantly ﬁghting with C++’s diﬃcult syntax and multiple ways of doi ng things, and I was losing many students unnecessarily as a result. Convinced there viii Preface had to be a better language choice for our ﬁrst-year class, I went looking for a n alternative to C++. I needed a language that would run on the machines in our Linux lab as well as on the Windows and Macintosh platforms most students have at home. I wanted it t o be free and available electronically, so that students could use it at home regar dless of their income. I wanted a language that was used by professional programmers, and one that had an active developer community around it. It had to support both procedural and object-oriented programming. And most importantly, it had to be easy to learn and teach. When I investigated the choices with these goals in mind, Python stood out as the best candidate for the job. I asked one of Yorktown’s talented students, Matt Ahrens, to give Python a t ry. In two months he not only learned the language but wrote an application called pyTicket that enabled our staﬀ to report technology problems via the Web. I knew that Matt could not have ﬁnished an application of that scale in so short a time in C++, and this accomplishment, combined with Matt’s positive assessment of Python, suggested that Python was the solution I was looking for. Finding a textbook Having decided to use Python in both of my introductory computer science classes the following year, the most pressing problem was the lack of an available t extbook. Free content came to the rescue. Earlier in the year, Richard Stallman had introduced me to Allen Downey. Both of us had written to Richard expressing an interest in developing free educational content. Allen had already written a ﬁrstyear computer science textbook, How to Think Like a Computer Scientist . When I read this book, I knew immediately that I wanted to use it in my class. It wa s the clearest and most helpful computer science text I had seen. It emphasized the processes of thought involved in programming rather than the features of a particular language. Reading it immediately made me a better teacher. How to Think Like a Computer Scientist was not just an excellent book, but it had been released under a GNU public license, which meant it could be used freely and modiﬁed to meet the needs of its user. Once I decided to use Python, it occurred to me that I could translate Allen’s original Java version of the book into the new language. While I would not have been able to write a textbook on my own, having Allen’s book to work from made it possible for me to do so, at the same time demonstrating that the cooperative development model used so well in software could also work for educational content. Working on this book for the last two years has been rewarding for both my students and me, and my students played a big part in the process. Since I could ix make instant changes whenever someone found a spelling error or diﬃcult passage, I encouraged them to look for mistakes in the book by giving them a bonus point each time they made a suggestion that resulted in a change in the text. This had the double beneﬁt of encouraging them to read the text more carefully and of getting the text thoroughly reviewed by its most important critics, students using it to learn computer science. For the second half of the book on object-oriented programming, I knew that someone with more real programming experience than I had would be needed to do it right. The book sat in an unﬁnished state for the better part of a year until the free software community once again provided the needed means for its completion. I received an email from Chris Meyers expressing interest in the book. Chris is a professional programmer who started teaching a programming course last yea r using Python at Lane Community College in Eugene, Oregon. The prospect of teaching the course had led Chris to the book, and he started helping out with it immediately. By the end of the school year he had created a companion project on our website at http://www.ibiblio.org/obp called Python for Fun and was working with some of my most advanced students as a master teacher, guiding them beyond where I could take them. Introducing programming with Python The process of translating and using How to Think Like a Computer Scientist for the past two years has conﬁrmed Python’s suitability for teaching beginning students. Python greatly simpliﬁes programming examples and makes importan t programming ideas easier to teach. The ﬁrst example from the text illustrates this point. It is the traditiona l “hello, world” program, which in the C++ version of the book looks like this: #include <iostream.h> void main() cout << "Hello, world." << endl; in the Python version it becomes: print "Hello, World!" Even though this is a trivial example, the advantages of Python stand out. Yo rktown’s Computer Science I course has no prerequisites, so many of the students x Preface seeing this example are looking at their ﬁrst program. Some of them are undoubtedly a little nervous, having heard that computer programming is diﬃcult to learn. The C++ version has always forced me to choose between two unsatisfying options: either to explain #include ,void main() ,{, and }, and risk confusing or intimidating some of the students right at the start, or to tell them, “Jus t don’t worry about all of that stuﬀ now; we will talk about it later,” and risk the same thing. The educational objectives at this point in the course are to introduce students to the idea of a programming language and to get them to write their ﬁrst program, thereby introducing them to the programming environment. The Python program has exactly what is needed to do these things, and nothing more. Comparing the explanatory text of the program in each version of the book fur - ther illustrates what this means to the beginning student. There are thirteen paragraphs of explanation of “Hello, world!” in the C++ version; in the Pytho n version, there are only two. More importantly, the missing eleven paragr aphs do not deal with the “big ideas” in computer programming but with the minutia of C++ syntax. I found this same thing happening throughout the book. Whole paragraphs simply disappear from the Python version of the text because Python’ s much clearer syntax renders them unnecessary. Using a very high-level language like Python allows a teacher to postpone tal king about low-level details of the machine until students have the background that they need to better make sense of the details. It thus creates the ability to put “ﬁrst things ﬁrst” pedagogically. One of the best examples of this is the way in which Python handles variables. In C++ a variable is a name for a place that holds a thing. Variables have to be declared with types at least in part because the size of the place to which they refer needs to be predetermined. Thus, the idea of a variable is bound up with the hardware of the machine. The powerful and fundamental concept of a variable is already diﬃcult enough for beginning students (in both computer science and algebra). Bytes and addresses do not help the matter. In Python a variable is a name that refers to a thing. This is a fa r more intuitive concept for beginning students and is much closer to the meaning of “variable” that they learned in their math courses. I had much less diﬃculty teaching variables this year than I did in the past, and I spent less time helping students with problems using them. Another example of how Python aids in the teaching and learning of programming is in its syntax for functions. My students have always had a great deal of diﬃ culty understanding functions. The main problem centers around the diﬀerence between a function deﬁnition and a function call, and the related distinction between a parameter and an argument. Python comes to the rescue with syntax that is nothing short of beautiful. Function deﬁnitions begin with the keyword def, so I simply tell my students, “When you deﬁne a function, begin with def, followed by the name of the function that you are deﬁning; when you call a function, simply xi call (type) out its name.” Parameters go with deﬁnitions; arguments go with ca lls. There are no return types, parameter types, or reference and value parameters to get in the way, so I am now able to teach functions in less than half the time that it previously took me, with better comprehension. Using Python has improved the eﬀectiveness of our computer science program for all students. I see a higher general level of success and a lower level of frustration than I experienced during the two years I taught C++. I move faster with better results. More students leave the course with the ability to create meaningful programs and with the positive attitude toward the experience of programm ing that this engenders. Building a community I have received email from all over the globe from people using this book to lea rn or to teach programming. A user community has begun to emerge, and many people have been contributing to the project by sending in materials for the companion website at http://www.thinkpython.com . With the publication of the book in print form, I expect the growth in the user community to continue and accelerate. The emergence of this user community and the possibility it suggests for similar collaboration among educators have been the most exciting parts of working on this project for me. By working together, we can increase the quality of materials available for our use and save valuabl e time. I invite you to join our community and look forward to hearing from you. P lease write to the authors at feedback@thinkpython.com . Jeﬀrey Elkner Yorktown High School Arlington, Virginia xii Preface Contributor List To paraphrase the philosophy of the Free Software Foundation, this book is free like free speech, but not necessarily free like free pizza. It came about because of a collaboration that would not have been possible without the GNU Free Documentation License. So we thank the Free Software Foundation for developing this license and, of course, making it available to us. We also thank the more than 100 sharp-eyed and thoughtful readers who have sent us suggestions and corrections over the past few years. In the spirit of free software, we decided to express our gratitude in the form of a contributor list. Unfortunately, this list is not complete, but we are doing our best to keep it up to date. If you have a chance to look through the list, you should realize that each pers on here has spared you and all subsequent readers from the confusion of a technical error or a less-than-transparent explanation, just by sending us a note. Impossible as it may seem after so many corrections, there may still be err ors in this book. If you should stumble across one, please check the online version of the book at http://thinkpython.com , which is the most up-to-date version. If the error has not been corrected, please take a minute to send us email at feedback@thinkpython.com . If we make a change due to your suggestion, you will appear in the next version of the contributor list (unless you ask to be omitt ed). Thank you! •Lloyd Hugh Allen sent in a correction to Section 8.4. •Yvon Boulianne sent in a correction of a semantic error in Chapter 5. •Fred Bremmer submitted a correction in Section 2.1. •Jonah Cohen wrote the Perl scripts to convert the LaTeX source for this book into beautiful HTML. xiv Contributor List •Michael Conlon sent in a grammar correction in Chapter 2 and an improvement in style in Chapter 1, and he initiated discussion on the technical aspects of interpreters. •Benoit Girard sent in a correction to a humorous mistake in Section 5.6. •Courtney Gleason and Katherine Smith wrote horsebet.py , which was used as a case study in an earlier version of the book. Their program can now be found on the website. •Lee Harr submitted more corrections than we have room to list here, and indeed he should be listed as one of the principal editors of the text. •James Kaylin is a student using the text. He has submitted numerous corrections. •David Kershaw ﬁxed the broken catTwice function in Section 3.10. •Eddie Lam has sent in numerous corrections to Chapters 1, 2, and 3. He also ﬁxed the Makeﬁle so that it creates an index the ﬁrst time it is run and helped us set up a versioning scheme. •Man-Yong Lee sent in a correction to the example code in Section 2.4. •David Mayo pointed out that the word “unconsciously” in Chapter 1 needed to be changed to “subconsciously”. •Chris McAloon sent in several corrections to Sections 3.9 and 3.10. •Matthew J. Moelter has been a long-time contributor who sent in numerous corrections and suggestions to the book. •Simon Dicon Montford reported a missing function deﬁnition and several typos in Chapter 3. He also found errors in the increment function in Chapter 13. •John Ouzts corrected the deﬁnition of “return value” in Chapter 3. •Kevin Parks sent in valuable comments and suggestions as to how to improve the distribution of the book. •David Pool sent in a typo in the glossary of Chapter 1, as well as kind wo rds of encouragement. •Michael Schmitt sent in a correction to the chapter on ﬁles and exceptions. •Robin Shaw pointed out an error in Section 13.1, where the printTime function was used in an example without being deﬁned. xv •Paul Sleigh found an error in Chapter 7 and a bug in Jonah Cohen’s Perl script that generates HTML from LaTeX. •Craig T. Snydal is testing the text in a course at Drew University. He has contributed several valuable suggestions and corrections. •Ian Thomas and his students are using the text in a programming course. They are the ﬁrst ones to test the chapters in the latter half of the book, and they have made numerous corrections and suggestions. •Keith Verheyden sent in a correction in Chapter 3. •Peter Winstanley let us know about a longstanding error in our Latin in Chapter 3. •Chris Wrobel made corrections to the code in the chapter on ﬁle I/O and exceptions. •Moshe Zadka has made invaluable contributions to this project. In addition to writing the ﬁrst draft of the chapter on Dictionaries, he provided continual guidance in the early stages of the book. •Christoph Zwerschke sent several corrections and pedagogic suggestions, and explained the diﬀerence between gleich andselbe. •James Mayer sent us a whole slew of spelling and typographical errors, including two in the contributor list. •Hayden McAfee caught a potentially confusing inconsistency between two examples. •Angel Arnal is part of an international team of translators working on the Spanish version of the text. He has also found several errors in the English version. •Tauhidul Hoque and Lex Berezhny created the illustrations in Chapter 1 and improved many of the other illustrations. •Dr. Michele Alzetta caught an error in Chapter 8 and sent some interesting pedagogic comments and suggestions about Fibonacci and Old Maid. •Andy Mitchell caught a typo in Chapter 1 and a broken example in Chapter •Kalin Harvey suggested a clariﬁcation in Chapter 7 and caught some typos. •Christopher P. Smith caught several typos and is helping us prepare to update the book for Python 2.2. xvi Contributor List •David Hutchins caught a typo in the Foreword. •Gregor Lingl is teaching Python at a high school in Vienna, Austria. He is working on a German translation of the book, and he caught a couple of bad errors in Chapter 5. •Julie Peters caught a typo in the Preface. •Florin Oprina sent in an improvement in makeTime , a correction in printTime , and a nice typo. •D. J. Webre suggested a clariﬁcation in Chapter 3. •Ken found a ﬁstful of errors in Chapters 8, 9 and 11. •Ivo Wever caught a typo in Chapter 5 and suggested a clariﬁcation in Chapter 3. •Curtis Yanko suggested a clariﬁcation in Chapter 2. •Ben Logan sent in a number of typos and problems with translating the book into HTML. •Jason Armstrong saw the missing word in Chapter 2. •Louis Cordier noticed a spot in Chapter 16 where the code didn’t match the text. •Brian Cain suggested several clariﬁcations in Chapters 2 and 3. •Rob Black sent in a passel of corrections, including some changes for Python 2.2. •Jean-Philippe Rey at Ecole Centrale Paris sent a number of patches, including some updates for Python 2.2 and other thoughtful improvements. •Jason Mader at George Washington University made a number of useful suggestions and corrections. •Jan Gundtofte-Bruun reminded us that “a error” is an error. •Abel David and Alexis Dinno reminded us that the plural of “matrix” is “matrices”, not “matrixes”. This error was in the book for years, but two readers with the same initials reported it on the same day. Weird. •Charles Thayer encouraged us to get rid of the semi-colons we had put at the ends of some statements and to clean up our use of “argument” and “parameter”. xvii •Roger Sperberg pointed out a twisted piece of logic in Chapter 3. •Sam Bull pointed out a confusing paragraph in Chapter 2. •Andrew Cheung pointed out two instances of “use before def.” •Hans Batra found an error in Chapter 16. •Chris Seberino suggested some improvements in the Preface. •Yuri Takhteyev pointed out a problem with single and double quotes. xviii Contributor List Contents Foreword v Preface vii Contributor List xiii 1 The way of the program 1 1.1 The Python programming language . . . . . . . . . . . . . . . . . 1 1.2 What is a program? . . . . . . . . . . . . . . . . . . . . . . . . . 3 1.3 What is debugging? . . . . . . . . . . . . . . . . . . . . . . . . . 4 1.4 Formal and natural languages . . . . . . . . . . . . . . . . . . . . 6 1.5 The ﬁrst program . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 1.6 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 2 Variables, expressions and statements 11 2.1 Values and types . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 2.2 Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 2.3 Variable names and keywords . . . . . . . . . . . . . . . . . . . . 13 2.4 Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 2.5 Evaluating expressions . . . . . . . . . . . . . . . . . . . . . . . . 16 2.6 Operators and operands . . . . . . . . . . . . . . . . . . . . . . . 17 xx Contents 2.7 Order of operations . . . . . . . . . . . . . . . . . . . . . . . . . . 17 2.8 Operations on strings . . . . . . . . . . . . . . . . . . . . . . . . . 18 2.9 Composition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 2.10 Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 2.11 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 3 Functions 23 3.1 Function calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 3.2 Type conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 3.3 Type coercion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 3.4 Math functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 3.5 Composition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 3.6 Adding new functions . . . . . . . . . . . . . . . . . . . . . . . . 26 3.7 Deﬁnitions and use . . . . . . . . . . . . . . . . . . . . . . . . . . 29 3.8 Flow of execution . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 3.9 Parameters and arguments . . . . . . . . . . . . . . . . . . . . . . 30 3.10 Variables and parameters are local . . . . . . . . . . . . . . . . . 31 3.11 Stack diagrams . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 3.12 Functions with results . . . . . . . . . . . . . . . . . . . . . . . . 33 3.13 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 4 Conditionals and recursion 37 4.1 The modulus operator . . . . . . . . . . . . . . . . . . . . . . . . 37 4.2 Boolean expressions . . . . . . . . . . . . . . . . . . . . . . . . . 37 4.3 Logical operators . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 4.4 Conditional execution . . . . . . . . . . . . . . . . . . . . . . . . 39 4.5 Alternative execution . . . . . . . . . . . . . . . . . . . . . . . . . 39 4.6 Chained conditionals . . . . . . . . . . . . . . . . . . . . . . . . . 40 Contents xxi 4.7 Nested conditionals . . . . . . . . . . . . . . . . . . . . . . . . . . 41 4.8 The return statement . . . . . . . . . . . . . . . . . . . . . . . . 42 4.9 Recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 4.10 Stack diagrams for recursive functions . . . . . . . . . . . . . . . 44 4.11 Inﬁnite recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 4.12 Keyboard input . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 4.13 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 5 Fruitful functions 49 5.1 Return values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 5.2 Program development . . . . . . . . . . . . . . . . . . . . . . . . 50 5.3 Composition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 5.4 Boolean functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 5.5 More recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55 5.6 Leap of faith . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 5.7 One more example . . . . . . . . . . . . . . . . . . . . . . . . . . 58 5.8 Checking types . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58 5.9 Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 6 Iteration 61 6.1 Multiple assignment . . . . . . . . . . . . . . . . . . . . . . . . . 61 6.2 The while statement . . . . . . . . . . . . . . . . . . . . . . . . . 62 6.3 Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64 6.4 Two-dimensional tables . . . . . . . . . . . . . . . . . . . . . . . 66 6.5 Encapsulation