Open T extbooks Gettysbur g College Open E ducational Resour ces Introduction T o MIPS Assembly Language Pr ogramming Introduction T o MIPS Assembly Language Pr ogramming Charles W . Kann Gettysbur g College Follow this and additional works at: https:/ /cupola.gettysbur g.edu/oer Part of the Computer and Systems Ar chitectur e Commons , and the Systems Ar chitectur e Commons Shar e feedback Shar e feedback about the accessibility of this item. about the accessibility of this item. Recommended Citation Recommended Citation Kann, Charles W ., "Intr oduction T o MIPS Assembly Language Pr ogramming" (2015). Open T extbooks . 2. https:/ /cupola.gettysbur g.edu/oer/2 This open access book is br ought t o you b y The Cupola: Scholarship at Gettysbur g College. It has been accepted for inclusion b y an authoriz ed administr ator of The Cupola. F or mor e information, please contact cupola@gettysbur g.edu . Introduction T o MIPS Assembly Language Pr ogramming Introduction T o MIPS Assembly Language Pr ogramming Description Description This book was written t o intr oduce students t o assembly language pr ogramming in MIPS. As with all assembly language pr ogramming texts, it co vers basic oper ators and instructions, subpr ogram calling, loading and st oring memor y, program contr ol, and the conv ersion of the assembly language pr ogram int o machine code. Howe ver this book was not written simply as a book on assembly language pr ogramming. The lar ger purpose of this text is t o show how concepts in Higher Le vel Languages (HLL), such as Ja va or C/C++, are represented in assembly . By showing how pr ogram constructs fr om these HLL map int o assembly , the concepts will be easier t o understand and use when the pr ogrammer implements pr ograms in languages like Ja va or C/C++. Concepts such as r eferences and v ariables, r egisters, binar y and Boolean oper ations, subpr ogram ex ecution, memor y types (heap, stack, and static), and arr ay processing ar e co vered to clarify the decisions made when implementing HLL. Pr ogram contr ol is pr esented using a mapping fr om structur ed pr ograms in pseudo code t o help students understand structur ed pr ogramming, and why it exists. Memor y access in assembly is pr esented t o high light the diff erence between r eferences (pointers) and v alues, and how these impact HLL. This book has numer ous code examples, and many pr oblems at the end of each chapter , and it is appr opriate for a class in Assembly Language, or as a extr a resour ce for a class in Computer Organization. This book is, and will alwa ys be, a fr ee download. Howe ver if y ou would lik e to suppor t me t o create new content, or simply sa y “thank y ou”’ for pr oviding this content for fr ee, y ou can use the site https:/ /www .buymeacoff ee.com/CharlesKann and buy me a coff e. Keywor ds Keywor ds MIPS, Assembly , Procedur al Pr ogramming, Binar y Arithmetic, Computer Or ganization, Computer Architectur e Disciplines Disciplines Computer and Systems Ar chitectur e | Computer Engineering | Computer Sciences | Systems Ar chitectur e Publisher Publisher Charles W . Kann III Comments Comments Additional r esour ces for this book at a vailable at accessible at http:/ /chuckkann.com Please contact the author at ckann@gettysbur g.edu if you wish t o adopt this book for a course - thanks! Creativ e Commons License Creativ e Commons License This work is licensed under a Creativ e Commons A ttribution 4.0 License . This book is a vailable at The Cupola: Scholarship at Gettysbur g College: https:/ /cupola.gettysbur g.edu/oer/2 Charles W. Kann Introduction to MIPS Assembly Language Programming This book is, and will always be, a free download. However if you would like to support me to create new content, or simply say “thank you”’ for providing this content for free, you can use the site https://www.buymeacoffee.com/CharlesKann and buy me a coffe. INTRODUCTION TO MIPS ASSEMBLY LANGUAGE P ROGRAMMING 2 © Charle s W. Kann III 277 E. Lincoln Ave. Gettysburg, Pa All rights reserved. This book is licensed under the Creative Commons Attribution 4.0 License Last Update: Sunday, November 06, 2016 An answer key is currently being written, and is available for the problems in this text. To request a copy of the answer key, write to ckann(at)gettysburg.edu. All requests must come from an account of a recognized educational institution, and the person requesting this material must be listed as an instructor at the institution. This book is available for free download from: http://chuckkann.com/books/ IntroductionT oMIPSAssembly. 3 INTRODUCTION TO MIPS ASSEMBLY LANGUAGE P ROGRAMMING Other books by Charles Kann Kann, Charles W., "Digital Circuit Projects: An Overview of Digital Circuits Through Implementing Integrated Circuits - Second Edition" (2014). Gettysburg College Open Educational Resources. Book 1. http://cupola.gettysburg.edu/oer/1 Kann, Charles W., "Introduction to MIPS Assembly Language Programming" (2015). Gettysburg College Open Educational Resources. Book 2. http://cupola.gettysburg.edu/oer/2 Kann, Charles W., "Implementing a One Address CPU in Logisim" (2016). Gettysburg College Open Educational Resources . 3. http://cupola.gettysburg.edu/oer/3 INTRODUCTION TO MIPS ASSEMBLY LANGUAGE P ROGRAMMING 4 Forward Given the effort of writing a book, the first question an author has to answer is “why bother?” The answer to that question is what frames the book, and what I will describe here. Why was this book written? First because I do not believe that there is any book currently available which meets the needs I had for a text book. The first is that the can be obtained for a minimal price, or can even be downloaded for free at a number of sites on the web . I am very tired of asking students to pay ov er $100 per book for classes. I personally have been blessed in so many ways in this world, and I have reached a point in my career where I can take the time to produce this text as a small pay back for all I have been given. I hope that this example wil l help students who use the book to order their priorities as they go through life, to seek a good outside of personal monetary gain . I realize that this text could very much use a good editing, unless I can find someone willing to donate the time to do so , I think the basic information in the book is well enough organized to make it useful, and well worth the cost of a free download. The second reason I wrote this book is that I could not find an assembly programming book that met the need I had in teachin g assembly programming. I believe that learning assembly programming is important to every Computer Science student because the principals in assembly affect how high level languages and programs in those languages are implemented. I have purposefully st ructured the topics in this text to illustrate how concepts such as memory organization (static, heap, and stack) affect variable allocation in high level languages. The chapter on program control is intended to make the student aware of structured progra mming, which is the basis for control structures in all modern high level languages. Even arrays make more sense in a high level language once one understands how they are implemented, and why. This text is intended to be more than a book about assembly language programming, but to extend assembly language into the principals on which the higher level languages are built. Finally writing a book is the best way to organize my own thoughts. Much of the material in this text existed for years as a jumble in my own mind. Producing slides and programs for class helped clarify the concepts , but it was when I had to provide a larger organization of the ideas that many of them finally gelled for me. Forcing yourself to explain a concept, particularly in the bru tal detail of writing it out, is the best way to organize and learn things. There are other details about this book that need to be mentioned. Because this book is electronic, it can be released in phases. This text should be looked at in the same way as a beta software release. I know there are mistakes, but I have the ability to correct them and rerelease the text. So comments are welcome. There is a separate set of appendices which should be available by mid -summer, 2015. I will update this forward with the URL address of those appendices once they are posted. If anyone is in real need of those appendices, I will send them in their current, incomplete, format. I can be contacted at ckann(at)gettysburg.edu. I will also release an answer guide when i t is completed, hopefully in the same mid-summer 2015 time frame. To request an answer guide will require a request from a professor or lecturer 5 INTRODUCTION TO MIPS ASSEMBLY LANGUAGE P ROGRAMMING at a school, and that the requestor be listed on the department web site for that school. Requests for this d ocument can be made to me at the same address as for the appendices. I hope the readers find this text useful. I hope it is at least worth the price... INTRODUCTION TO MIPS ASSEMBLY LANGUAGE P ROGRAMMING 6 Contents Chapter 1 Introduction ................................ ................................ ................................ ............. 14 Chapter 1. 1 Binary Numbers ................................ ................................ ............................... 14 Chapter 1.1. 1 Values for Binary Numbers ................................ ................................ ........ 14 Chapter 1.1. 2 Binary Whole Numbers ................................ ................................ .............. 15 Chapter 1. 2 Converting Binary, Decimal, and Hex Numbers ................................ ............. 17 Chapter 1.2. 1 Converting Binary to Decimal ................................ ................................ .... 17 Chapter 1.2. 2 Converting Decimal to Binary using Binary Powers ................................ . 17 Chapter 1.2. 3 Converting Decimal to Binary using Division ................................ ........... 18 Chapter 1.2. 4 Converting betwee n binary and hexadecimal ................................ ............. 19 Chapter 1. 3 Character Representation ................................ ................................ ................. 20 Chapter 1. 4 Adding Binary Whole Numbers ................................ ................................ ...... 22 Chapter 1. 5 Integer Numbers (2's Complement) ................................ ................................ . 22 Chapter 1.5. 1 What is an Integer ................................ ................................ ....................... 22 Chapter 1.5. 2 2's complement operation and 2's complement format ............................... 23 Chapter 1.5. 3 The 2's Complement Operation ................................ ................................ .. 23 Chapter 1.5. 4 The 2's Complement (or Integer) Type ................................ ...................... 24 Chapter 1. 6 Integer Arithmetic ................................ ................................ ............................ 25 Chapter 1.6. 1 Integer Addition ................................ ................................ .......................... 25 Chapter 1.6. 2 Overflow of Integer Addition ................................ ................................ ..... 26 Chapter 1.6. 3 Integer multiplication using bit shift operations ................................ ......... 27 Chapter 1.6. 4 Integer division using bit shif t operations ................................ .................. 29 Chapter 1. 7 Boolean Logical and Bitwise Operators ................................ .......................... 29 Chapter 1.7. 1 Boolean Operators ................................ ................................ ...................... 29 Chapter 1.7. 2 Logical and Bitwise Boolean Operators ................................ ..................... 31 Chapter 1. 8 Context ................................ ................................ ................................ ............. 32 Chapter 1. 9 Summary ................................ ................................ ................................ .......... 32 Chapter 1. 10 Exercises ................................ ................................ ................................ .......... 32 Chap ter 2 First Programs in MIPS assembly ................................ ................................ ........... 36 Chapter 2. 1 The MARS IDE ................................ ................................ ............................... 36 Chapter 2. 2 MIPS and memory ................................ ................................ ........................... 37 Chapter 2.2. 1 Types of memory ................................ ................................ ........................ 38 Chapter 2.2. 2 Overview of a MIPS CPU ................................ ................................ .......... 38 Chapter 2.2. 3 Registers ................................ ................................ ................................ ..... 40 7 INTRODUCTION TO MIPS ASSEMBLY LANGUAGE P ROGRAMMING Chapter 2.2. 4 Types of memory ................................ ................................ ........................ 42 Chapter 2. 3 First program in MIPS assembly ................................ ................................ ..... 43 Chapter 2.3. 1 Program 2 -1 Commentary ................................ ................................ .......... 45 Chapter 2. 4 Program to prompt and read an integer from a user ................................ ........ 47 Chapter 2.4. 1 Program 2 -2 Commentary ................................ ................................ .......... 48 Chapter 2. 5 Program to prompt and read a string from a user ................................ ........... 48 Chapter 2.5. 1 Program 2 -3 Commentary ................................ ................................ .......... 49 Chapter 2. 6 Summary ................................ ................................ ................................ .......... 53 Chapter 2. 7 Java program for call by value and reference ................................ .................. 53 Chapter 2. 8 Exercises ................................ ................................ ................................ .......... 54 Chapter 3 MIPS arithmetic and Logical Operators ................................ ................................ . 55 Chapter 3. 1 3-Address machines ................................ ................................ ......................... 55 Chapter 3. 2 Addition in MIPS assembly ................................ ................................ ............. 57 Chapter 3.2. 1 Addition operators ................................ ................................ ...................... 57 Chapter 3.2. 2 Addition Examples ................................ ................................ ..................... 58 Chapter 3.2. 3 Introduction to pseudo code ................................ ................................ ....... 60 Chapter 3.2. 4 Assembly language addition program ................................ ........................ 61 Chapter 3.2. 5 Assembly language addition program commentary ................................ ... 62 Chapter 3. 3 Subtraction in MIPS assembly ................................ ................................ ........ 63 Chapter 3. 4 Multiplication in MIPS assembly ................................ ................................ .... 64 Chapter 3. 5 Division in MIPS Assembly ................................ ................................ ............ 66 Chapter 3.5. 1 Remainder operator, even/odd number checker ................................ ......... 68 Chapter 3.5. 2 Remainder operator, even/odd number checker ................................ ......... 68 Chapter 3. 6 Solving arithmetic expressions in MIPS assembly ................................ .......... 69 Chapter 3. 7 Division and accuracy of an equation ................................ .............................. 70 Chapter 3. 8 Logical operators ................................ ................................ ............................. 71 Chapter 3. 9 Using logical operators ................................ ................................ .................... 74 Chapter 3.9. 1 Storing immediate values in registers ................................ ......................... 74 Chapter 3.9. 2 Converting a character from upper case to lower case ............................... 74 Chapter 3.9. 3 Reversible operatio ns with XOR ................................ ................................ 75 Chapter 3. 10 Shift Operations ................................ ................................ ............................... 76 Chapter 3.10. 1 Program illustrating shift operations ................................ ........................ 79 Chapter 3. 11 Summary ................................ ................................ ................................ .......... 80 Chapter 3. 12 Exercises ................................ ................................ ................................ .......... 80 INTRODUCTION TO MIPS ASSEMBLY LANGUAGE P ROGRAMMING 8 Chapter 4 Translating Assembly Language into Machine Code ................................ ............. 84 Chapter 4. 1 Instruction formats ................................ ................................ ........................... 84 Chapter 4. 2 Machine code for the add instruction ................................ .............................. 86 Chapter 4. 3 Machine code for the sub instruction ................................ .............................. 87 Chapter 4. 4 Machine code for the addi instruction ................................ ............................. 87 Chapter 4. 5 Machine code for the sll instruction ................................ ................................ 88 Chapter 4. 6 Exercises ................................ ................................ ................................ .......... 88 Chapter 5 Simple MIPS subprograms ................................ ................................ ..................... 91 Chapter 5. 1 Exit Subprogram ................................ ................................ .............................. 91 Chapter 5.1. 1 Commentary on Exit subprogram ................................ ............................... 92 Chapter 5. 2 PrintNewLine subprogram ................................ ................................ .............. 93 Chapter 5.2. 1 Commentary on Exit subprogram ................................ ............................... 94 Chapter 5. 3 The Program Counter ( $pc) register and calling a subprogram .................... 95 Chapter 5. 4 Returning from a subprogram and the $ra register ................................ ........ 98 Chapter 5. 5 Input parameter with PrintString subprogram ................................ ................. 99 Chapter 5. 6 Multiple input paramete rs with PrintInt subprogram ................................ .... 101 Chapter 5. 7 Return values with PromptInt subprogram ................................ .................... 103 Chapter 5. 8 Create a utils.asm file ................................ ................................ .................... 105 Chapter 5. 9 Final program to prompt, read, and print an integer ................................ ...... 107 Chapter 5. 10 Summary ................................ ................................ ................................ ........ 108 Chapter 5. 11 Exercises ................................ ................................ ................................ ........ 108 Chapter 6 MIPS memory - the data segment ................................ ................................ ......... 111 Chapter 6. 1 Flat memory model ................................ ................................ ........................ 111 Chapter 6. 2 Static data ................................ ................................ ................................ ...... 113 Chapter 6. 3 Accessing memory ................................ ................................ ........................ 116 Chapter 6. 4 Methods of accessing memory ................................ ................................ ...... 117 Chapter 6.4. 1 Addressing by label ................................ ................................ .................. 117 Chapter 6.4. 2 Register direct access ................................ ................................ ................ 118 Chapter 6.4. 3 Register indirect access ................................ ................................ ............ 119 Chapter 6.4. 4 Register offset access ................................ ................................ ................ 120 Chapter 6. 5 Exercises ................................ ................................ ................................ ........ 123 Chapter 7 Assembly language program control structures ................................ .................... 124 Chapter 7. 1 Use of goto statements ................................ ................................ ................... 125 Chapter 7. 2 Simple if statements ................................ ................................ ....................... 126 9 INTRODUCTION TO MIPS ASSEMBLY LANGUAGE P ROGRAMMING Chapter 7.2. 1 Simple if statements in pseudo code ................................ ......................... 126 Chapter 7.2. 2 Simple if statement translated to assembly ................................ ............... 126 Chapter 7.2. 3 Simple if statement with complex logical conditions ............................... 127 Chapter 7. 3 if-else statem ents ................................ ................................ .......................... 128 Chapter 7. 4 if-elseif -else statements ................................ ................................ ................. 130 Chapter 7. 5 Loops ................................ ................................ ................................ ............. 132 Chapter 7.5. 1 Sentinel control loop ................................ ................................ ................. 133 Chapter 7.5. 2 Counter control loop ................................ ................................ ................. 134 Chapter 7. 6 Nested code blocks ................................ ................................ ........................ 136 Chapter 7. 7 A full assembly language program ................................ ................................ 138 Chapter 7. 8 How to calculate branch amounts in machine code ................................ ...... 142 Chapter 7.8. 1 Instruction Addresses ................................ ................................ ............... 142 Chapter 7.8. 2 Value in the $pc register ................................ ................................ ........... 143 Chapter 7.8. 3 How the word boundary effects branching ................................ ............... 144 Chapter 7.8. 4 Translating branch instructions to machine code ................................ ..... 145 Chapter 7.8. 5 PC relative addressing ................................ ................................ .............. 147 Chapter 7. 9 Exercises ................................ ................................ ................................ ........ 148 Chapter 8 Reentrant Subprograms ................................ ................................ ......................... 151 Chapter 8. 1 Stacks ................................ ................................ ................................ ............. 151 Chapter 8.1. 1 Stack data structure: definition ................................ ................................ . 151 Chapter 8.1. 2 Another stack implementation ................................ ................................ .. 153 Chapter 8. 2 The program stack ................................ ................................ ......................... 154 Chapter 8.2. 1 The non -reentrant subprogram problem ................................ ................... 154 Chapter 8.2. 2 Making subprograms re -entrant ................................ ................................ 157 Chapter 8. 3 Recursion ................................ ................................ ................................ ....... 159 Chapter 8.3. 1 Recursive multiply in a HLL ................................ ................................ .... 160 Chapter 8. 4 Exercises ................................ ................................ ................................ ........ 162 Chapter 9 Arrays ................................ ................................ ................................ .................... 164 Chapter 9. 1 Heap dynamic memory ................................ ................................ .................. 164 Chapter 9.1. 1 What is heap memory ................................ ................................ ............... 164 Chapter 9.1. 2 Allocating heap memory example – PromptString subprogram .............. 165 Chapter 9.1. 3 Commentary on PromptString Subprogram ................................ ............. 166 Chapter 9. 2 Array Definition and creation in Assembly ................................ ................... 167 Chapter 9.2. 1 Allocating arrays in memory ................................ ................................ .... 169 INTRODUCTION TO MIPS ASSEMBLY LANGUAGE P ROGRAMMING 10 Chapter 9. 3 Printing an Array ................................ ................................ ........................... 170 Chapter 9. 4 Bubble Sort ................................ ................................ ................................ .... 172 Chapter 9.3. 1 Bubble Sort in MIPS assembly ................................ ................................ . 173 Chapter 9. 5 Summary ................................ ................................ ................................ ........ 176 Chapte r 9. 6 Exercises ................................ ................................ ................................ ........ 177 11 INTRODUCTION TO MIPS ASSEMBLY LANGUAGE P ROGRAMMING Table of Figures Figure 1 -1: Binary whole number addition ................................ ................................ ................... 22 Figure 1 -2: Addition of two positive integers ................................ ................................ ............... 25 Figure 1 -3: Addition of positive and negative integers ................................ ................................ 26 Figure 1 -4: Addition of two negative integers ................................ ................................ .............. 26 Figure 1 -5: Addition with overflow ................................ ................................ .............................. 27 Figure 1 -6: Subtraction with overflow ................................ ................................ .......................... 27 Figure 2 -1: Initial Screen of the MARS IDE ................................ ................................ ................ 37 Figure 2 -2: 3-address store/load computer architecture ................................ ................................ 39 Figure 2 -3: MIPS memory configuration ................................ ................................ ..................... 43 Figure 2 -4: Assembling a program ................................ ................................ ............................... 44 Figure 2 -5: Running a program ................................ ................................ ................................ ..... 45 Figure 2 -6: Memory before entering a string ................................ ................................ ................ 51 Figure 3-1: MIPS computer architecture ................................ ................................ ...................... 56 Figure 3 -2: Assembled addition example ................................ ................................ ..................... 59 Figure 3 -3: Addition Example after running 1 step. ................................ ................................ ..... 60 Figure 4 -1: R format instruction ................................ ................................ ................................ ... 84 Figure 4 -2: I format instruction ................................ ................................ ................................ ..... 84 Figure 4 -3: Machine Code example ................................ ................................ .............................. 85 Figure 4 -4: Machine code for add $t0, $t1, $t2 ................................ ................................ ............ 86 Figure 4 -5: Machine code for sub $s0, $s1, $s2 ................................ ................................ ........... 87 Figure 4 -6: Machine code for addi $s2, $t8, 37 ................................ ................................ ............ 87 Figure 4 -7: Machine code for sll $t0, $t1, 10 .........................