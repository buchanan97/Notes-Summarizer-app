function to apply, and providing its argument. Using these de nitions, it s instructive to write out the representations of the examples we de ned above: (fd C double x (plus C (id C x) (id C x))) (fd C quadruple x (app C double (app C double (id C x)))) (fd C const5 (num C )) We also need to choose a representation for a set of function de nitions. It s convenient to represent these by a list. Look out! Did you notice that we spoke of a setof function de nitions, but chose a list representation? That means we re using an ordered collection of data to represent an unordered entity. At the very least, then, when testing, we should use any and all permutations of de nitions to ensure we haven t subtly built in a dependence on the order. Growing the Interpreter Now we re ready to tackle the interpreter proper. First, let s remind ourselves of what it needs to consume. Previously, it consumed only an expression to evaluate. Now it also needs to take a list of function de nitions: interp :: (define (interp e : Expr C fds : (listof Fun Def C) ) : number interp-body ) Let s revisit our old interpreter (section ). In the case of numbers, clearly we still return the number as the answer. In the addition and multiplication case, we still need to recur (because the sub-expressions might be complex), but which set of function de nitions do we use? Because the act of evaluating an expression neither adds nor removes function de nitions , the set of de nitions remains the same, and should