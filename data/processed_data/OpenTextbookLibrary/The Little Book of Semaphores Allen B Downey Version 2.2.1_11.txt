of the things that makes concurrent p rograms hard to debug. A program might work correctly 1000 times in a row, a nd then crash on the 1001st run, depending on the particular decisions of t he scheduler. These kinds of bugs are almost impossible to nd by testing; t hey can only be avoided by careful programming. Shared variables Most of the time, most variables in most threads are local, meaning that they belong to a single thread and no other threads can access them . As long as that s true, there tend to be few synchronization problems, because threads just don t interact. But usually some variables are sharedamong two or more threads; this is one of the ways threads interact with each other. For examp le, one way to communicate information between threads is for one threa d to read a value written by another thread. If the threads are unsynchronized, then we cannot tell by loo king at the program whether the reader will see the value the writer writ es or an old value that was already there. Thus many applications enforce the c onstraint that the reader should not read until after the writer writes. Thi s is exactly the serialization problem in Section . Other ways that threads interact are concurrent writes (two or more writers) and concurrent updates (two or more threads performing a read followed by a write). The next two sections deal with these interactio ns. The other possible use of a shared variable, concurrent reads, does no t generally create a synchronization problem. Concurrent writes In the following example, xis a shared variable accessed by two writers. Shared