will quietly convert that value to the type it needs, using a set of rules that often aren t what you want or expect. This is called type coercion . The nullin the firstexpressionbecomes 0andthe " "inthesecondexpressionbecomes (from string to number). Yet in the third expression, tries string concatenation before numeric addition, so the 1is converted to " "(from number to string). When something that doesn t map to a number in an obvious way (such as "five"orundefined ) is converted to a number, you get the value Na N. Further arithmetic operations on Na Nkeep producing Na N, so if you find yourself getting one of those in an unexpected place, look for accidental type conversions. When comparing values of the same type using the operator, the outcome is easy to predict: you should get true when both values are the same, except in the case of Na N. But when the types differ, Java Script uses a complicated and confusing set of rules to determine what to do. In most cases, it just tries to convert one of the values to the other value s type. However, when nullor undefined occurs on either side of the operator, it produces true only if both sides are one of nullorundefined . console.log(null undefined); true console.log(null ); false That behavior is often useful. When you want to test whether a value has a real value instead of nullorundefined , you can compare it to nullwith the or! operator. Whatifyouwanttotestwhethersomethingreferstotheprecisevalue false? Expressionslike false and "" false arealsotruebecauseofautomatic type conversion. When you do notwant any type conversions to happen, there are two additional operators: and ! . The first tests whether a value