To implement the add(i;x) operation, we rst check if ais already full. If so, we call the method resize () to increase the size of a. How resize () is implemented will be discussed later. For now, it is su cient to know that, after a call to resize (), we can be sure that a:length n. With this out of the way, we now shift the elements a i ;:::;a n right by one position to make room for x, seta i equal to x, and increment n. Array Stack void add(int i, T x) if (n a.length) resize(); for (int j n; j i; j--) a j a j- ; a i x; n ; If we ignore the cost of the potential call to resize (), then the cost of theadd(i;x) operation is proportional to the number of elements we have to shift to make room for x. Therefore the cost of this operation (ignoring the cost of resizing a) is O(n i ). Implementing the remove (i) operation is similar. We shift the elements a i ;:::;a n left by one position (overwriting a i ) and decrease the value of n. After doing this, we check if nis getting much smaller than a:length by checking if a:length 3n. If so, then we call resize () to reduce the size of a. Array Stack T remove(int i) T x a i ; Array-Based Lists add( ,e) add( ,r) add( ,e) br ed e r br ed e r br ed e er br ee e r br er e br ee br eeremove( ) remove( ) remove( ) 01234567891011br eiset( ,i)br ed ebred Figure : A