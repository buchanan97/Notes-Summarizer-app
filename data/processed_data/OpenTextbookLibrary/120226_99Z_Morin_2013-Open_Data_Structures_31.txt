List implementation. Think about how you could improve the performance of the find (x) operation in your USet and SSet implementations. This exercise is designed to give you a feel for how di cult it can be to obtain e cient implementations of these interfaces. Chapter Array-Based Lists In this chapter, we will study implementations of the List and Queue interfaces where the underlying data is stored in an array, called the backing array . The following table summarizes the running times of operations for the data structures presented in this chapter: get(i) set(i;x)add(i;x) remove (i) Array Stack O( ) O(n i) Array Deque O( ) O(minfi;n ig) Dual Array Deque O( ) O(minfi;n ig) Rootish Array Stack O( ) O(n i) Data structures that work by storing data in a single array have many advantages and limitations in common: Arrays o er constant time access to any value in the array. This is what allows get(i) and set(i;x) to run in constant time. Arrays are not very dynamic. Adding or removing an element near the middle of a list means that a large number of elements in the array need to be shifted to make room for the newly added element or to ll in the gap created by the deleted element. This is why the operations add(i;x) and remove (i) have running times that depend onnandi. Arrays cannot expand or shrink. When the number of elements in the data structure exceeds the size of the backing array, a new array Array-Based Lists needs to be allocated and the data from the old array needs to be copied into the new array. This is an expensive operation. The third