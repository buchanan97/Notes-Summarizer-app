yielding 00011110 or . Likewise multiplying 0000 1111 by is done by moving the number spaces to the left (0000 1111 ), yielding 01111000 , or . So it is easy to multiply any number represented in base by a power of (for example 2n) by doing n left bit shifts and backfilling with 's. Note that this also works for multiplication of negative 's complement (or integer) numbers. Multiplying 1111000 (- ) by is done by moving the bits left space and again appending a , yielding 11100010 (or - ) (note that in this case is used for positive or negative numbers). Again multiply 11110001 (- ) by is done using bit shifts and backfilling the number again with zeros, yielding 10001000 (- ) By applying simple arithmetic, it is easy to see how to do multiplication by a constant . Multiplication by can be thought of as multiplication by ( ), so (n ) ((n ) (n )). ( ) ( 0000 1111 ) ( 0000 1111 ) 1111000 11110 100100110 This factoring procedure applies for multiplication by any constant , as any constant can be represented by adding powers of . Thus any co nstant multiplication can be encoded in assembly as a series of shifts and adds. This is sometimes faster, and often easier , than doing the math operations, and should be something every assembly language programmer should be familiar with. This explanation of t he constant multiplication trick works in assembly, which begs the question does it also work in a HLL? The answer is yes and no. Bit shifts and addition can be done in most programming languages, so constant multiplication can