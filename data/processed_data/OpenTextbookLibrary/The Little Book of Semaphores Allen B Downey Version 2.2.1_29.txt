Only the nth thread can lock or unlock the turnstiles. . Before a thread can unlock the rst turnstile, it has to clo se the second, and vice versa; therefore it is impossible for one thread to g et ahead of the others by more than one turnstile. By nding the right kinds of statements to assert and prove, y ou can sometimes nd a concise way to convince yourself (or a skeptical c olleague) that your code is bulletproof. Reusable barrier Preloaded turnstile One nice thing about a turnstile is that it is a versatile comp onent you can use in a variety of solutions. But one drawback is that it forc es threads to go through sequentially, which may cause more context switchi ng than necessary. In the reusable barrier solution, we can simplify the soluti on if the thread that unlocks the turnstile preloads the turnstile with enou gh signals to let the right number of threads through2. The syntax I am using here assumes that signalcan take a parameter that speci es the number of signals. This is a non-standard f eature, but it would be easy to implement with a loop. The only thing to keep i n mind is that the multiple signals are not atomic; that is, the signal ing thread might be interrupted in the loop. But in this case that is not a problem . Reusable barrier solution rendezvous 3mutex.wait() count 5if count n: turnstile.signal(n) unlock the first 7mutex.signal() 9turnstile.wait() first turnstile critical point 13mutex.wait() count - if count : turnstile2.signal(n) unlock the second 17mutex.signal() 19turnstile2.wait() second turnstile When the nth thread arrives, it preloads the rst turnstile with one si