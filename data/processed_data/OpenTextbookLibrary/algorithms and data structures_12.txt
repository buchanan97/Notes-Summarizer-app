begin j : div n; for i : to n do move(s); turn(j) end; But, a useful procedure to draw a circle requires additional arguments. Let us start with the following: procedure circle(x, y, r, n: integer); centered at (x, y); r radius; n number of sides var a, s, i: integer; angle, step, counter begin moveto(x, y r); bottom of circle turnto( ); east a : div n; s : r sin(a); between inscribed and circumscribed polygons for i : to n do move(s); turn(a) end; This procedure places the burden of choosing n on the programmer. A more sophisticated, "adaptive" version might choose the number of sides on its own as a function of the radius of the circle to be drawn. We assume that lengths are measured in terms of pixels (picture elements) on the screen. We observe that a circle of radius r is of This book is licensed under a Creative Commons Attribution License length 2 r. We approximate it by drawing short-line segments, about pixels long, thus needing about r line segments. procedure circle(x, y, r: integer); centered at (x, y); radius r var a, s, i: integer; angle, step, counter begin moveto(x, y r); bottom of circle turnto( ); east a : div r; ( of line segments) s : r sin(a); between inscribed and circumscribed polygons for i : to r do move(s); turn(a) end; This circle procedure still suffers from severe shortcomings: .If we discretize a circle by a set of pixels, it is an unnecessary detour to do this in two steps as done above: first, discretize the circle by a polygon; second, discretize the polygon by pixels. This two-step