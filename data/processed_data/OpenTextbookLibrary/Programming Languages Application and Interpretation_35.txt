these questions cannot be answered statically in a dynamically-scoped language: so your IDE, for instance, cannot overlay arrows to show you this information (as Dr Racket does). Thus, A different way to think about it is that in a dynamically-scoped language, the answer to these questions is the same for all identi ers, and it simply refers to the dynamic environment. In other words, it provides no useful information.even though the rules of scope become more complex as the space of names becomes richer (e.g., objects, threads, etc.), we should always strive to preserve the spirit of static scoping. How Bad Is It? You might look at our running example and wonder whether we re creating a tempest in a teapot. In return, you should consider two situations: . To understand the binding structure of your program, you may need to look at the whole program . No matter how much you ve decomposed your program into small, understandable fragments, it doesn t matter if you have a free identi er anywhere. . Understanding the binding structure is not only a function of the sizeof the program but also of the complexity of its control ow. Imagine an interactive program with numerous callbacks; you d have to track through every one of them, too, to know which binding governs an identi er. Need a little more of a nudge? Let s replace the expression of our example program with this one: (if (moon-visible?) (f1 ) (f2 )) Suppose moon-visible? is a function that presumably evaluates to false on new-moon nights, and true at other times. Then, this program will evaluate to an answer except on new-moon nights, when it will