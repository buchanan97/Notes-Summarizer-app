grows; it never shrinks. Because we agreed that environments are only an alternate implementation strategy for substitution and in particular, that the language s meaning should not change we have to alter the interpreter. Concretely, we should not ask it to carry around all past deferred substitution requests, but instead make it start afresh for every new function, just as the substitution-based interpreter does. This is an easy change: app C-interp-bind-in-env :: (extend-env (bind (fd C-arg fd) (interp a env fds)) mt-env) Now we have truly reproduced the behavior of the substitution interpreter. In case you re wondering how to write a test case that catches errors, look uptest exn . Scope The broken environment interpreter above implements what is known as dynamic scope . This means the environment accumulates bindings as the program executes. As a result, whether an identi er is even bound depends on the history of program execution. We should regard this unambiguously as a aw of programming language design. It adversely affects all tools that read and process programs: compilers, IDEs, and humans. In contrast, substitution and environments, done correctly give us lexical scope orstatic scope . Lexical in this context means as determined from the source program , while static in computer science means without running the program , so these are appealing to the same intuition. When we examine an identi er, we want to know two things: ( ) Is it bound? ( ) If so, where? By where we mean: if there are multiple bindings for the same name, which one governs this identi er? Put differently, which one s substitution will give a value to this identi er? In general,