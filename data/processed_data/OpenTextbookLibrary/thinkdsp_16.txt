how the Spectrum class works. The code for this chapter is in chap02.ipynb , which is in the repository for this book (see Section ). You can also view it at http: tinyurl.com thinkdsp02 . Triangle waves A sinusoid contains only one frequency component, so its spectrum has only one peak. More complicated waveforms, like the violin recording, yield DFTs with many peaks. In this section we investigate the relationship between waveforms and their spectrums. I'll start with a triangle waveform, which is like a straight-line version of a sinusoid. Figure shows a triangle waveform with frequency Hz. To generate a triangle wave, you can use thinkdsp.Triangle Signal : class Triangle Signal(Sinusoid): def evaluate(self, ts): cycles self.freq ts self.offset PI2 Chapter . Harmonics Time (s) Figure : Segment of a triangle signal at Hz. frac, np.modf(cycles) ys np.abs(frac - ) ys normalize(unbias(ys), self.amp) return ys Triangle Signal inherits init from Sinusoid , so it takes the same arguments: freq ,amp, andoffset . The only di erence is evaluate . As we saw before, tsis the sequence of sample times where we want to evaluate the signal. There are many ways to generate a triangle wave. The details are not important, but here's how evaluate works: .cycles is the number of cycles since the start time. np.modf splits the number of cycles into the fraction part, stored in frac , and the integer part, which is ignored1. .frac is a sequence that ramps from to with the given frequency. Subtracting yields values between - and . Taking the absolute value yields a waveform that zig-zags between and . .unbias shifts the waveform down so it is centered at ; then normalize