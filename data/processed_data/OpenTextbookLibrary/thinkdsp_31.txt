smoothly to the beginning. Figure (middle) shows a Hamming window", one of the more common window functions. No window function is perfect, but some can be shown to be optimal for di erent applications, and Hamming is a good, all-purpose window. Figure (bottom) shows the result of multiplying the window by the original signal. Where the window is close to , the signal is unchanged. Where the window is close to , the signal is attenuated. Because the window tapers at both ends, the end of the segment connects smoothly to the beginning. Figure (right) shows the spectrum of the windowed signal. Windowing has reduced leakage substantially, but not completely. Chapter . Non-periodic signals Time (s) Figure : Overlapping Hamming windows. Here's what the code looks like. Wave provideswindow , which applies a Hamming window: class Wave: def window(self, window): self.ys window And Num Py provides hamming , which computes a Hamming window with a given length: window np.hamming(len(wave)) wave.window(window) Num Py provides functions to compute other window functions, including bartlett ,blackman ,hanning , andkaiser . One of the exercises at the end of this chapter asks you to experiment with these other windows. Implementing spectrograms Now that we understand windowing, we can understand the implementation of spectrogram. Here is the Wave method that computes spectrograms: class Wave: def make spectrogram(self, seg length): window np.hamming(seg length) i, j , seg length step seg length spec map . Implementing spectrograms while j len(self.ys): segment self.slice(i, j) segment.window(window) t (segment.start segment.end) spec map t segment.make spectrum() i step j step return Spectrogram(spec map, seg length) This is the longest function in the book, so if you can handle this, you can handle