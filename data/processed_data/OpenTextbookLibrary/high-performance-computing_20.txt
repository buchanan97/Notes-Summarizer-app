ge data structure using non-unit stride, performance suf fers because data is loaded into cache that is not used. For example: DO I ,1000000, SUM SUM A(I) END DO This code would experience the same number of cache misses as the previous loop, and the same amount of data would be loaded into the cache. However , the program needs only one of the eight -bit words loaded into cache. Even though this program performs one-eighth the additions of the previous loop, its elapsed time is roughly the same as the previous loop because the memory operations dominate performance. While this example may seem a bit contrived, there are several situations in which non-unit strides occur quite often. First, when a FOR TRAN twodimensional array is stored in memory , successive elements in the first column are stored sequentially followed by the elements of the second column. If the array is processed with the row iteration as the inner loop, it produces a unit-stride reference pattern as follows: REAL A( , ) DO J , DO I , SUM SUM A(I,J) END DO END DO Interestingly , a FOR TRAN programmer would most likely write the loop (in alphabetical order) as follows, producing a non-unit stride of bytes between successive load operations: REAL A( , ) DO I , DO J , SUM SUM A(I,J) END DO END DO Because of this, some compilers can detect this suboptimal loop order and reverse the order of the loops to make best use of the memory system. As we will see in link , however , this code transformation may produce different results, and so you may have to give the compiler