and that this value is stored in a variable, n, that is accessible from all threads. When the rst n threads arrive they should block until the nth thread arrives, at which point all the threads may proceed. Barrier Barrier hint For many of the problems in this book I will provide hints by pr esenting the variables I used in my solution and explaining their roles. Barrier hint 1n the number of threads 2count 3mutex Semaphore( ) 4barrier Semaphore( ) countkeeps track of how many threads have arrived. mutexprovides exclusive access to countso that threads can increment it safely. barrier is locked (zero or negative) until all threads arrive; then i t should be unlocked ( or more). Basic synchronization patterns Barrier Barrier non-solution First I will present a solution that is not quite right, becau se it is useful to examine incorrect solutions and gure out what is wrong. Barrier non-solution 1rendezvous 3mutex.wait() count count 5mutex.signal() 7if count n: barrier.signal() 9barrier.wait() 11critical point Sincecountis protected by a mutex, it counts the number of threads that pass. The rst n threads wait when they get to the barrier, which is initiall y locked. When the nth thread arrives, it unlocks the barrier. Puzzle: What is wrong with this solution? Basic synchronization patterns Barrier Deadlock The problem is a deadlock. An an example, imagine that n and that threads are waiting at the barrier. The value of the semaphore is the number of threads i n queue, negated, which is - . Whenthe5ththreadsignalsthebarrier, oneofthewaitingth readsisallowed to proceed, and the semaphore is incremented to - . But then no one signals the semaphore again and none of the oth er threads