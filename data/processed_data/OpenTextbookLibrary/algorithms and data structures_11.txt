higher level we have procedures: they let us refer to a program fragment of arbitrary size and complexity as a single entity, and build hierarchically nested structures. Modern programming languages provide yet another level of packaging: modules, or packages, useful for grouping related data and procedures. We limit our discussion to the use of procedures. Programmers accumulate their own collection of useful program fragments. Programming languages provide the concept of a procedure as the major tool for turning fragments into reusable building blocks. A procedure consists of two parts with distinct purposes: .The heading specifies an important part of the procedure's external behavior through the list of formal parameters: namely, what type of data moves in and out of the procedure. .The body implements the action performed by the procedure, processing the input data and generating the output data. A program fragment that embodies a single coherent concept is best written as a procedure. This is particularly true if we expect to use this fragment again in a different context. The question of how general we want a procedure to be deserves careful thought. If the procedure is too specific, it will rarely be useful. If it is too general, it may be unwieldy: too large, too slow, or just too difficult to understand. The generality of a procedure depends primarily on the choice of formal parameters. Example: the long road toward a procedure circle Let us illustrate these issues by discussing design considerations for a procedure that draws a circle on the screen. The program fragment above for drawing a regular polygon is easily turned into procedure ngon(n,s: integer); n number of sides, s step size var i,j: integer;