just be passed along unchanged in the recursive calls. interp-body :: (type-case Expr C e num C (n) n id C-interp-case app C-interp-case plus C (l r) ( (interp l fds) (interp r fds)) mult C (l r) ( (interp l fds) (interp r fds)) ) Now let s tackle application. First we have to look up the function de nition, for which we ll assume we have a helper function of this type available: ; get-fundef : symbol (listof Fun Def C) - Fun Def C Assuming we nd a function of the given name, we need to evaluate its body. However, remember what we said about identi ers and parameters? We must search-andreplace , a process you have seen before in school algebra called substitution . This is suf ciently important that we should talk rst about substitution before returning to the interpreter (section ). Substitution Substitution is the act of replacing a name (in this case, that of the formal parameter) in an expression (in this case, the body of the function) with another expression (in this case, the actual parameter). Let s de ne its type: ; subst : Expr C symbol Expr C - Expr C It helps to also give its parameters informative names: subst :: (define (subst what : Expr C for : symbol in : Expr C ) : Expr C subst-body ) The rst argument is what we want to replace the name with; the second is for what name we want to perform substitution; and the third is in which expression we want to do it. Do Now! Suppose we want to substitute 3for the identi er xin the bodies