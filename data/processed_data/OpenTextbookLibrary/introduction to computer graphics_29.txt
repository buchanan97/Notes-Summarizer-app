As new capabilities were added to Open GL, the API grew in size . But the growth was still outpaced by the invention of new, more sophisticated techni ques for doing graphics. Some of these new techniques were added to Open GL, but the problem is that no matter how many features you add, there will always be demands for new featur es as well as complaints that all the new features are making things too complicated! Open GL w as a giant machine, with new pieces always being tacked onto it, but still not pleasing ev eryone. The real solution was to make the machine programmable . With Open GL , it became possible to write programs CHAPTER . INTRODUCTION to be executed as part of the graphical computation in the GPU . The programs are run on the GPU at GPU speed. A programmer who wants to use a new graphics t echnique can write a program to implement the feature and just hand it to the GPU. T he Open GL API doesn t have to be changed. The only thing that the API has to support is the ability to send programs to the GPU for execution. The programs are called shaders (although the term doesn t really describe what most of them actually do). The rst shaders to be introduced were vertex shaders andfragment shaders . When a primitive is drawn, some work has to be done at each ver tex of the primitive, such as applying a geometric transform to the vertex coordin ates or using the attributes and global lighting environment to compute the color of that ver tex. A vertex shader is