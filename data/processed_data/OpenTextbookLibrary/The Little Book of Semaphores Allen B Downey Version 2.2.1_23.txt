sconventionaltoshowo nlyonecopyofthe code, but you should imagine multiple copies of the code runn ing concurrently in multiple threads. Multiplex solution 1multiplex.wait() critical section 3multiplex.signal() What happens if the critical section is occupied and more tha n one thread arrives? Of course, what we want is for all the arrivals to wai t. This solution does exactly that. Each time an arrival joins the queue, the s emaphore is decremented, so that the value of the semaphore (negated) represe nts the number of threads in queue. When a thread leaves, it signals the semaphore, incrementin g its value and allowing one of the waiting threads to proceed. Thinking again of metaphors, in this case I nd it useful to th ink of the semaphore as a set of tokens (rather than a lock). As each thre ad invokes wait, it picks up one of the tokens; when it invokes signalit releases one. Only a thread that holds a token can enter the room. If no tokens are a vailable when a thread arrives, it waits until another thread releases one . In real life, ticket windows sometimes use a system like this . They hand out tokens (sometimes poker chips) to customers in line. Eac h token allows the holder to buy a ticket. Barrier Consider again the Rendezvous problem from Section . A limitation of the solution we presented is that it does not work with more than t wo threads. Puzzle: Generalize the rendezvous solution. Every thread s hould run the following code: Barrier code 1rendezvous 2critical point Basic synchronization patterns Thesynchronizationrequirementisthatnothreadexecutes critical point until after all threads have executed rendezvous . You can assume that there are nthreads