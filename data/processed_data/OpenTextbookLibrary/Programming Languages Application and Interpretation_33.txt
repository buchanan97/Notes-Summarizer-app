(fd C 'f2'y (plus C (id C 'x) (id C 'y))))) In our interpreter, this evaluates to . Should it? Translated into Racket, this test corresponds to the following two de nitions and expression: (define (f1 x) (f2 )) (define (f2 y) ( x y)) (f1 ) What should this produce? (f1 ) substitutes xwith 3in the body of f1, which then invokes (f2 ) . But notably, in f2, the identi er xisnot bound ! Sure enough, Racket will produce an error. In fact, so will our substitution-based interpreter! Why does the substitution process result in an error? It s because, when we replace the representation of xwith the representation of 3in the representation of f1, we do so inf1only. (Obviously: xisf1 s parameter; even if another function had a parameter This the representation of is getting a little annoying, isn t it? Therefore, I ll stop saying that, but do make sure you understand why I had to say it. It s an important bit of pedantry.named x, that s a different x.) Thus, when we get to evaluating the body of f2, itsx hasn t been substituted, resulting in the error. What went wrong when we switched to environments? Watch carefully: this is subtle. We can focus on applications, because only they affect the environment. When we substituted the formal for the value of the actual, we did so by extending the current environment . In terms of our example, we asked the interpreter to substitute not only f2 s substitution in f2 s body, but also the current ones (those for the caller, f1), and indeed all past ones as well. That is, the environment only