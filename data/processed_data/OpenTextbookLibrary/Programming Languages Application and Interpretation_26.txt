wrong. Do Now! Do you see why? Reason from the types. What does the interpreter return? Numbers. What does substitution return? Oh, that s right, expressions! For instance, when we substituted in the body of double , we got back the representation of ( ) . This is not a valid answer for the interpreter. Instead, it must be reduced to an answer. That, of course, is precisely what the interpreter does: app C-interp-case :: app C (f a) (local ( define fd (get-fundef f fds) ) (interp (subst a (fd C-arg fd) (fd C-body fd)) fds)) Okay, that leaves only one case: identi ers. What could possibly be complicated about them? They should be just about as simple as numbers! And yet we ve put them off to the very end, suggesting something subtle or complex is afoot. Do Now! Work through some examples to understand what the interpreter should do in the identi er case. Let s suppose we had de ned double as follows: (define (double x) ( x y)) When we substitute 5forx, this produces the expression ( y) . So far so good, but what is left to substitute y? As a matter of fact, it should be clear from the very outset that this de nition of double iserroneous . The identi er yis said to be free, an adjective that in this setting has negative connotations. In other words, the interpreter should never confront an identi er. All identi ers ought to be parameters that have already been substituted (known as bound identi ers here, a positive connotation) before the interpreter ever sees them. As a result, there is only one possible response