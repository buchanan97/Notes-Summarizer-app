In contrast, subtraction and other additions represent our user-facing, surface language. It s wise to record conceptually different ideas in distinct datatypes, rather than shoehorn them into one. The separation can look a little unwieldy sometimes, but it makes the program much easier for future developers to read and maintain. Besides, for different purposes you might want to layer on different extensions, and separating the core from the surface enables that. Therefore, we ll de ne a new datatype to re ect our intended surface syntax terms: (define-type Arith S num S (n : number) plus S (l : Arith S) (r : Arith S) bminus S (l : Arith S) (r : Arith S) mult S (l : Arith S) (r : Arith S) ) This looks almost exactly like Arith C , other than the added case, which follows the familiar recursive pattern. Given this datatype, we should do two things. First, we should modify our parser to also parse -expressions, and always construct Arith S terms (rather than any Arith C ones). Second, we should implement a desugar function that translates Arith S values into Arith C ones. Let s write the obvious part of desugar : desugar :: (define (desugar as : Arith S ) : Arith C (type-case Arith S as num S (n) (num C n) plus S (l r) (plus C (desugar l) (desugar r)) mult S (l r) (mult C (desugar l) (desugar r)) bminus S-case )) Now let s convert the mathematical description of subtraction above into code: bminus S-case :: bminus S (l r) (plus C (desugar l) (mult C (num C - ) (desugar r))) Do Now! It s