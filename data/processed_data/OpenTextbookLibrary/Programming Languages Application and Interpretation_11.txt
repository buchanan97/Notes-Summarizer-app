code it requires is small, and can easily be embedded in many contexts. By integrating the syntax into the language, it becomes easy for programs to manipulate representations of programs (as we will see more of in REF ). It s therefore no surprise that even though many Lisp-based syntaxes have had wildly different semantics, they all share this syntactic legacy. Of course, we could just use XML instead. That would be much better. Or JSON . Because that wouldn t be anything like an s-expression at all. A First Look at Interpretation Now that we have a representation of programs, there are many ways in which we might want to manipulate them. We might want to display a program in an attractive way ( pretty-print ), convert into code in some other format ( compilation ), ask whether it obeys certain properties ( veri cation ), and so on. For now, we re going to focus on asking what value it corresponds to ( evaluation the reduction of programs to values ). Let s write an evaluator, in the form of an interpreter , for our arithmetic language. We choose arithmetic rst for three reasons: (a) you already know how it works, so we can focus on the mechanics of writing evaluators; (b) it s contained in every language we will encounter later, so we can build upwards and outwards from it; and (c) it s at once both small and big enough to illustrate many points we d like to get across. Representing Arithmetic Let s rst agree on how we will represent arithmetic expressions. Let s say we want to support only two operations addition and multiplication