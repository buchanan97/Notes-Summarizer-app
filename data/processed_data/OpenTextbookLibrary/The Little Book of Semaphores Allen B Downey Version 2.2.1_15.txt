result is ne gative, the thread blocks itself and cannot continue until another thre ad increments the semaphore. . When a thread increments the semaphore, if there are other threads waiting, one of the waiting threads gets unblocked. Tosaythatathreadblocksitself(orsimply blocks )istos aythatitnoti es the scheduler that it cannot proceed. The scheduler will pre vent the thread from running until an event occurs that causes the thread to becom e unblocked. In the tradition of mixed metaphors in computer science, unblo cking is often called waking . That s all there is to the de nition, but there are some conse quences of the de nition you might want to think about. Semaphores In general, there is no way to know before a thread decrements a semaphore whether it will block or not (in speci c cases you m ight be able to prove that it will or will not). After a thread increments a semaphore and another thread get s woken up, both threads continue running concurrently. There is no way to know which thread, if either, will continue immediately. Whenyousignalasemaphore, youdon tnecessarilyknowwhet heranother thread is waiting, so the number of unblocked threads may be z ero or one. Finally, you might want to think about what the value of the se maphore means. If the value is positive, then it represents the numbe r of threads that can decrement without blocking. If it is negative, then it re presents the number of threads that have blocked and are waiting. If the value is z ero, it means there are no threads waiting, but if a thread tries to decrement, it will block. Syntax In most programming environments, an implementation