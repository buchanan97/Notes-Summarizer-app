so they stay in whatever mode they were originally. By the way, a set of specific bits (such as the 0x06 above) is often referred to as a bit pattern or bitmask. To see if a specific bit is set, simply AND instead of OR. So, to see if the 1st bit of DDR is set for output mode, you could use something like: if ( DDR 0x02 ) true if set Clearing bits requires ANDing with a bitmask that has been complemented. In other words, all 1s and 0s have been reversed in the bit pattern. If, for example, we want to clear the 0th and 4th bits, we d first complement the bit pattern 0x11 yielding 0xee. Then we AND: DDR 0xee; Often, it s easier to just use the logical complement operator on the original bit pattern and then AND it: DDR ( 0x11); If you re dealing with a single bit, you can use the left shift operator so you don t even have to bother figuring out the bit pattern in hex. To set the 3rd bit and then clear the 4th bit of DDR, you could use the following: DDR (0x01 ); DDR (0x01 ); These operations are so common that they are often invoked using an in-line expansion via a define. define Very often it is desirable to use symbolic constants in place of actual values. For example, you d probably prefer to use a symbol such as PI instead of the number . You can do this with the define preprocessor directive. These are normally found in header files (such as stdio.h or math.h) or at the top of a module of