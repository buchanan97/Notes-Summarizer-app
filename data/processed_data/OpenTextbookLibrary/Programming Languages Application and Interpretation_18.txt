that the recursion is generative , which forces us to take extra care. If you haven t heard of generative recursion before, read the section on it in How to Design Programs . Essentially, in generative recursion the sub-problem is a computed function of the input, rather than a structural piece of it. This is an especially simple case of generative recursion, because the function is simple: it s just the bminus S constructor.We might be tempted to x this by using a different rewrite: uminus S (e) (bminus S (num S ) (desugar e)) which does indeed eliminate the generativity. Do Now! Unfortunately, this desugaring transformation won t work at all! Do you see why? If you don t, try to run it. . The second is that we are implicitly depending on exactly what bminus S means; if its meaning changes, so will that of uminus S , even if we don t want it to. In contrast, de ning a functional abstraction that consumes two terms and generates one representing the addition of the rst to - times the second, and using this to de ne the desugaring of both uminus S andbminus S , is a little more faulttolerant. You might say that the meaning of subtraction is never going to change, so why bother? Yes and no. Yes, it s meaning is unlikely to change; but no, its implementation might. For instance, the developer may decide to log all uses of binary subtraction. In the macro expansion, all uses of unary negation would also get logged, but they would not in the second expansion. Fortunately, in this particular case we have a much simpler option,