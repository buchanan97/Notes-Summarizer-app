and the entry doesn t exist in the TLB, you suf fer a TLB miss . The information needed may have to be generated (a new page may need to be created), or it may have to be retrieved from the page table. The TLB is good for the same reason that other types of caches are good: it reduces the cost of memory references. But like other caches, there are pathological cases where the TLB can fail to deliver value. The easiest case to construct is one where every memory reference your program makes causes a TLB miss: REAL X(10000000) COMMON X DO I ,9999 DO J ,10000000,10000 SUM SUM X(J I) END DO END DO Assume that the TLB page size for your computer is less than KB. Every time through the inner loop in the above example code, the program asks for data that is bytes , , bytes away from the last reference. That is, each reference falls on a dif ferent memory page. This causes 1000 TLB misses in the inner loop, taken 1001 times, for a total of at least one million TLB misses. T o add insult to injury , each reference is guaranteed to cause a data cache miss as well. Admittedly , no one would start with a loop like the one above. But presuming that the loop was any good to you at all, the restructured version in the code below would cruise through memory like a warm knife through butter: REAL X(10000000) COMMON X DO I ,10000000 SUM SUM X(I) END DO The revised loop has unit stride, and TLB misses occur only every so often. Usually it is