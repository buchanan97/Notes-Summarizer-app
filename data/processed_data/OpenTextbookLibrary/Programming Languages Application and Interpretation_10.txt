(define (parse s : s-expression ) : Arith C (cond (s-exp-number? s) (num C (s-exp- number s)) (s-exp-list? s) (let ( sl (s-exp- list s) ) (case (s-exp- symbol (first sl)) ( ) (plus C (parse (second sl)) (parse (third sl))) ( ) (mult C (parse (second sl)) (parse (third sl))) else (error 'parse "invalid list input") )) else (error 'parse "invalid input") )) Thus: (parse '( ( ) ( ))) - Arith C (plus C (mult C (num C ) (num C )) (plus C (num C ) (num C ))) Congratulations! You have just completed your rst representation of a program . From now on we can focus entirely on programs represented as recursive trees, ignoring the vagaries of surface syntax and how to get them into the tree form. We re nally ready to start studying programming languages! Exercise What happens if you forget to quote the argument to the parser? Why? Coda Racket s syntax, which it inherits from Scheme and Lisp, is controversial. Observe, however, something deeply valuable that we get from it. While parsing traditional languages can be very complex, parsing this syntax is virtually trivial. Given a sequence of tokens corresponding to the input, it is absolutely straightforward to turn parenthesized sequences into s-expressions; it is equally straightforward (as we see above) to turn sexpressions into proper syntax trees. I like to call such two-level languages bicameral , in loose analogy to government legislative houses: the lower-level does rudimentary well-formedness checking, while the upper-level does deeper validity checking. (We haven t done any of the latter yet, but we will REF .) The virtues of this syntax are thus manifold. The amount of