one thread, so that the two kinds of object were in one-to-one correspondence, and it was not important to distinguish them. However, in this book, I will consistently make the distinction. When I am referring to the ability to set an independent sequence of programmed actions in motion, I will write about creating threads. Only when I am referring to the ability to protect threads will I write about creating processes. In order to support threads, operating system APIs include features such as the ability to create a new thread and to kill o an existing thread. Inside the operating system, there must be some mechanism for switching the computer's attention between the various threads. When the operating system suspends execution of one thread in order to give another thread a chance to make progress, the operating system must store enough information about the rst thread to be able to successfully resume its execution later. Chapter addresses these issues. Some threads may not be runnable at any particular time, because they are waiting for some event, such as the arrival of input. However, in general, . INTERACTIONS BETWEEN COMPUTATIONS an operating system will be confronted with multiple runnable threads and will have to choose which ones to run at each moment. This problem of scheduling threads' execution has many solutions, which are surveyed in Chapter . The scheduling problem is interesting, and has generated so many solutions, because it involves the balancing of system users' competing interests and values. No individual scheduling approach will make everyone happy all the time. My focus is on explaining how the di erent scheduling approaches t di erent contexts of system usage and achieve