stay out of the way of the compiler . Often constructs used to improve performance on a particular architecture limit our ability to achieve performance on another architecture. Further , these brilliant (read obtuse) hand optimizations often confuse a compiler , limiting its ability to automatically transform our code to take advantage of the particular strengths of the computer architecture. As programmers, it is important to know how the compiler works so we can know when to help it out and when to leave it alone. W e also must be aware that as compilers improve (never as much as salespeople claim) it s best to leave more and more to the compiler . As we move up the hierarchy of high performance computers, we need to learn new techniques to map our programs onto these architectures, including language extensions, library calls, and compiler directives. As we use these features, our programs become less portable. Also, using these higher -level constructs, we must not make modifications that result in poor performance on the individual RISC microprocessors that often make up the parallel processing system. Measuring Performance When a computer is being purchased for computationally intensive applications, it is important to determine how well the system will actually perform this function. One way to choose among a set of competing systems is to have each vendor loan you a system for a period of time to test your applications. At the end of the evaluation period, you could send back the systems that did not make the grade and pay for your favorite system. Unfortunately , most vendors won t lend you a system for such an extended period of time