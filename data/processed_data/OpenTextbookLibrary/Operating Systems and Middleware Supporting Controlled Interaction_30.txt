those in another by directing their memory accesses to di erent regions of memory. Having broached the topic of providing processes with isolated virtual memory, I devote Chapter to processes. This chapter explains an API for creating processes. However, I also focus on protection mechanisms, not only by building on Chapter 's introduction of virtual memory, but also by explaining other forms of protection that are used to protect processes from one another and to protect the operating system itself from the processes. Some of these protection mechanisms can be used to protect not just the storage of values in memory, but also longer-term data storage, such as les, and even network communication channels. Therefore, Chapter lays some groundwork for the later treatment of these topics. Chapter also provides me an opportunity to clarify one point about threads left open by Chapter . By showing how operating systems provide a protective boundary between themselves and the running application processes, I can explain where threads fall relative to this boundary. In particular, there are threads that are contained entirely within the operating . SUPPORTING INTERACTION ACROSS TIME system kernel, others that are contained entirely within an application process, and yet others that cross the boundary, providing support from within the kernel for concurrent activities within the application process. Although it might seem natural to discuss these categories of threads in Chapter , the chapter on threads, I really need to wait for Chapter in order to make any more sense out of the distinctions than I've managed in this introductory paragraph. When two computations run concurrently on a single computer, the hard part of supporting controlled interaction is to keep the