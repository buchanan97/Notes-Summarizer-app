the interpreter provides. As a result, we should think of the previous interpreter as a reference implementation that the one we re about to write should match. Indeed, we should create a generator that creates lots of tests, runs them through both interpreters, and makes sure their answers are the same. Ideally, we should prove that the two interpreters behave the same, which is a good topic for advanced study. One subtlety is in de ning precisely what the same means, especially with regards to failure.Let s rst de ne our environment data structure. An environment is a list of pairs of names associated with what? Do Now! A natural question to ask here might be what the environment maps names to. But a better, more fundamental, question is: How to determine the answer to the natural question? Remember that our environment was created to defer substitutions. Therefore, the answer lies in substitution. We discussed earlier (section ) that we want substitution to map names to answers, corresponding to an eager function application strategy. Therefore, the environment should map names to answers. (define-type Binding bind (name : symbol) (val : number) ) (define-type-alias Env (listof Binding)) (define mt-env empty) (define extend-env cons) Interpreting with Environments Now we can tackle the interpreter. One case is easy, but we should revisit all the others: :: (define (interp expr : Expr C env : Env fds : (listof Fun Def C) ) : number (type-case Expr C expr num C (n) n id C-case app C-case plus C mult C-case )) The arithmetic operations are easiest. Recall that before, the interpreter recurred without performing any new substitutions. As a result, there are no