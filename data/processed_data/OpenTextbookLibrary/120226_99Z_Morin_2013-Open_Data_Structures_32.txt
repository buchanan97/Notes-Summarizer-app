point is important. The running times cited in the table above do not include the cost associated with growing and shrinking the backing array. We will see that, if carefully managed, the cost of growing and shrinking the backing array does not add much to the cost of an averageoperation. More precisely, if we start with an empty data structure, and perform any sequence of madd(i;x) orremove (i) operations, then the total cost of growing and shrinking the backing array, over the entire sequence of moperations is O(m). Although some individual operations are more expensive, the amortized cost, when amortized over all moperations, is only O( ) per operation. Array Stack : Fast Stack Operations Using an Array An Array Stack implements the list interface using an array a, called the backing array . The list element with index iis stored in a i . At most times, ais larger than strictly necessary, so an integer nis used to keep track of the number of elements actually stored in a. In this way, the list elements are stored in a , , a n and, at all times, a:length n. Array Stack T a; int n; int size() return n; The Basics Accessing and modifying the elements of an Array Stack using get(i) and set(i;x) is trivial. After performing any necessary bounds-checking we simply return or set, respectively, a i . Array Stack T get(int i) Array Stack : Fast Stack Operations Using an Array return a i ; T set(int i, T x) T y a i ; a i x; return y; The operations of adding and removing elements from an Array Stack are illustrated in Figure .