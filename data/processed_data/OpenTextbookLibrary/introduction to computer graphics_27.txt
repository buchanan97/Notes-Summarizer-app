along with the appl ication program that it is running. Open GL commands come from the program that is runni ng on the CPU. However, it is actually possible to run Open GL programs remotely over a network. That is, you can execute an application program on a remote computer (the Ope n GL client), while the graphics computations and display are done on the computer that you ar e actually using (the Open GL server). The key idea is that the client and the server are separate com ponents, and there is a communication channel between those components. Open GL co mmands and the data that they need are communicated from the client (the CPU) to the se rver (the GPU) over that channel. The capacity of the channel can be a limiting factor in graphics performance. Think of drawing an image onto the screen. If the GPU can draw the ima ge in microseconds, but it takesmillisecondstosendthedatafortheimagefromthe CPU tothe GPU,thenthegreatspeed of the GPU is irrelevant most of the time that it takes to draw the image is communication time. For this reason, one of the driving factors in the evolution o f Open GL has been the desire to limit the amount of communication that is needed between t he CPU and the GPU. One approach is to store information in the GPU s memory. If some data is going to be used several times, it can be transmitted to the GPU once and stored in memo ry there, where it will be immediately accessible to the GPU. Another approach is to tr y to decrease the number of Open GL commands that must be transmitted to the