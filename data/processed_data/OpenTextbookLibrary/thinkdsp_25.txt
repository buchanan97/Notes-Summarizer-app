freqs dts phases np.cumsum(dphis) ys self.amp np.cos(phases) return ys tsis the sequence of points in time where the signal should be evaluated; to keep this function simple, I assume they are equally-spaced. To compute the frequency at each point in time, I use np.linspace , which returns a Num Py array of nvalues between start andend. np.diff computes the di erence between adjacent elements of ts, returning the length of each interval in seconds. If the elements of tsare equally spaced, thedtsare all the same. . Exponential chirp The next step is to gure out how much the phase changes during each interval. In Section we saw that when frequency is constant, the phase, , increases linearly over time: ft When frequency is a function of time, the change in phase during a short time interval, tis: f(t) t In Python, since freqs containsf(t) anddtscontains the time intervals, we can write dphis PI2 freqs dts Now, since dphis contains the changes in phase, we can get the total phase at each timestep by adding up the changes: phases np.cumsum(dphis) phases np.insert(phases, , ) np.cumsum computes the cumulative sum, which is almost what we want, but it doesn't start at . So I use np.insert to add a at the beginning. The result is a Num Py array where the ith element contains the sum of the rstiterms from dphis ; that is, the total phase at the end of the ith interval. Finally,np.cos computes the amplitude of the wave as a function of phase (remember that phase is expressed in radians). If you know calculus, you might notice that the limit as tgets small is d f(t)dt Dividing through by