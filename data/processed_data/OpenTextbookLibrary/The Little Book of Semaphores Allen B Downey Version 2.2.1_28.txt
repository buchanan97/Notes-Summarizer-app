and then open the second. Basic synchronization patterns Reusable barrier Reusable barrier solution Reusable barrier solution rendezvous 3mutex.wait() count 5if count n: turnstile2.wait() lock the second turnstile.signal() unlock the first 8mutex.signal() 10turnstile.wait() first turnstile 11turnstile.signal() critical point 15mutex.wait() count - if count : turnstile.wait() lock the first turnstile2.signal() unlock the second 20mutex.signal() 22turnstile2.wait() second turnstile 23turnstile2.signal() This solution is sometimes called a two-phase barrier because it forces all the threads to wait twice: once for all the threads to arrive a nd again for all the threads to execute the critical section. Unfortunately, this solution is typical of most non-trivia l synchronization code: it is di cult to be sure that a solution is correct. Ofte n there is a subtle way that a particular path through the program can cause an er ror. To make matters worse, testing an implementation of a soluti on is not much help. The error might occur very rarely because the particul ar path that causes it might require a spectacularly unlucky combination of cir cumstances. Such errors are almost impossible to reproduce and debug by conve ntional means. The only alternative is to examine the code carefully and pr ove that it is correct. I put prove in quotation marks because I don t mea n, necessarily, that you have to write a formal proof (although there are zeal ots who encourage such lunacy). The kind of proof I have in mind is more informal. We can take ad vantage of the structure of the code, and the idioms we have developed , to assert, and then demonstrate, a number of intermediate-level claims ab out the program. For example: Basic synchronization patterns .