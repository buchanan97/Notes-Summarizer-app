of the three example functions above. What should it produce? Indouble , this should produce ( ) ; inquadruple , it should produce (double (double )) ; and in const5 , it should produce (i.e., no substitution happens because there are no instances of xin the body). A common mistake is to assume that the result of substituting, e.g., forxindouble is (define (double x) ( )) . This is incorrect. We only substitute at the point when we apply the function , at which point the function s invocation is replaced by its body. The header enables us to nd the function and ascertain the name of its parameter; but only its body remains for evaluation. Examine how substitution is used to notice the type error that would result from returning a function de nition.These examples already tell us what to do in almost all the cases. Given a number, there s nothing to substitute. If it s an identi er, we haven t seen an example with a different identi er but you ve guessed what should happen: it stays unchanged. In the other cases, descend into the sub-expressions, performing substitution. Before we turn this into code, there s an important case to consider. Suppose the name we are substituting happens to be the name of a function. Then what should happen? Do Now! What, indeed, should happen? There are many ways to approach this question. One is from a design perspective: function names live in their own world , distinct from ordinary program identi ers. Some languages (such as C and Common Lisp, in slightly different ways) take this perspective, and partition identi ers into different namespaces depending