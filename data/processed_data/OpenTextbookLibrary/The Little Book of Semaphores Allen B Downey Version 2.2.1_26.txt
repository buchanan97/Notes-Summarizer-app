barrier.wait() barrier.signal() 9mutex.signal() 11critical point This turns out to be a bad idea because it can cause a deadlock. Imagine that the rst thread enters the mutex and then blocks when it reaches the turnstile. Since the mutex is locked, no other th reads can enter, so the condition, count n , will never be true and no one will ever unlock the turnstile. In this case the deadlock is fairly obvious, but it demonstra tes a common source of deadlocks: blocking on a semaphore while holding a mutex. Reusable barrier Often a set of cooperating threads will perform a series of st eps in a loop and synchronize at a barrier after each step. For this applicati on we need a reusable barrier that locks itself after all the threads have passed t hrough. Puzzle: Rewrite the barrier solution so that after all the th reads have passed through, the turnstile is locked again. Basic synchronization patterns Reusable barrier Reusable barrier non-solution Once again, we will start with a simple attempt at a solution a nd gradually improve it: Reusable barrier non-solution 1rendezvous 3mutex.wait() count 5mutex.signal() 7if count n: turnstile.signal() 9turnstile.wait() 10turnstile.signal() 12critical point 14mutex.wait() count - 16mutex.signal() 18if count : turnstile.wait() Notice that the code after the turnstile is pretty much the sa me as the code before it. Again, we have to use the mutex to protect access to the shared variablecount. Tragically, though, this code is not quite correct. Puzzle: What is the problem? Basic synchronization patterns Reusable barrier Reusable barrier problem There is a problem spot at Line 7of the previous code. If then 1th thread is interrupted at this point, and then the nth