in seen , we go back to Step . . Otherwise, we add the node to seen and add its neighbors to the stack. When the stack is empty, we can't reach any more nodes, so we break out of the loop and return seen . As an example, we can nd all nodes in the complete graph that are reachable from node : reachable nodes(complete, ) , , , , , , , , , Initially, the stack contains node and seen is empty. The rst time through the loop, node is added to seen and all the other nodes are added to the stack (since they are all neighbors of node ). The next time through the loop, popreturns the last element in the stack, which is node . So node gets added to seen and its neighbors get added to the stack. Chapter Graphs Notice that the same node can appear more than once in the stack; in fact, a node withkneighbors will be added to the stack ktimes. Later, we will look for ways to make this algorithm more e cient. We can use reachable nodes to write is connected : def is connected(G): start next(iter(G)) reachable reachable nodes(G, start) return len(reachable) len(G) is connected chooses a starting node by making a node iterator and choosing the rst element. Then it uses reachable to get the set of nodes that can be reached from start . If the size of this set is the same as the size of the graph, that means we can reach all nodes, which means the graph is connected. A complete graph is, not surprisingly, connected: is connected(complete) True In the