C source code. You might see something like: define PI Once the compiler sees this, every time it comes across the token PI it will replace it with the value . This directive uses a simple substitution but you can do many more complicated things than this. For example, you can also create something that looks like a function: Embedded Controllers define parallel((x),(y)) ((x) (y)) ((x) (y)) The x and y serve as placeholders. Thus, the line a parallel( b, c ); gets expanded to: a (a b) (a b); Why do this? Because it s an in-line expansion or macro. That means that there s no function call overhead and the operation runs faster. At the same time, it reads like a function, so it s easier for a programmer to follow. OK, but why all the extra parentheses? The reason is because x and y are placeholders, and those items might be expressions, not simple variables. If you did it this way you might get in trouble: define parallel(x,y) x y (x y) What if x is an expression, as in the following example? a parallel( b,c); This would expand to: a b c ( b c); As multiplication is executed before addition, you wind up with being added to the product of b times c after the division, which is not the same as the sum of and b being multiplied by c, and that quantity then being divided. By using the extra parentheses, the order of execution is maintained. Referring back to the bit field operations, here are some useful definitions for what appear to be functions but which are, in fact, bitwise operations expanded in-line: