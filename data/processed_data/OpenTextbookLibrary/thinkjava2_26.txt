You might expect the variableyto get the value0.333333, which is a legal floating-point value. But instead it gets the value0. . The expression on the right divides two integers, so Java does integer division, which yields theint value0. Converted todouble, the value assigned toyis0. . One way to solve this problem (once you figure out the bug) is to make the right-hand side a floating-point expression. The following setsyto0.333333, as expected: double y ; correct As a matter of style, you should always assign floating-point values to floatingpoint variables. The compiler won t make you do it, but you never know when a simple mistake will come back and haunt you. Rounding Errors Most floating-point numbers are onlyapproximatelycorrect. Some numbers, like reasonably sized integers, can be represented exactly. But repeating fractions, like1 , and irrational numbers, like , cannot. To represent these numbers, computers have to round off to the nearest floating-point number. Operators for Strings The difference between the number we want and the floating-point number we get is calledrounding error. For example, the following two statements should be equivalent: System.out.println( ); System.out.println( ); But on many machines, the output is as follows: The problem is that0.1is a repeating fraction when converted into binary. So its floating-point representation stored in memory is only approximate. When we add up the approximations, the rounding errors accumulate. For many applications (like computer graphics, encryption, statistical analysis, and multimedia rendering), floating-point arithmetic has benefits that outweigh the costs. But if you needabsoluteprecision, use integers instead. For example, consider a bank account with a balance of : double balance ; potential rounding error In this example, balances will become inaccurate over time as the