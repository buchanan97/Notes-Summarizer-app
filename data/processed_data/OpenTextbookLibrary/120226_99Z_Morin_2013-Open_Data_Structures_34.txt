sequence of add(i;x) and remove (i) operations on an Array Stack . Arrows denote elements being copied. Operations that result in a call to resize () are marked with an asterisk. Array Stack : Fast Stack Operations Using an Array for (int j i; j n- ; j ) a j a j ; n--; if (a.length n) resize(); return x; If we ignore the cost of the resize () method, the cost of a remove (i) operation is proportional to the number of elements we shift, which is O(n i). Growing and Shrinking Theresize () method is fairly straightforward; it allocates a new array b whose size is nand copies the nelements of ainto the rst npositions in b, and then sets atob. Thus, after a call to resize (),a:length 2n. Array Stack void resize() T b new Array(max(n , )); for (int i ; i n; i ) b i a i ; a b; Analyzing the actual cost of the resize () operation is easy. It allocates an array bof size nand copies the nelements of aintob. This takes O(n) time. The running time analysis from the previous section ignored the cost of calls to resize (). In this section we analyze this cost using a technique known as amortized analysis . This technique does not try to determine the cost of resizing during each individual add(i;x) and remove (i) operation. Instead, it considers the cost of all calls to resize () during a sequence of mcalls to add(i;x) orremove (i). In particular, we will show: Lemma . If an empty Array List is created and any sequence of m calls to add(i;x)andremove (i)are performed, then the