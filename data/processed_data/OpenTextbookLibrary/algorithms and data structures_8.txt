need three types of invariants to verify the wall-following program: "wall to left-rear", "wall to left-front", and "wall to right-front". The relationships between the robot's position and the presence of a nearby wall that must hold for each assertion to be true are illustrated in Exhibit . Shaded circles indicate points through which a wall must pass. Each robot command transforms its precondition (i.e. the assertion true before the command is executed) into its postcondition (i.e. the assertion true after its execution). Thus each of the commands 'left', 'right', and 'forward' is a predicate transformer , as suggested in Exhibit . Exhibit : Three types of invariants relate the positions of robot and wall. Algorithms and Data Structures A Global Text . Reducing a task to given primitives: programming motion Exhibit : Robot motions as predicate transformers. Algorithm programmed in the robot's language A straightforward translation from the high-level program into the robot's low-level language yields the following seven-line wall-following program: loop left; 1left while touch do 2if touch goto 3goto right; 4right endwhile; 5goto forward; 6forward forever; 7goto The robot's program optimized In designing a program it is best to follow simple, general ideas, and to decide on details in the most straightforward manner, without regard for the many alternative ways that are always available for handling details. Once a program is proven correct, and runs, then we may try to improve its efficiency, measured by time and memory requirements. This process of program transformation can often be done syntactically, that is merely by considering the definition of individual statements, not the algorithm as a whole. As an example, we derive a five-line version of the wall-following program by