type it returns a distinct type called an s-expression , written in Typed PLAI as s-expression : (read) - s-expression type in ( (- )) '( (- )) Racket has a very rich language of s-expressions (it even has notation to represent cyclic structures), but we will use only the simple fragment of it. In the typed language, an s-expression is treated distinctly from the other types, such as numbers and lists. Underneath, an s-expression is a large recursive datatype that consists of all the base printable values numbers, strings, symbols, and so on and printable collections (lists, vectors, etc.) of s-expressions. As a result, base types like numbers, symbols, and strings are both their own type and an instance of s-expression. Typing such data can be fairly problematic, as we will discuss later REF . Typed PLAI takes a simple approach. When written on their own, values like numbers are of those respective types. But when written inside a complex s-expression in particular, as created by read or quotation they have type s-expression . You have to then cast them to their native types. For instance: ' - symbol ' (define l '( )) l - s-expression '( ) (first l) . typecheck failed: (listof ' a) vs s-expression in: first (quote ( )) l first (define f (first (s-exp- list l))) f - s-expression ' This is similar to the casting that a Java programmer would have to insert. We will study casting itself later REF . Observe that the rst element of the list is still not treated by the type checker as a symbol: a list-shaped s-expression is a list of s-expressions . Thus, (symbol- string