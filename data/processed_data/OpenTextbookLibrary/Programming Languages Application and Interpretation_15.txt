features to the interpreter itself (assuming we don t want to use G del numbering). Others, such as adding more of arithmetic itself, can be done without disturbing the core language and hence its interpreter. We ll examine this next (section ). A First Taste of Desugaring We ve begun with a very spartan arithmetic language. Let s look at how we might extend it with more arithmetic operations that can nevertheless be expressed in terms of existing ones. We ll add just two, because these will suf ce to illustrate the point. Extension: Binary Subtraction First, we ll add subtraction. Because our language already has numbers, addition, and multiplication, it s easy to de ne subtraction: a b a b. Okay, that was easy! But now we should turn this into concrete code. To do so, we face a decision: where does this new subtraction operator reside? It is tempting, and perhaps seems natural, to just add one more rule to our existing Arith C datatype. Do Now! What are the negative consequences of modifying Arith C ? This creates a few problems. The rst, obvious, one is that we now have to modify all programs that process Arith C . So far that s only our interpreter, which is pretty simple, but in a more complex implementation, that could already be a concern. Second, we were trying to add new constructs that we can de ne in terms of existing ones; it feels slightly self-defeating to do this in a way that isn t modular. Third, and most subtly, there s something conceptually wrong about modifying Arith C . That s because Arith C represents our core language.