version of substitution we have doesn t scale past this language due to a subtle problem known as name capture . Fixing substitution is complex, subtle, and an exciting intellectual endeavor, but it s not the direction I want to go in here. We ll instead sidestep this problem in this book. If you re interested, however, read about the lambda calculus , which provides the tools for de ning substitution correctly.Exercise Modify your interpreter to substitute names with answers, not expressions. We ve actually stumbled on a profound distinction in programming languages. The act of evaluating arguments before substituting them in functions is called eager application, while that of deferring evaluation is called lazy and has some variations. For now, we will actually prefer the eager semantics, because this is what most mainstream languages adopt. Later REF , we will return to talking about the lazy application semantics and its implications. From Substitution to Environments Though we have a working de nition of functions, you may feel a slight unease about it. When the interpreter sees an identi er, you might have had a sense that it needs to look it up . Not only did it not look up anything, we de ned its behavior to be an error! While absolutely correct, this is also a little surprising. More importantly, we write interpreters to understand andexplain languages, and this implementation might strike you as not doing that, because it doesn t match our intuition. There s another dif culty with using substitution, which is the number of times we traverse the source program. It would be nice to have to traverse only those parts of the program that