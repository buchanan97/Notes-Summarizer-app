. Sounds and signals def make wave(self, duration , start , framerate 11025): n round(duration framerate) ts start np.arange(n) framerate ys self.evaluate(ts) return Wave(ys, ts, framerate framerate) start andduration are the start time and duration in seconds. framerate is the number of frames (samples) per second. nis the number of samples, and tsis a Num Py array of sample times. To compute the ys,make wave invokesevaluate , which is provided by Sinusoid : def evaluate(self, ts): phases PI2 self.freq ts self.offset ys self.amp self.func(phases) return ys Let's unwind this function one step at time: .self.freq is frequency in cycles per second, and each element of tsis a time in seconds, so their product is the number of cycles since the start time. .PI2is a constant that stores . Multiplying by PI2converts from cycles to phase . You can think of phase as cycles since the start time" expressed in radians. Each cycle is radians. .self.offset is the phase when tists . It has the e ect of shifting the signal left or right in time. . Ifself.func isnp.sin ornp.cos , the result is a value between and . . Multiplying by self.amp yields a signal that ranges from -self.amp to self.amp . In math notation, evaluate is written like this: y Acos( ft ) where Ais amplitude, fis frequency, tis time, and 0is the phase o set. It may seem like I wrote a lot of code to evaluate one simple expression, but as we'll see, this code provides a framework for dealing with all kinds of signals, not just sinusoids. . Exercises Exercises Before you begin these exercises, you should download the code for this book, following the instructions