process is a source of unnecessary work and errors. .The approximation of the circle by a polygon computed from vertex to vertex leads to rounding errors that accumulate. Thus the polygon may fail to close, in particular when using integer computation with its inherent large rounding error. .The procedure attempts to draw its circle on an infinite screen. Computer screens are finite, and attempted drawing beyond the screen boundary may or may not cause an error. Thus the circle ought to be clipped at the boundaries of an arbitrarily specified rectangle. Writing a good circle procedure is a demanding task for professionals. We started this discussion of desiderata and difficulties of a simple library procedure so that the reader may appreciate the thought and effort that go into building a useful programming environment. In chapter we return to this problem and present one possible goal of "the long road toward a procedure 'circle'". We now make a huge jump from the artificially small environments discussed so far to one of today's realistic programming environments for graphics Quick Draw: a graphics toolbox For the sake of concreteness, the next few sections show programs written for a specific programming environment: Mac Pascal using the Quick Draw library of graphics routines App . It is not our purpose to duplicate a manual, but only to convey the flavor of a realistic graphics package and to explain enough about Quick Draw for the reader to understand the few programs that follow. So our treatment is highly selective and biased. Concerning the circle that we attempted to program above, Quick Draw offers five procedures for drawing circles and related figures: procedure Frame Oval(r: Rect); procedure