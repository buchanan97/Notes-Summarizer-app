have options in order to optimize your code. If you have a variable that ranges from say, to 1000, there s no need to use more than a short ( bit) integer. Using a bit integer simply uses more memory. Now, you might consider extra bytes to be no big deal, but remember that we are talking about embedded controllers in some cases, not desktop systems. Some small controllers may have only a few hundred bytes of memory available for data. Even on desktop systems with gigabytes of memory, choosing the wrong size can be disastrous. For example, suppose you have a system with an analog to digital converter for audio. The CD standard sampling rate is , samples per second. Each sample is a bit value ( bytes), producing a data rate of , bytes per second. Now imagine that you need enough memory for a five minute song in stereo. That works out to nearly megabytes of memory. If you had chosen long ( bit) integers to hold these data, you d need about megabytes instead. As the values placed on an audio CD never exceed bits, it would be foolish to allocate more than bits each for the values. Data sizes are power-of- multiples of a byte though, so you can t choose to have an integer of say, bits length. It s , , or for the most part (some controllers have an upper limit of bits). In the case of float versus double, float is used where space is at a premium. It has a smaller range (size of exponent) and a lower precision (number of significant digits) than double. double is generally preferred and