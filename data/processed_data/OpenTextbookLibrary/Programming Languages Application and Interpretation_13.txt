C (l r) mult C (l r) )) You re probably tempted to jump straight to code, which you can: (define (interp a : Arith C ) : number (type-case Arith C a num C (n) n plus C (l r) ( l r) mult C (l r) ( l r) )) Do Now! Do you spot the errors? Instead, let s expand the template out a step: (define (interp a : Arith C ) : number (type-case Arith C a num C (n) n plus C (l r) (interp l) (interp r) mult C (l r) (interp l) (interp r) )) and now we can ll in the blanks: (define (interp a : Arith C ) : number (type-case Arith C a num C (n) n plus C (l r) ( (interp l) (interp r)) mult C (l r) ( (interp l) (interp r)) )) Later on REF , we re going to wish we had returned a more complex datatype than just numbers. But for now, this will do. Congratulations: you ve written your rst interpreter! I know, it s very nearly an anticlimax. But they ll get harder much harder pretty soon, I promise. Did You Notice? I just slipped something by you: Do Now! What is the meaning of addition and multiplication in this new language? That s a pretty abstract question, isn t it. Let s make it concrete. There are many kinds of addition in computer science: First of all, there s many different kinds of numbers : xed-width (e.g., 32bit) integers, signed xed-width (e.g., -bits plus a sign-bit) integers, arbitrary precision integers; in some languages, rationals; various formats of xed- and oating-point numbers;