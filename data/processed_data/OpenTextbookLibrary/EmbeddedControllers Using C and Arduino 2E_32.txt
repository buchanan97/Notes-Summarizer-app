plates). Unless you initialize an auto variable, you have no idea what its value is when you first use it. Its value happens to be whatever was in that memory location the previous time it was used. It is important to understand that this includes subsequent calls to a function (i.e., its prior value is not remembered the next time you call the function). This is because any subsequent call to a function does not have to produce the same the memory locations for these variables, anymore than you always wind up with the same plate every time you go to the cafeteria. Register variables are similar to auto types in behavior, but instead of using the usual stack method, a CPU register is used (if available). The exact implementation is CPU and compiler specific. In some case the register keyword is ignored and a simple auto type is used. CPU registers offer faster access than normal memory so register variables are used to create faster execution of critical code. Typically this includes counters or pointers that are incremented inside of loops. A declaration would like something like this: register int x; Static variables are used when you need a variable that maintains its value between function calls. So, if we need a variable that will appear the way we left it from the last call, we might use something like this: static char y; There is one important difference between auto and static types concerning initialization. If an auto variable is initialized in a function as so: char a ; Then a is set to each time the function is entered. If you do the same initialization with a