we already have. Type-checking this helps to make sure we got all the little pieces right. Once we have a de nition for lookup , we d have a full interpreter. So here s one: (define (lookup for : symbol env : Env ) : number (cond (empty? env) (error 'lookup "name not found") else (cond (symbol ? for (bind-name (first env))) (bind-val (first env)) else (lookup for (rest env)) ) )) Observe that looking up a free identi er still produces an error, but it has moved from the interpreter which is by itself unable to determine whether or not an identi er is free to lookup , which determines this based on the content of the environment. Now we have a full interpreter. You should of course test it make sure it works as you d expect. For instance, these tests pass: (test (interp (plus C (num C ) (app C 'const5 (num C ))) mt-env (list (fd C 'const5 ' (num C )))) ) (test (interp (plus C (num C ) (app C 'double (plus C (num C ) (num C )))) mt-env (list (fd C 'double 'x (plus C (id C 'x) (id C 'x))))) ) (test (interp (plus C (num C ) (app C 'quadruple (plus C (num C ) (num C )))) mt-env (list (fd C 'quadruple 'x (app C 'double (app C 'double (id C 'x)))) (fd C 'double 'x (plus C (id C 'x) (id C 'x))))) ) So we re done, right? Do Now! Spot the bug. Deferring Correctly Here s another test: (interp (app C 'f1 (num C )) mt-env (list (fd C 'f1'x (app C 'f2 (num C )))