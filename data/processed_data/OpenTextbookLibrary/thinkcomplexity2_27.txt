not already in seen , we add it, which is constant time, and then add the neighbors to the stack, which is linear in the number of neighbors. To express the run time in terms of nandm, we can add up the total number of times each node is added to seen andstack . Each node is only added to seen once, so the total number of additions is n. But nodes might be added to stack many times, depending on how many neighbors they have. If a node has kneighbors, it is added to stackktimes. Of course, if it has kneighbors, that means it is connected to kedges. So the total number of additions to stack is the total number of edges, m, doubled because we consider every edge twice. Therefore, the order of growth for this function is O(n m), which is a convenient way to say that the run time grows in proportion to either norm, whichever is bigger. If we know the relationship between nandm, we can simplify this expression. For example, in a complete graph the number of edges is n(n ) , which is in O(n2). So for a complete graph, reachable nodes is quadratic in n. Exercises The code for this chapter is in chap02.ipynb , which is a Jupyter notebook in the repository for this book. For more information about working with this code, see Section . Exercise Launch chap02.ipynb and run the code. There are a few short exercises embedded in the notebook that you might want to try. Exercise In Section we analyzed the performance of reachable nodes and classi ed it in O(n m), wherenis the number of nodes