which is to de ne b b. This expansion works with the primitives we have, and follows structural recursion. The reason we took the above detour, however, is to alert you to these problems, and warn that you might not always be so fortunate. Adding Functions to the Language Let s start turning this into a real programming language. We could add intermediate features such as conditionals, but to do almost anything interesting we re going to need functions or their moral equivalent, so let s get to it. Exercise Add conditionals to your language. You can either add boolean datatypes or, if you want to do something quicker, add a conditional that treats 0as false and everything else as true. What are the important test cases you should write? Imagine, therefore, that we re modeling a system like Dr Racket. The developer de nes functions in the de nitions window, and uses them in the interactions window. For now, let s assume all de nitions go in the de nitions window only (we ll relax this soon REF ), and all expressions in the interactions window only. Thus, running a program simply loads de nitions. Because our interpreter corresponds to the interactions window prompt, we ll therefore assume it is supplied with a set of de nitions. Asetof de nitions suggests no ordering, which means, presumably, any de nition can refer to any other. That s what I intend here, but when you are designing your own language, be sure to think about this. De ning Data Representations To keep things simple, let s just consider functions of one argument. Here are some Racket examples: (define (double x) (