f) . typecheck failed: symbol vs s-expression in: symbol- string f symbol- string f first (first (s-exp- list l)) s-exp- list whereas again, casting does the trick: (symbol- string (s-exp- symbol f)) - string " " The need to cast s-expressions is a bit of a nuisance, but some complexity is unavoidable because of what we re trying to accomplish: to convert an untyped input stream into a typed output stream through robustly typed means. Somehow we have to make explicit our assumptions about that input stream. Fortunately we will use s-expressions only in our parser, and our goal is to get away from parsing as quickly as possible ! Indeed, if anything this should be inducement to get away even quicker. Completing the Parser In principle, we can think of read as a complete parser. However, its output is generic: it represents the token structure without offering any comment on its intent. We would instead prefer to have a representation that tells us something about the intended meaningof the terms in our language, just as we wrote at the very beginning: representing addition , represents a number , and so on. To do this, we must rst introduce a datatype that captures this representation. We will separately discuss (section ) how and why we obtained this datatype, but for now let s say it s given to us: (define-type Arith C num C (n : number) plus C (l : Arith C) (r : Arith C) mult C (l : Arith C) (r : Arith C) ) We now need a function that will convert s-expressions into instances of this datatype. This is the other half of our parser: