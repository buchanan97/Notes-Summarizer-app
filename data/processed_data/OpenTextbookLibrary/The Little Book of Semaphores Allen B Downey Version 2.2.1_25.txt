can pass the barrier. This is a second example of a deadlock. Puzzle: Does this code always create a deadlock? Can you nd a n execution path through this code that does notcause a deadlock? Puzzle: Fix the problem. Basic synchronization patterns Barrier Barrier solution Finally, here is a working barrier: Barrier solution 1rendezvous 3mutex.wait() count count 5mutex.signal() 7if count n: barrier.signal() 9barrier.wait() 10barrier.signal() 12critical point The only change is another signalafter waiting at the barrier. Now as each thread passes, it signals the semaphore so that the next thre ad can pass. This pattern, a waitand asignalin rapid succession, occurs often enough that it has a name; it s called a turnstile , because it allows one thread to pass at a time, and it can be locked to bar all threads. In its initial state (zero), the turnstile is locked. The nth thread unlocks it and then all nthreads go through. It might seem dangerous to read the value of countoutside the mutex. In this case it is not a problem, but in general it is probably not a good idea. We will clean this up in a few pages, but in the meantime, you mi ght want to consider these questions: After the nth thread, what state is the turnstile in? Is there any way the barrier might be signaled more than once? Basic synchronization patterns Reusable barrier Deadlock Since only one thread at a time can pass through the mutex, and only one thread at a time can pass through the turnstile, it might seen reasonable to put the turnstile inside the mutex, like this: Bad barrier solution 1rendezvous 3mutex.wait() count count 5if count n: barrier.signal()