is nothing more than a huge array of memory slots. Some people draw them with the lowest (starting) address at the top and other people draw them with the lowest address at the bottom. Embedded Controllers Here s an example with just six bytes of memory: address address address address address address Figure , simple memory map Each address or slot represents a place we can store one byte. If we had to remember specific addresses we would be doing a lot of work. Instead, the C compiler will keep track of this for us. For example, if we declare a char named X, it might be at address . If we need to print that value, we don t have to say fetch the value at address . Instead we say; fetch the value of X and the compiler generates code to make this work out to the proper address ( ). This abstraction eases our mental burden considerably. As many variables require more than one byte, we may need to combine addresses to store a single value. For example, if we chose a short int, that needs two bytes. Suppose this variable starts at address . It will also require the use of address . When we access this variable the compiler automatically generates the code to utilize both addresses because it knows we re using a short int. Our little six byte memory map could hold char, short int, long int with short int, long int with char, or some other similar combination. It cannot hold a double as that requires bytes. Similarly, it could not hold an array of or more short int (see Chapter Three