new deferred substitutions to perform either, which means the environment does not change: plus C mult C-case :: plus C (l r) ( (interp l env fds) (interp r env fds)) mult C (l r) ( (interp l env fds) (interp r env fds)) Now let s handle identi ers. Clearly, encountering an identi er is no longer an error: this was the very motivation for this change. Instead, we must look up its value in the directory: id C-case :: id C (n) (lookup n env) Do Now! Implement lookup . Finally, application. Observe that in the substitution interpreter, the only case that caused new substitutions to occur was application. Therefore, this should be the case that constructs bindings. Let s rst extract the function de nition, just as before: app C-case :: app C (f a) (local ( define fd (get-fundef f fds) ) app C-interp ) Previously, we substituted, then interpreted. Because we have no substitution step, we can proceed with interpretation, so long as we record the deferral of substitution. app C-interp :: (interp (fd C-body fd) app C-interp-bind-in-env fds) That is, the set of function de nitions remains unchanged; we re interpreting the body of the function, as before; but we have to do it in an environment that binds the formal parameter. Let s now de ne that binding process: app C-interp-bind-in-env-take- :: (extend-env (bind (fd C-arg fd) (interp a env fds)) env) the name being bound is the formal parameter (the same name that was substituted for, before). It is bound to the result of interpreting the argument (because we ve decided on an eager application semantics). And nally, this extends the environment