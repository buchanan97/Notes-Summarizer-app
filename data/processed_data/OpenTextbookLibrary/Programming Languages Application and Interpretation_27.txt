given an identi er: id C-interp-case :: id C ( ) (error 'interp "shouldn 't get here") And that s it! Finally, to complete our interpreter, we should de ne get-fundef : (define (get-fundef n : symbol fds : (listof Fun Def C) ) : Fun Def C (cond (empty? fds) (error 'get-fundef "reference to undefined function") (cons? fds) (cond (equal? n (fd C-name (first fds))) (first fds) else (get-fundef n (rest fds)) ) )) Oh Wait, There s More! Earlier, we gave the following type to subst : ; subst : Expr C symbol Expr C - Expr C Sticking to surface syntax for brevity, suppose we apply double to( ) . This would substitute ( ) for each x, resulting in the following expression ( ( ) ( )) for interpretation. Is this necessarily what we want? When you learned algebra in school, you may have been taught to do this differently: rst reduce the argument to an answer (in this case, ), then substitute the answer for the parameter. This notion of substitution might have the following type instead: ; subst : number symbol Expr C - Expr C Careful now: we can t put raw numbers inside expressions, so we d have to constantly wrap the number in an invocation of num C . Thus, it would make sense for subst to have a helper that it invokes after wrapping the rst parameter. (In fact, our existing subst would be a perfectly good candidate: because it accepts any Expr C in the rst parameter, it will certainly work just ne with a num C .) In fact, we don t even have substitution quite right! The