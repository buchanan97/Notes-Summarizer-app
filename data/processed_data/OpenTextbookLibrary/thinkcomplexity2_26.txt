we compute the probability that a graph with parameter pis connected and store the results in ys. Figure shows the results, with a vertical line at the computed critical Chapter Graphs value,p : . As expected, the transition from to occurs near the critical value. Figure shows similar results for larger values of n. Asnincreases, the critical value gets smaller and the transition gets more abrupt. These experimental results are consistent with the analytic results Erd os and R enyi presented in their papers. Analysis of graph algorithms Earlier in this chapter I presented an algorithm for checking whether a graph is connected; in the next few chapters, we will see other graph algorithms. Along the way, we will analyze the performance of those algorithms, guring out how their run times grow as the size of the graphs increases. If you are not already familiar with analysis of algorithms, you might want to read Appendix B of Think Python, 2nd Edition , at http: thinkcomplex. com tp2 . The order of growth for graph algorithms is usually expressed as a function of n, the number of vertices (nodes), and m, the number of edges. As an example, let's analyze reachable nodes from Section : def reachable nodes(G, start): seen set() stack start while stack: node stack.pop() if node not in seen: seen.add(node) stack.extend(G.neighbors(node)) return seen Each time through the loop, we pop a node o the stack; by default, pop removes and returns the last element of a list, which is a constant time operation. Exercises Next we check whether the node is in seen , which is a set, so checking membership is constant time. If the node is