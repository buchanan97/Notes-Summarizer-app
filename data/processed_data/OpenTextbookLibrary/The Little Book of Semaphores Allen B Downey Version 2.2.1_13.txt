we rewrite the code with a temporary variable, temp. Thread A 1temp count 2count temp Thread B 1temp count 2count temp Now consider the following execution path a1 b1 b2 a2 Assuming that the initial value of xis0, what is its nal value? Because boththreadsreadthesameinitialvalue, theywritethesame value. Thevariable Introduction is only incremented once, which is probably not what the prog rammer had in mind. This kind of problem is subtle because it is not always possib le to tell, looking at a high-level program, which operations are perfo rmed in a single step and which can be interrupted. In fact, some computers provid e an increment instruction that is implemented in hardware and cannot be in terrupted. An operation that cannot be interrupted is said to be atomic. So how can we write concurrent programs if we don t know which operations are atomic? One possibility is to collect speci c informati on about each operation on each hardware platform. The drawbacks of this approa ch are obvious. The most common alternative is to make the conservative assu mption that all updates and all writes are not atomic, and to use synchron ization constraints to control concurrent access to shared variables. The most common constraint is mutual exclusion, or mutex, wh ich I mentioned in Section . Mutual exclusion guarantees that only onethread accesses a shared variable at a time, eliminating the kinds of synchro nization errors in this section. Puzzle: Suppose that threads run the following program c oncurrently (if you are not familiar with Python, the forloop runs the update times.): 1for i in range( ): temp count count temp What is the largest possible value of countafter