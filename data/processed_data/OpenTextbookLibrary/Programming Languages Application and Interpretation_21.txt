inner application of double isx; the argument in the outer application is (double x) . Thus, the argument can be any complex expression. Let s commit all this to a crisp datatype. Clearly we re extending what we had before (because we still want all of arithmetic). We ll give a new name to our datatype to signify that it s growing up: expr C :: (define-type Expr C num C (n : number) id C-def app-def plus C (l : Expr C) (r : Expr C) mult C (l : Expr C) (r : Expr C) ) Identi ers are closely related to formal parameters. When we apply a function by giving it a value for its parameter, we are in effect asking it to replace all instances of that formal parameter in the body i.e., the identi ers with the same name as the formal parameter with that value. To simplify this process of search-and-replace, we Observe that we are being coy about a few issues: what kind of value REF and when to replace REF .might as well use the same datatype to represent both. We ve already chosen symbols to represent formal parameters, so: id C-def :: id C (s : symbol) Finally, applications. They have two parts: the function s name, and its argument. We ve already agreed that the argument can be any full- edged expression (including identi ers and other applications). As for the function name, it again makes sense to use the same datatype as we did when giving the function its name in a function de nition. Thus: app-def :: app C (fun : symbol) (arg : Expr C) identifying which