are actually evaluated, and then, only when necessary. But substitution traverses everything unvisited branches of conditionals, for instance and forces the program to be traversed once for substitution and once again for interpretation. Exercise Does substitution have implications for the time complexity of evaluation? There s yet another problem with substitution, which is that it is de ned in terms of representations of the program source. Obviously, our interpreter has and needs access to the source, to interpret it. However, other implementations such as compilers have no need to store it for that purpose. It would be nice to employ a mechanism that Compilers might store versions of or information about the source for other reasons, such as reporting runtime errors, and JITs may need it to re-compile on demand.is more portable across implementation strategies. Introducing the Environment The intuition that addresses the rst concern is to have the interpreter look up an identi er in some sort of directory. The intuition that addresses the second concern is todefer the substitution. Fortunately, these converge nicely in a way that also addresses the third. The directory records the intent to substitute , without actually rewriting the program source; by recording the intent, rather than substituting immediately, we can defer substitution; and the resulting data structure, which is called an environment , avoids the need for source-to-source rewriting and maps nicely to low-level machine representations. Each name association in the environment is called a binding . Observe carefully that what we are changing is the implementation strategy for the programming language, not the language itself . Therefore, none of our datatypes for representing programs should change, nor even should the answers that