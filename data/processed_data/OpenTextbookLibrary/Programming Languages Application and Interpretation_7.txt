(to say nothing of natural languages). A Lightweight, Built-In First Half of a Parser These problems make parsing a worthy topic in its own right, and entire books, tools, and courses are devoted to it. However, from our perspective parsing is mostly a distraction, because we want to study the parts of programming languages that are not parsing. We will therefore exploit a handy feature of Racket to manage the transformation of input streams into trees: read .read is tied to the parenthetical form of the language, in that it parses fully (and hence unambiguously) parenthesized terms into a built-in tree form. For instance, running (read) on the parenthesized form of the above input ( (- )) will produce a list, whose rst element is the symbol , second element is the number , and third element is a list; this list s rst element is the symbol -, second element is the number , and third element is the number . A Convenient Shortcut As you know you need to test your programs extensively, which is hard to do when you must manually type terms in over and over again. Fortunately, as you might expect, the parenthetical syntax is integrated deeply into Racket through the mechanism of quotation. That is, expr which you saw a moment ago in the above example acts as if you had run (read) and typed expr at the prompt (and, of course, evaluates to the value the (read) would have). Types for Parsing Actually, I ve lied a little. I said that (read ) or equivalently, using quotation will produce a list, etc. That s true in regular Racket, but in Typed PLAI, the