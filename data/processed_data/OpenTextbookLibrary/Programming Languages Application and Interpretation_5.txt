provides a pattern-matcher for use when writing expressions, such as a function s body: (define (good? ma : Misspelled Animal ) : boolean (type-case Misspelled Animal ma caml (humps) ( humps ) yacc (height) ( height ) )) In the expression ( humps ) , for instance, humps is the name given to whatever value was given as the argument to the constructor caml . Finally, you should write test cases, ideally before you ve de ned your function, but also afterwards to protect against accidental changes: (test (good? ma1) t) (test (good? ma2) f) When you run the above program, the language will give you verbose output telling you both tests passed. Read the documentation to learn how to suppress most of these messages. Here s something important that is obscured above. We ve used the same name, humps (and height ), in both the datatype de nition and in the elds of the patternmatch. This is absolutely unnecessary because the two are related by position , not name. Thus, we could have as well written the function as (define (good? ma : Misspelled Animal ) : boolean (type-case Misspelled Animal ma caml (h) ( h ) yacc (h) ( h ) )) Because each his only visible in the case branch in which it is introduced, the two hs do not in fact clash. You can therefore use convention and readability to dictate your choices. In general, it makes sense to provide a long and descriptive name when de ning the datatype (because you probably won t use that name again), but shorter names in the type-case because you re likely to use use those names one or