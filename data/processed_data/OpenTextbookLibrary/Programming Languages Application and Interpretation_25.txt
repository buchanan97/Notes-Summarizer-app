on how they are used. In other languages, there is no such distinction; indeed, we will examine such languages soon REF . For now, we will take a pragmatic viewpoint. Because expressions evaluate to numbers, that means a function name could turn into a number. However, numbers cannot name functions, only symbols can. Therefore, it makes no sense to substitute in that position, and we should leave the function name unmolested irrespective of its relationship to the variable being substituted. (Thus, a function could have a parameter named xas well as refer to another function called x, and these would be kept distinct.) Now we ve made all our decisions, and we can provide the body code: subst-body :: (type-case Expr C in num C (n) in id C (s) (cond (symbol ? s for) what else in ) app C (f a) (app C f (subst what for a)) plus C (l r) (plus C (subst what for l) (subst what for r)) mult C (l r) (mult C (subst what for l) (subst what for r)) ) Exercise Observe that, whereas in the num C case the interpreter returned n, substitution returns in(i.e., the original expression, equivalent at that point to writing (num C n) . Why? The Interpreter, Resumed Phew! Now that we ve completed the de nition of substitution (or so we think), let s complete the interpreter. Substitution was a heavyweight step, but it also does much of the work involved in applying a function. It is tempting to write app C-interp-case-take- :: app C (f a) (local ( define fd (get-fundef f fds) ) (subst a (fd C-arg fd) (fd C-body fd))) Tempting, but