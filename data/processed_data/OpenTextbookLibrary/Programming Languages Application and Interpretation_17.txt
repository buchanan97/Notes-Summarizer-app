a common mistake to forget the recursive calls to desugar onland r. What happens when you forget them? Try for yourself and see. Extension: Unary Negation Now let s consider another extension, which is a little more interesting: unary negation. This forces you to do a little more work in the parser because, depending on your surface syntax, you may need to look ahead to determine whether you re in the unary or binary case. But that s not even the interesting part! There are many ways we can desugar unary negation. We can de ne it naturally as b b, or we could abstract over the desugaring of binary subtraction with this expansion: b b. Do Now! Which one do you prefer? Why? It s tempting to pick the rst expansion, because it s much simpler. Imagine we ve extended the Arith S datatype with a representation of unary negation: uminus S (e : Arith S) Now the implementation in desugar is straightforward: uminus S (e) (desugar (bminus S (num S ) e)) Let s make sure the types match up. Observe that eis a Arith S term, so it is valid to use as an argument to bminus S , and the entire term can legally be passed to desugar . It is therefore important to notdesugar ebut rather embed it directly in the generated term. This embedding of an input term in another one and recursively calling desugar is a common pattern in desugaring tools; it is called a macro (speci cally, the macro here is this de nition of uminus S ). However, there are two problems with the de nition above: . The rst is