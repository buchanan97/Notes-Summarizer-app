more times. I did just say you re unlikely to use the eld descriptors introduced in the datatype de nition, but you can. The language provides selectors to extract elds without the need for pattern-matching: e.g., caml-humps . Sometimes, it s much easier to use the selector directly rather than go through the pattern-matcher. It often isn t, as when de ning good? above, but just to be clear, let s write it without pattern-matching: (define (good? ma : Misspelled Animal ) : boolean (cond (caml? ma) ( (caml-humps ma) ) (yacc? ma) ( (yacc-height ma) ) )) Do Now! What happens if you mis-apply functions to the wrong kinds of values? For instance, what if you give the caml constructor a string? What if you send a number into each version of good? above? Everything (We Will Say) About Parsing Parsing is the act of turning an input character stream into a more structured, internal representation. A common internal representation is as a tree, which programs can recursively process. For instance, given the stream - we might want a tree representing addition whose left node represents the number and whose right node represents subtraction of 6from . Aparser is responsible for performing this transformation. Parsing is a large, complex problem that is far from solved due to the dif culties of ambiguity. For instance, an alternate parse tree for the above input expression might put subtraction at the top and addition below it. We might also want to consider whether this addition operation is commutative and hence whether the order of arguments can be switched. Everything only gets much, much worse when we get to full- edged programming languages