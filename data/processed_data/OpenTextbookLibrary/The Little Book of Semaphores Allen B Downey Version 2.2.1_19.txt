were able to gure out a solution , but if not, here is a hint. Create two semaphores, named a Arrived andb Arrived , and initialize them both to zero. As the names suggest, a Arrived indicates whether Thread A has arrived at the rendezvous, and b Arrived likewise. Basic synchronization patterns Rendezvous Rendezvous solution Here is my solution, based on the previous hint: Thread A 1statement a1 2a Arrived.signal() 3b Arrived.wait() 4statement a2 Thread B 1statement b1 2b Arrived.signal() 3a Arrived.wait() 4statement b2 While working on the previous problem, you might have tried s omething like this: Thread A 1statement a1 2b Arrived.wait() 3a Arrived.signal() 4statement a2 Thread B 1statement b1 2b Arrived.signal() 3a Arrived.wait() 4statement b2 This solution also works, although it is probably less e cie nt, since it might have to switch between A and B one time more than necessary. If A arrives rst, it waits for B. When B arrives, it wakes A and might proceed immediately to its waitin which case it blocks, allowing A to reach its signal, after which both threads can proceed. Thinkabouttheotherpossiblepathsthroughthiscodeandco nvinceyourself that in all cases neither thread can proceed until both have a rrived. Deadlock Again, while working on the previous problem, you might have tried something like this: Thread A 1statement a1 2b Arrived.wait() 3a Arrived.signal() 4statement a2 Thread B 1statement b1 2a Arrived.wait() 3b Arrived.signal() 4statement b2 If so, I hope you rejected it quickly, because it has a serious problem. Assuming that A arrives rst, it will block at its wait. When B arrives, it will also block, since A wasn t able to signal a Arrived . At this point, neither thread can