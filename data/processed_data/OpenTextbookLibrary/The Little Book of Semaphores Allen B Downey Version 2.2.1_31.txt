imagine that threads represent ballroom dance rs and that two kinds of dancers, leaders and followers, wait in two queues b efore entering the dance oor. When a leader arrives, it checks to see if there is a follower waiting. If so, they can both proceed. Otherwise it waits. Similarly, when a follower arrives, it checks for a leader an d either proceeds or waits, accordingly. Puzzle: write code for leaders and followers that enforces t hese constraints. Basic synchronization patterns Queue Queue hint Here are the variables I used in my solution: Queue hint 1leader Queue Semaphore( ) 2follower Queue Semaphore( ) leader Queue is the queue where leaders wait and follower Queue is the queue where followers wait. Basic synchronization patterns Queue Queue solution Here is the code for leaders: Queue solution (leaders) 1follower Queue.signal() 2leader Queue.wait() 3dance() And here is the code for followers: Queue solution (followers) 1leader Queue.signal() 2follower Queue.wait() 3dance() This solution is about as simple as it gets; it is just a Rendez vous. Each leader signals exactly one follower, and each follower sign als one leader, so it is guaranteed that leaders and followers are allowed to proc eed in pairs. But whether they actually proceed in pairs is not clear. It is pos sible for any number of threads to accumulate before executing dance, and so it is possible for any number of leaders to dancebefore any followers do. Depending on the semantics ofdance, that behavior may or may not be problematic. Tomakethingsmoreinteresting, let saddtheadditionalco nstraintthateach leader can invoke danceconcurrently with only one follower, and vice versa. In other words, you got to dance with the one that brought you3. Puzzle: write