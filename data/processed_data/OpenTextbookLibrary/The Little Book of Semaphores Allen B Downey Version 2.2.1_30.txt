gnal for each thread. When the nth thread passes the turnstile, it takes the last token and leaves the turnstile locked again. The same thing happens at the second turnstile, which is unlo cked when the last thread goes through the mutex. Thanks to Matt Tesch for this solution! Basic synchronization patterns Barrier objects It is natural to encapsulate a barrier in an object. I will bor row the Python syntax for de ning a class: Barrier class 1class Barrier: def init (self, n): self.n n self.count self.mutex Semaphore( ) self.turnstile Semaphore( ) self.turnstile2 Semaphore( ) def phase1(self): self.mutex.wait() self.count if self.count self.n: self.turnstile.signal(self.n) self.mutex.signal() self.turnstile.wait() def phase2(self): self.mutex.wait() self.count - if self.count : self.turnstile2.signal(self.n) self.mutex.signal() self.turnstile2.wait() def wait(self): self.phase1() self.phase2() Theinitmethod runs when we create a new Barrier object, and initializes the instance variables. The parameter nis the number of threads that have to invoke waitbefore the Barrier opens. The variable selfrefers to the object the method is operating on. Since each barrier object has its own mutex and turnstiles, self.mutex refers to the speci c mutex of the current object. Here is an example that creates a Barrier object and waits on it: Barrier interface 1barrier Barrier(n) initialize a new barrier 2barrier.wait() wait at a barrier Queue Optionally, code that uses a barrier can call phase1andphase2separately, if there is something else that should be done in between. Queue Semaphores can also be used to represent a queue. In this case , the initial value is , and usually the code is written so that it is not possible to signal unless there is a thread waiting, so the value of the semaphore is nev er positive. For example,