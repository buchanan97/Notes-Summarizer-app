autores julio cesar ponce gallegos aurora torres soto fátima sayuri quezada aguilera antonio silva sprock ember ubeimar martínez flor ana casali eliana scheihing yván jesús túpac valdivia ma dolores torres soto francisco javier ornelas zapata josé alberto hernández crizpín zavala nodari vakhnia oswaldo pedreñointeligencia artiﬁcial ed iniciativa latinoamericana libros texto abiertos latin pag primera edición marzo iniciativa latinoamericana libros texto abiertos latin http los textos este libro se distribuyen bajo una licencia unported cc http esta licencia permite compartir copiar y redistribuir el material en cualquier medio o formato adaptar remezclar transformar y crear partir del material para cualquier ﬁnalidad siempre que se cumplan la siguientes condiciones reconocimiento debe reconocer adecuadamente la autoría proporcionar enlace la licencia e indicar si se han realizado cambios puede hacerlo cualquier manera razonable pero una manera que sugiera que tiene el apoyo del licenciador o lo recibe por el uso que hace compartirigual si remezcla transforma o crea partir del material berá difundir sus contribuciones bajo la misma licencia que el original la ﬁguras e ilustraciones que aparecen en el libro son autoría los respectivos autores aquellas ﬁguras o ilustraciones que son realizadas por los autores se coloca la referencia respectiva este texto forma parte la iniciativa latinoamericana libros texto abiertos latin proyecto ﬁnanciado por la unión europea en el marco su programa alfa iii europeaid el proyecto latin está conformado por escuela superior politécnica del litoral ecuador espol universidad autónoma aguascalientes méxico uaa dad católica san pablo perú ucsp universidade presbiteriana mackenzie sil upm universidad la república uruguay udelar universidad nacional rosario argentina ur universidad central venezuela venezuela ucv sidadaustraldechile chile uach universidaddelcauca colombia unicauca katholieke universiteit leuven bélgica kul universidad alcalá españa uah université paul sabatier francia ups general y antecedentes la inteligencia artiﬁcial objetivo resumen del capítulo conocimientos previos introduccion clasiﬁcación la inteligencia artiﬁcial historia la inteligencia artiﬁcial modelos inteligencia sistemas que piensan como humanos sistemas que actúan como humanos sistemas que piensan racionalmente sistemas actuantes racionales el test turing aplicaciones y herramientas derivadas la inteligencia artiﬁcial lenguajes programación aplicaciones y sistemas expertos ambientes desarrollo area la inteligencia artiﬁcial actividades aprendizaje material referencias consultar opcional lecturas adicionales referencias del problema introduccion clasiﬁcación los problemas plantear problema planteamiento del problema para ser resuelto mediante la búsqueda bibliografía del conocimiento introduccion características deseables los formalismos sentación conocimiento tipos conocimiento técnicas representación conocimientos formalismos basados en conceptos formalismos basados en relaciones formalismos basados en acciones referencias inteligentes introducción qué e agente modelos abstractos agentes arquitecturas agentes distintas arquitecturas agentes agentes razonamiento procedural pr lenguaje para desarrollar agentes introducción jason arquitectura agente en agentspeak caso estudio sistemas multiagentes características los sistemas multiagentes comunicación coordinación bibliografía al aprendizaje concepto aprendizaje aprendizaje supervisado primer ejemplo la regresión lineal procedimiento entrenamiento el problema la clasiﬁcación comparación los do enfoques bibliografía y heurísticas deﬁniciones en optimización funciones único objetivo optimización clásica convexidad técnicas clásicas optimización optimización lineal método simplex optimización lineal método steepest descent método gradiente conjugado técnicas heurísticas optimización heurísticas búsqueda tabú simulated annealing hill climbing referencias evolutivos optimizacion y heurísticas optimización deﬁniciones en optimización funciones único objetivo optimización clásica técnicas clásicas optimización técnicas heurísticas optimización conceptos básicos algoritmo evolutivo algoritmos evolutivos conceptos usados en computación evolutiva paradigmas la computación evolutiva algoritmo genético clásico introducción deﬁnición algoritmos genéticos componentes algoritmo genético algoritmo genético canónico función evaluación estrategias selección operadores genéticos ajustes la aptitud ajustes la selección computación evolutiva en optimización numérica uso codiﬁcación binaria o real algoritmos evolutivos codiﬁcación real problemas restricciones restricciones lineales genocop iii computación evolutiva en optimización combinatoria algoritmos evolutivos discretos algoritmos evolutivos orden problemas optimización combinatoria traveling salesman problem tsp otros algoritmos búsqueda eda scatter search pseudocódigo del algoritmo umda ejemplo del uso del umda en el problema del máximo número unos otros algoritmos estimación la distribución actividades aprendizaje lecturas adicionales referencias bioinspirados introducción swarm intelligence optimización colonias hormigas ant colony optimization aco optimización por cumulo partículas particle swarm optimization pso conclusión cuestionario colonias hormigas bibliografía en paralelo mediante uso gpus objetivo resumen del capítulo conocimientos previos introducción la gpus y cuda antecedentes históricos la gpu s fundamentos teoricos cuda compute uniﬁed device architecture jerarquía hilo paralelismo basado en datos metodología caso práctico análisis requerimientos el problema del agente viajero áreas aplicación ant colony análisis del algoritmo colonia hormigas implementación del algoritmo colonia hormigas sobre gpu s identiﬁcación procesos paralelizables en aco especificación la interfaz en términos patrones interacción especificación la interfaz en términos patrones software ejercicios resueltos ejercicios resolver conclusiones bibliografia dedicatoria agradecemos toda la persona involucradas en la escritura del libro asi como sus instituciones por su apoyo al proyecto prólogo actualmente la inteligencia artiﬁcial e area la ciencia gran interes por ser area multidiciplinaria donde se realizan sistemas que tratan hacer tareas y resolber problemas como lo hace humano asi mismo se trata simular manera artiﬁcial la formas del pensamiento y como trabaja el cerebro para tomar desiciones aunque en la realidad aun se podido realizar todo lo que la persona sueñan al conocer esta area o al ver lo que se muestra en la ciencia ﬁccion e area que poco poco va ganando terreno al estar presente en muchas aplicaciones aparatos dispositivos que utilizamos manera cotidiana utilizará el libro este libro va dirigido los estudiantes profesores y profesionales que tienen algun interes o relación la inteligencia artiﬁcial el objetivo que pueda ser utilizado como libro texto que apoye conocer los fundamentos y aplicaciones que sirvan para la generación sistemas inteligentes objetivos del libro introducir al lector al area la inteligencia artiﬁcial y algunas desus rama conocimiento dandole al usuario una vision general del area y algunas la rama y aplicaciones existentes organización del libro este se encuentra dividido en secciones o capitulos donde cada uno estos da una introduccion al contenido del mismo menciona los antecedentes necesarios y hace refenecia la revision bibliograﬁca abstract este libro e una introducción al area la inteligencia artiﬁcial y presenta algunas la aplicaciones que puede tener en la vida real en diversos campos aplicación el libro esta compuesto ocho capítulos los cuales abarcan los antededentes algunos conceptos importantes para la resolución problemas como e la representación conocimiento el planteamiento los problemas asimismo se menciona la teoría agentes por lado y por otro lo que e el aprendizaje computacional otra area que se aborta e la computación evolutivo y los algoritmos bioinspirados para la resolución problemas dandole enfasis los problemas optimizacion por ultimo se menciona una nueva tendencia en el area la ciencias computacionales como e el uso la gpus para trabajar una manera ma rapida al realizar el procesamiento en abreviaturas algoritmos evolutivos ea algoritmos genéticos ag ingeniería software orientada agentes aose inteligencia artiﬁcial ia solucionador general problemas gps optimización colonias hormigas aco optimización cúmulo particulas pso problema del agente viajero tsp sistemas ma glosario inteligencia artiﬁcial rama la ciencias computacionales preocupada por la tomatización la conducta inteligente agente inteligente ente capaz persivir su entorno trave sensores y actuar sobre él algoritmos son algoritmos basados en la evolución que puede darse nivel individuo una población manera biológica o artiﬁcial julio cesar ponce gallegos y aurora torres soto universidad autónoma aguascalientes méxico objetivo este capítulo tiene como objetivo establecer punto partida para el estudio la inteligencia artiﬁcial mediante el conocimiento sus orígenes y descripción general el lector hará una revisión histórica los personajes y la herramientas que sentaron la base la inteligencia artiﬁcial tal como la conocemos el día hoy el conocimiento que adquiera el estudiante podrá ser autoevaluado mediante la ción cuestionario al ﬁnal del capítulo resumen del capítulo lo largo este capítulo se hará una descripción los orígenes e historia la inteligencia artiﬁcial así como algunas contribuciones que esta área ha heredado otras disciplinas también se discutirán algunas la deﬁniciones más comúnmente aceptadas y los diferentes modelos que se emplean para describirla también se hará una descripción del conocido como test turing que por mucho tiempo se consideró como la prueba que validaría forma deﬁnitiva la existencia máquinas inteligentes después haber revisado la principales aplicaciones y herramientas derivadas la inteligencia artiﬁcial en la que se discuten grandes rasgos los lenguajes ción desarrollados algunos sistemas expertos y muy brevemente lo que se entiende por shell se hará una revisión los diferentes tópicos la inteligencia artiﬁcial conocimientos previos el alumno debe contar conocimientos razonamiento lógico programación temáticas estos conocimientos son la base para el desarrollo modelos matemáticos que permiten llegar la solución problema así como la modelación sistemas que resuelvan problemas como si lo hiciera introducción y antecedentes la inteligencia artiﬁcial introduccion la inteligencia artiﬁcial ia e una la rama la ciencias la computación que más interés ha despertado en la actualidad debido su enorme campo aplicación la búsqueda mecanismos que no ayuden comprender la inteligencia y realizar modelos y simulaciones estos e algo que ha motivado muchos cientíﬁcos elegir esta área investigación elorigeninmediatodelconceptoydeloscriteriosdedesarrollodela ia seremontaala intuición del genio matemático inglés alan turing y el apelativo inteligencia artiﬁcial se debe mccarthy quien organizo una conferencia en el darmouth college estados unidos para discutir la posibilidad construir máquinas inteligentes esta reunión asistieron cientíﬁcos investigadores conocida reputación en el área la ciencias computacionales como marvin minsky nathaniel rochester claude shannon herbert simon y allen newell como resultado esta reunión se establecieron los primeros lineamientos la hoy conocida como inteligencia artiﬁcizal aunque anteriormente ya existian algunos trabajos relacionados desde su origen la ia tuvo que lidiar el conﬂicto que existía una deﬁnición clara y única inteligencia así e que e sorprender que aún en la actualidad exista una deﬁnición única ella así como la psicología ha identiﬁcado diferentes tipos inteligencia humana emocional interpersonal musical lingüística ca espacial la distintas deﬁniciones la inteligencia artiﬁcial hacen énfasis en diferentes aspectos aunque existen similitude entre ellas continuación se presentan algunas la deﬁniciones iniciales esta área estudio la computación que observa que una maquina sea capaz percibir razonar y actuar winston ciencia la obtención máquinas que logren hacer cosas que requerirían ligencia si la hiciesen los humanos minsky nuevo esfuerzo excitante que logre que la computadora piense máquinas mentes en el sentido completo y literal haugeland rama la ciencia computacional preocupada por la automatización la ducta inteligente luger stubbleﬁeld maquina inteligente e la que realiza el proceso analizar organizar y tir los datos en conocimiento donde el conocimiento del sistema e información estructurada adquirida y aplicada para reducir la ignorancia o la incertidumbre sobre una tarea espesiﬁca realizar por esta pajares y santos originalmente la inteligencia artiﬁcial se construyó en base conocimientos y teorías existentes en otras áreas del conocimiento algunas la principales fuentes piración y conocimientos que nutrieron esta área son la ciencias la computación la ﬁlosofía la lingüística la matemáticas y la psicología cada una estas ciencias contribuyó solamente los conocimientos desarrollados en ellas sino sus rramientas y experiencias también contribuyendo así la gestación y desarrollo esta nueva área del conocimiento los ﬁlósofos como sócrates platón aristóteles leibniz desde el año ac sentaron la base para la inteligencia artiﬁcial al concebir la mente como una máquina que funciona partir del conocimiento codiﬁcado en lenguaje interno y al considerar que el pensamiento servía para determinar cuál era la acción correcta que había que emprender por ejemplo aristóteles quien e considerado como el primero introduccion describir forma estructurada la forma como el ser humano produce conclusiones racionales partir grupo premisas contribuyó conjunto reglas conocidas como silogismos que actualmente son la base uno los enfoques la inteligencia artiﬁcial sin embargo la ﬁlosofía e la única ciencia que ha heredado sus frutos esta área pues otras contribuciones menos importantes son la siguientes la matemáticas proveyeron la herramientas para manipular la aseveraciones teza lógica así como aquellas en la que existe incertidumbre tipo probabilista el cálculo por su lado bridó la herramientas que no permiten la modelación te tipos fenómenos y fueron también la matemáticas quienes prepararon el terreno para el manejo del razonamiento algoritmos la psicología ha reforzado la idea que los humanos y otros animales pueden ser considerados como máquinas para el procesamiento información psicólogos como piaget y craik deﬁnieron teorías como el conductismo psicología cognitiva la ciencias la computación muy poco ante que la inteligencia artiﬁcial misma la teorías la ia encuentran medio para su implementación artefactos y modelado cognitivo través la computadoras los programas inteligencia ﬁcial por general son extensos y funcionarían sin los grandes avances velocidad y memoria aportados por la industria cómputo la lingüística se desarrolló en paralelo la ia y sirve base para la representación del conocimiento chomsky la lingüística moderna nació casi la par que la gencia artiﬁcial y ambas áreas han ido madurando junta al grado que existe área híbrida conocida como lingüística computacional o procesamiento del lenguaje natural los lingüistas han demostrado que el problema del entendimiento del lenguaje e mucho más complicado lo que se había supuesto en la economía como una área experta en la toma decisiones debido que éstas implican la pérdida o ganancia del rendimiento brindó la ia una serie teorías teoría la decisión combina la teoría la probabilidad y la teoría la utilidad teoría juegos para pequeñas economías procesos decisión markov para procesos secuenciales entre otras que la posibilitaron para la toma buenas decisiones finalmente la neurociencia ha contribuido la ia los conocimientos recabados hasta la fecha sobre la forma como el cerebro procesa la información clasiﬁcación la inteligencia artiﬁcial la escuela clásica dentro la ia utiliza representaciones simbólicas basadas en número ﬁnito primitivas y reglas para la manipulación símbolos por ejemplo redes semánticas lógica predicados los cuales fueron y siguen siendo parte central dichos sistemas otro tipo representación e el llamado el cual utiliza representaciones numéricas o del conocimiento aunque la mayor parte los libros ia hebb minsky papert sólo enfatizan el trabajo realizado por rosenblatt y widrow en la década los s redes neuronales en este tipo introducción y antecedentes la inteligencia artiﬁcial el enfoque la ia se caracteriza por crear sistemas capacidad aprendizaje éste se puede obtener nivel individuo imitando el cerebro redes neuronales nivel especie imitando la evolución hasta hace poco era común hablar algoritmos genéticos ag en general en vez identiﬁcar diferentes tipos deae yaqueelrestodelosalgoritmossepuedeninterpretarcomovariacionesomejoras los ag figura enfoques clasiﬁcación la inteligencia artiﬁcial en la actualidad la ia empieza extender sus áreas investigación en diversas recciones y trata integrar diferentes métodos en sistemas gran escala en su afán por explotar al máximo la ventajas cada una estas en una gran cantidad áreas del conocimiento ya que se realizan aplicaciones en una gran cantidad are del conocimiento como son la medicina biología ingeniera educación en la actualidad existen nuevas técnicas que utilizan el enfoque como son los algoritmos optimización colonias hormigas sistema inmune cúmulo partículas entre otros los cuales están inspirados en los comportamientos emergentes la naturaleza historia la inteligencia artiﬁcial desde tiempos inmemoriales el hombre ha buscado la materialización del deseo crear seres semejantes él pasando por la creación artefactos aspecto movimientos y hasta comportamiento similar al que presentamos los seres humanos el ruso isaac asimov escritor e historiador narraba sobre objetos y situaciones que en su tiempo eran sin embargo el paso del tiempo muchas ellas se han ido volviendo realidad asimov en su libro runaround describió lo que el día hoy son la tres leyes la robótica su obra literaria serviria como motivación para que los cientíﬁcos e ingenieros trataran hacerla realidad en los años cuando se logra realizar sistema que tuvo cierto éxito se llamó el perceptrón rossenblatt este era sistema visual reconocimiento patrones en el cual se aunaron esfuerzos para que se pudieran resolver una gama amplia problemas pero estas energías se diluyeron enseguida aproximadamente enese tiempo el matematicoinglés alanturing propuso unapruebaconlaﬁnalidaddedemostrarlaexistenciade inteligencia enundispositivo biológico esta prueba conocida como test turing se fundamenta en la introduccion que si una máquina se comporta en todos aspectos como inteligente entonces debe ser inteligente alan turing como consecuencia esta prueba muchos los esfuerzos los investigadores en ese tiempo se enfocaron en la redacción sistemas inteligencia artiﬁcial lingüísticos lo que marcó el nacimiento los conocidos como chatbots robot plática pesar que ya se habían realizado investigación sobre el diseño y la capacidades la entidades biológicas el trabajo alan turing concentró el interés la comunidad cientíﬁca en el desarrollo la máquinas inteligentes do la contribuciones más importantes alan turing son el diseño la primera computadoracapaz jugar al ajedrez y el establecimiento la naturaleza simbólica la computación itam posteriormente en alan newell y herbert simon que trabajaban en la ción teoremas y el ajedrez por ordenador logran crear programa llamado gps general problem solver este era sistema donde el usuario deﬁnía entorno en función una serie objetos y los operadores que se podían aplicar sobre ellos este programa fue redactado mediante el uso ipl information processing languaje y e considerado como el primer programa en el que se separó la información relacionada el problema la estrategia empleada para darle solución el gps se basó en el trabajo previamente desarrollado sus autores sobre máquinas lógicas y aunque fue capaz resolver problemas como el la torres hanoi pudo resolver problemas ni del mundo real ni médicos ni tomar decisiones importantes el gps manejaba reglas heurísticas que la conducían hasta el destino deseado mediante el método del ensayo y el error newell y simon varios años más tarde en los años equipo investigadores dirigido por edward feigenbaum comenzaría elaborar proyecto para resolver problemas la vida cotidiana problemas más concretos dando origen lo que se conocería como los sistemas expertos en mccarthy desarrolló lenguaje programación simbolica cuando estaba trabajando en el mit dicho lenguaje e utlilizado aún en la actualidad y e conocido como lisp el nombre lisp deriva list processing procesamiento listas la listas encadenadas son una la estructuras datos importantes del lisp en el año joseph weizenbaum construyo el primer programa interactivo el cual consistia en que usuario podium sostener una conversación en ingles una tadora utilizando una comunicación por escrito este sistema fue denominado eliza el primer sistema experto fue el denominado dendral intérprete espectrograma masa construido en pero el más inﬂuyente resultaría ser el mycin el mycin era capaz diagnosticar trastornos en la sangre y recetar la correspondiente medicación todo logro en aquella época que incluso fueron utilizados en hospitales como el puﬀ variante mycin uso común en el paciﬁc medical center san francisco eeuu ya en los años se desarrollaron lenguajes especiales para utilizar la inteligencia artiﬁcial tale como el lisp o el prolog e en esta época cuando se desarrollan sistemas expertos más reﬁnados como por ejemplo el eurisko este programa fecciona su propio cuerpo reglas heurísticas automáticamente por inducción también podemos destacar la importante intervención arthur samuel que desarrollo programa juego dama capaz aprender su propia experiencia selfridge que estudiaba el reconocimiento visual por computadora apartirdeestegrupoinicial seformarondosgrandes escuelas introducción y antecedentes la inteligencia artiﬁcial lideraron el equipo la universidad proponiéndose desarrollar modelos comportamiento humano aparatos cuya estructura se pareciese lo más posible la del cerebro lo que derivó en la postura conexionista y en la redes neuronales artiﬁciales mccarthy y minsky formaron otro equipo en el instituto tecnológico massachusett mit centrándose más en que los productos del procesamiento tengan el carácter inteligente sinpreocuparseporqueelfuncionamientoolaestructuradeloscomponentes sean parecidas los del ser humano ambo enfoques sin embargo persiguen los mismos objetivos prioritarios la entender la inteligencia natural humana y usar máquinas inteligentes para adquirir conocimientos y resolver problemas considerados como intelectualmente difíciles la historia la ia ha sido testigo ciclos éxito injustiﬁcado optimismo y la consecuente desaparición entusiasmo y apoyos ﬁnancieros también han habido ciclos caracterizados por la introducción nuevos y creativos enfoques y sistemático perfeccionamiento los mejores por sus implicaciones áreas como la medicina psiclogía biología ética y ﬁlosofía entre otras esta rama del conocimiento ha tenido que lidiar fuertes grupos oponentes y críticas desde sus orígenes sin embargo siempre existió grupo persona interesadas en el área lo que permitio que se consolidara como area del conocimiento gran interes para la investigación cientíﬁca modelos inteligencia existeunaclasiﬁcacióndelosmodelosdeinteligenciaartiﬁcialquesebasaenelobjetivo y la forma en que trabaja el sistema esta clasiﬁcación manera inicial se veía como clases independientes sin embargo en la actualidad los sistemas mezclan características ellas sistemas que piensan como humanos el modelo e el funcionamiento la mente humana se intenta establecer una teoría sobre el funcionamiento la mente experimentación psicológica partir la teoría se pueden establecer modelos computacionales inﬂuencia la ciencias general problem solver newell simon se preocupaban sobre cómo obtener la respuesta correcta sino sobre por qué los sistemas llegaban dar la respuestas que daban en los sistemas cognitivos la mayoría la investigaciones son computadoras sino humanos y animales sistemas que actúan como humanos el modelo e el hombre el objetivo e construir sistema que pase por humano prueba turing si sistema la pasa e inteligente capacidades necesarias procesamiento del lenguaje natural representación del nocimiento razonamiento introduccion figura modelos inteligencia pasar la prueba e el objetivo primordial la ia la interacción programas persona hace que sea importante que éstos puedan actuar como humanos sistemas que piensan racionalmente la leyes del pensamiento racional se fundamentan en la lógica silogismos le la lógica formal está en la base los programas inteligentes logicismo se presentan do obstáculos e muy difícil formalizar el conocimiento hay gran salto entre la capacidad teórica la lógica y su realización práctica silogismos aristóteles lógica como base del esfuerzo lógica predicados sistemas actuantes racionales actuar racionalmente signiﬁca conseguir unos objetivos dada unas creencias el paradigma e el agente racional que se aplica por ejemplo muchos sistemas introducción y antecedentes la inteligencia artiﬁcial agente percibe y actúa siempre teniendo en cuenta el entorno en el que está situado la capacidades necesarias percepción procesamiento del lenguaje natural representación del conocimiento razonamiento aprendizaje automático visión la actuación general y centrada en el modelo humano el test turing la prueba turing alan turing intenta ofrecer una deﬁnición inteligencia artiﬁcial que se pueda evaluar para que ser o máquina se considere inteligente debe lograr engañar evaluador que este ser o máquina se trata humano evaluando toda la actividades tipo cognoscitivo que puede realizar el ser humano si el diálogo que ocurra y el número errores en la solución dada se acerca al número errores ocurridos en la comunicación ser humano se podrá estimar que estamos ante una máquina inteligente figura test turing una persona debe establecer si sostuvo una charla una máquina o otra persona imagen tomada henderson introduccion hoy por hoy el trabajo que entraña programar una computadora para pasar la prueba e considerable la computadora debería se capaz lo siguiente procesarunlenguajenatural paraasípoderestablecercomunicaciónsatisfactoria sea en español inglés o en cualquier otro idioma humano representar el conocimiento para guardar toda la información que se le haya dado ante o durante el interrogatorio utilización base datos para receptar preguntas y luego almacenarlas razonarautomáticamente utilizalainformaciónguardadaalresponderpreguntas y obtener nuevas conclusiones o tomar decisiones autoaprendizaje la máquina el propósito adaptarse nuevas tancias el autoaprendizaje conlleva la autoevaluación para aprobar la prueba total turing e necesario que la computadora esté dotada vista capacidad percibir el objeto que se encuentra en frente suyo robótica capacidad para mover el objeto que ha sido percibido aplicaciones y herramientas derivadas la inteligencia artiﬁcial lo largo la historia la inteligencia artiﬁcial sean ido desarrollando diferentes herramientas y aplicaciones entre la que podemos mencionar la siguientes lenguajes programación aplicaciones y sistemas expertos ambientes desarrollo shell lenguajes programación unlenguajedeprogramaciónesunlenguajeartiﬁcialempleadoparadictarinstrucciones una computadora y aunque e factible hacer uso cualquier lenguaje computacional para la producción herramientas inteligencia artiﬁcial se han desarrollado mientas cuyo propósito especíﬁco e el desarrollo sistemas dotados inteligencia artiﬁcial algunos los lenguajes más notable son e considerado como el primer lenguaje programación orientado la ción problemas la inteligencia artiﬁcial el ipl e el lenguaje programación empleado por newell y simon para la construcción del gps general solver problem newell y simon este lenguaje programación fue desarrollado en el año por herbert simon el físico allen newell y shaw año más tarde estos tres cientíﬁcos desarrollaron lo que sería el antecesor del gps llamado logic theorist el cual era capaz demostrar una gran variedad teoremas matemáticos este ma se considera como el primer programa creado la intención imitar la forma como el ser humano resuelve problemas lisp su nombre se deriva la siglas list processor este lenguaje ción e uno los lenguajes más antiguos que continúa siendo empleado fue especiﬁcado por john mccarthy y sus colaboradores en el instituto tecnológico massachusetts en entre otras la aportaciones este lenguaje se puede mencionar la troducción la estructuras datos árbol la listas encadenadas son una introducción y antecedentes la inteligencia artiﬁcial figura allen newell figura herbert simon estructuras datos importantes del lisp y el código fuente del lisp en sí mismo está compuesto listas como resultado los programas lisp pueden manipular el código fuente como una estructura datos dando lugar los macro sistemas que permiten los programadores crear una nueva sintaxis lenguajes programación dominio especíﬁco empotrados en el lisp el lisp fue el primer lenguaje para procesamiento simbólico figura john mccarthy prolog este lenguaje programación debe su nombre la siglas programming logic prolog diferencia otros lenguajes el prolog e lenguaje uso general su uso e exclusivo para la solución problemas relacionados el cálculo predicados pues alain coulmeauer y philippe roussell estaban interesados en desarrollar una herramienta para realizar deducciones partir texto la primera descripción detallada este lenguaje fue en como manual para el intérprete prolog marseille roussel recientemente en los autores del lenguaje escribieron artículo titulado el nacimiento prolog en el que se muestra desde una amplia perspectiva el nacimiento este lenguaje colmenauer roussel oﬃcial production e lenguaje para ingeniería tiva que soporta la representación del conocimiento en forma reglas aunque menos conocido que los otros lenguajes mencionados este lenguaje programación fue el introduccion figura philippe roussel figura alain colmenauer mero empleado éxito en el desarrollo sistemas expertos la familia lenguajes ops oﬁcial productio fue desarrollada ﬁnales la década por el charles forgy el algoritmo inmerso en este lenguaje programación e conocido como algoritmo rete que e la base muchos sistas actuales este algoritmo fue presentado como resultado su tesis doctoral en forgy figura dr charles forgy creador la familida lenguajes ops small talk e el resultado una investigación para la creación sistema orientado la educación el objetivo era crear sistema que permitiese expandir la creatividad sus usuarios proporcionando entorno para la experimentación ción e investigación e lenguaje orientado al trabajo objetos lidereado por alan kay quien tenía el objetivo crear una computadora personal en toda la extensión la palabra el nacimiento del lenguaje se ubica la tesis doctoral kay como estudiante la universidad utah en kay este lenguaje solamente introdujo entorno desarrollo gràﬁco y amigable sino que introdujo también el concepto objetos cambiando los paradigmas mación originales aunque todo los programacdores compartimos ciertas costumbres y pasos generales para el desarrollo aplicaciones el manejo smalltalk e una riencia completamente personal y cada individuo conﬁgura el ambiente y hace uso la herramientas manera muy diferente este lenguaje rompe el ciclo cambiándolo por proceso interactivo y creativo el propósito del proyecto smalltalk e proveer soporte computacional al espíritu introducción y antecedentes la inteligencia artiﬁcial figura alan kay pionero en el desarrollo la programación orientada objetos tivo que anida en cada persona la idea utilizadas en el desarrollo smalltalk son la base la programación orientada objetos poo actual que ésta fue popularizada varios años después smalltalk también fue el pionero en el desarrollo la interface gràﬁcas usuario gui actuales algunas la versiones actuales smalltalk en la que interviene kay son los yectos código abierto squeak y croquet logo seymour papert matemático y educador sudafricano que estuvo trabajando el prominente educador jean piaget en la universidad ginebra se mudó los estados unidos norteamérica donde conoció marvin minsky uno los cientíﬁcos más comprometidos el desarrollo la inteligencia artiﬁcial en ese momento y quien el laboratorio inteligencia artiﬁcial del mit como fruto del trabajo papert en colaboración bolt beranek y newman liderados por wallace feurzeig se creó la primera versión logo en este lenguaje programación esta basado en lisp y ha implementado muchas la idea del conocido como construccionismo debido su facilidad aprendizaje este lenguaje programación e una la herramientas preferidas para el trabajo niños y jóvenes figura saymour papert parte del equipo desarrollo del lenguaje acuerdo harold abelson logo e el nombre una ﬁlosofía educación y una familia en continuum evolución lenguajes programación que contribuye su realización uno los objetivos este lenguaje fue el proveer una herramienta para la interacción los seres humanos y la computadoras aplicaciones y sistemas expertos desde su nacimiento la inteligencia artiﬁal ha vivido diferentes etapas algunas motivación y abundancia fondos para su investigación y otras poca introduccion sobre sus logros sin embargo cuando parece que camino se cierra se abren muchos otros para seguir dando frutos continuación se comentan algunas la aplicaciones más conocidas y naturalmente se discuten también los más prominentes los primeros sistemas expertos desarrollados pues ellos la inteligencia artiﬁcial tuvo renacimiento cuando más parecía necesitarlo hecho los sistemas expertos son actualmente considerados como uno los productos típicos la inteligencia artiﬁcial algunas la primeras investigaciones exitosas se realizaron en el área del lenguaje ejemplo reconocimiento mundial e el programa conocido como eliza llado por el profesor joseph weizenbaum del instituto tecnología massachusetts entre y eliza captó la atención tanto detractores como defensores la inteligencia artiﬁcial pues fue uno los primeros programas que procesaban guaje natural weizenbaum tenía el objetivo crear programa que mantuviera una conversación texto coherente ser humano este célebre programa simula al psicólogo carl rogers quien fue partícipe en el desarrollo la terapia centrada en la persona weizembaum también e el autor del libro computer power human reason el poder la computadoras y la razón humana en el que expone algunas sus inquietude respecto la inteligencia artiﬁcial pues pesar ser área enormes oportunidades también podría ser empleada manera que se perdieran algunas libertades civiles figura joseph otrasáreasenlasqueseprodujeronaplicacionesdeenormeéxito yqueestablecieronlos principios para el almacenamiento y manipulación la base del conocimiento los sistemas expertos fueron la ciencias naturales sistema experto e una aplicación informática que soluciona problemas complicados que otra manera exigirían mente la pericia humana los sistemas expertos simulan el proceso razonamiento humanos mediante la aplicación conocimiento e inferencia uno los primeros sistemas expertos conocido como dendral desarrollado por ward feigenbaum en el instituto tecnología carnegie actual instituto carnegie tecnología el trabajo feigenbaum se vió fuertemente inﬂuenciado por el trabajo otros importantes investigadores como john von newman en principio y por herbert simon y allen newell posteriormente en sus propias palabras feigenbaum claró que cuando newell anunció el desarrollo los primeros modelos computadora sobre el pensamiento humano y la toma desiciones su clase él renació y partir ese momento decidió seguir el camino del estudio los procesos mentales humanos henderson en lugar abordar el proceso toma decisiones feigenbaum se dedicó al estudio la memorización desarrollando programa conocido como epam elementary perceiver memorizer una la contribuciones más importantes del trabajo feigenbaum la inteligencia artiﬁcial fue el desarrollo la redes discriminación introducción y antecedentes la inteligencia artiﬁcial que posteriormente formaron parte la investigación en redes neuronales principios los años feigenbaum estuvo trabajando en una aplicación concreta relacionada espectrómetro masa el que se percató la necesidad construir una base conocimiento para que los programas la pudieran usar el tado del trabajo feigenbaum y su colega robert lindsay en fue el desarrollo dendral el primer sistema experto exitoso y productivo dendral mostro potencial en la deducción información sobre estructuras químicas que acuerdo su propio autor se desprendía su conocimiento sobre química feigenbaum pesar la fuerte crítica que recibió en dendral en su tiempo pues algunos tigadores la época lo consideraron demasiado especializado en química al grado que podían aprender poco él feigenbaum se dejó intimidar en su lugar formuló lo que él llamó el principio del conocimiento el cual establece que en la ausencia del conocimiento el razonamiento e inútil figura edward feigenbaum posteriormente el equipo feigenbaum inició nuevo proyecto que se extendería en la universidad stanfort este sistema experto introdujo el uso concimiento impreciso y la posibilidad explicar el proceso razonamiento la herramienta aunque el proyecto fue inicialmente conducido por feigenbaum fue ﬁnalizado por shortliﬀe y sus colaboradores mediante el uso lisp la relevancia este sistema radica en la demostración la eﬁciencia su esquema representación del conocimiento y sus técnicas razonamiento mismas que ejercieron una enorme inﬂuencia en el desarrollo sistemas posteriores basados en reglas en tanto dominios médicos como médicos el propósito mycin fue el diagnóstico enfermedades infecciosas la sangre figura edward shortliﬀe la tabla recopila algunos los primeros sistemas expertos rolston los sistemas presentados en esta tabla no permiten visualizar que alrededor los años s se empezó generar enorme interés en lo que posteriormente se conoció introduccion sistemas basados en el conocimiento tabla primeros sistemas expertos sistema fecha autor aplicación dendral stanford deducción información bre estructuras químicas macsyma mit análisis matemático complejo hearsay carnegie mellon interpreta en lenguaje natural subconjunto del idioma mycin stanford diagnóstico enfermedades la sangre tieresias stanford herramienta para la mación conocimientos prospector stanford exploración mineral y mientas identiﬁcación age stanford herramienta para generar temas expertos carnegie mellon herramientas para desarrollo sistemas expertos caduceus university pittsburg herramienta diagnóstico para medicina interna rosie rand herramienta desarrollo sistemas expertos carnegie mellon conﬁgurador equipos computación para dec ambientes desarrollo debido al enorme éxito que tuvieron los sistemas expertos en la década los s empezaron surgir desarrollos conocidos como shell en computación una shell e una pieza software que provee una interfaz para los usuarios sistema experto posee entre sus componentes la do herramientas siguientes base conocimientos el conocimiento relacionado problema o fenómeno se codiﬁca según una notación especíﬁca que incluye reglas predicados redes semánticas y objetos motor inferencia e el mecanismo que combina los hechos y la preguntas particulares utilizando la base conocimiento seleccionando los datos y pasos apropiados para presentar los resultados en el entorno los sistemas expertos una shell e una herramienta diseñada para facilitar su desarrollo e implementación en otros términos una shell e sistema experto que posee una base conocimientos vacía pero acompañada la mientas necesarias para proveer la base conocimiento sobre el dominio del discurso una aplicación especíﬁca una shell provee también al ingeniero del conocimiento encargado recabar la base conocimientos una herramienta que trae integrado algún mecanismo representación del conocimiento ver capítulo introducción y antecedentes la inteligencia artiﬁcial inferencia ver capítulo elementos que faciliten la explicación del procedimiento o decisión tomados por el sistema experto componente explicativo e incluso algunas veces proveen una interfaz usuario el uso estos ambientes desarrollo permiten el desarrollo sistemas expertos eﬁcientes incluso cuando se domine algún lenguaje programación razón por la que se ha popularizado su uso para la producción sistemas expertos en todos los dominios del conocimiento algunos ambientes desarrollo para la construcción sistemas expertos te del dominio o shell clásicos son emycin o essential mycin esta shell fue construida en la universidad stanford como resultado del desarrollo del sistema experto mycin que realizaba el enfermedades infecciosas la sangre el sistema emycin fue la base para la construcción muchos otros sistemas expertos tale como el puff que diagnostica enfermedades pulmonares y el sacon que trabaja ingeniería estructural estas shell fueron desarrolladas en c e el lenguaje que debe ser empleado para la inserción la reglas base y junto el uso del encadenamiento hacia adelante la posibilidad insertar la reglas en lenguaje como el c son sus principales aportaciones este sistema esta basado en el algoritmo propietario rete ii el algoritmo rete e reconocida eﬁcacia para la comparación hechos los patrones la reglas y la determinación cuales ellas satisfacen sus condiciones expert development environment esta e una herramienta mercial creada por ibm para sus sistemas operativos vm y mv esta herramienta que incluye facilidades gráﬁcas y acceso base datos fue creada para su uso mainframe esta herramienta usa reglas para representar el conocimiento del tipo x y la principal ventaja este tipo representación e su facilidad para modiﬁcarlas y el hecho que la reglas son esquema muy semejante al modelo el que los seres humanos razonamos o planteamos la solución problema kee knowledge engineering environment esta herramienta la casa comercial intellicorpcombinaelusodelaprogramaciónorientadaaobjetosyelusodereglascomo herramientas representación del conocimiento debido la mezcla técnicas esta shell e conocida como una herramienta híbrida el tipo b asico representación keeestabasadaenmarcosconjerarquíasmultipadreyvariosmecanismosdeherencias que permiten transferir los atributos los marcos través la jerarquía filman esta herramienta también puede codiﬁcar el conocimiento mediante lisp kee fue desarrollado mediante common lisp y usa reglas del tipo antecedente consecuente acuerdo s hayes esta herramienta para el desarrollo sistemas expertos basada en reglas provee toda clase facilidades para la introducción del conocimiento tanto por parte del ingeniero como del experto sobre cierto dominio este sistema incluye ya el uso del idioma inglés manera que traduce automáticamente fragmentos texto que se asocien la base conocimientos este sistema además muestra dinámicamente sus líneas razonamiento alternativas conclusiones y reglas heurísticas consideradas exsys considerado por largo tiempo como el líder para el desarrollo sistemas pertos e el resultado más años mejora y reﬁnamiento esta actividades aprendizaje posee también elementos para la producción sistemas expertos interactivos en la web exsys usa reglas del tipo que son resueltas mecanismos hacia adelante o hacia tras acuerdo al problema que se pretende resolver en este sistema e factible que la reglas posean múltiples hechos en la parte del diante el uso conectores lógicos mientras que la parte del solamente presenta componente en este sistema la reglas se agrupan en una estructura arbórea que permite su mejor administración y comprensión naturalmenteexisteunaenormelistadeherramientasquenohansidocomentadas entre la que se pueden mencionar nexpert object guru hugin icarus entre otros area la inteligencia artiﬁcial en la actualidad existe una gran cantidad area especiﬁcas en la que se trabaja bajo el concepto inteligenci artiﬁcial cada una estas cuenta herramientas tecnicas propias para lograr sus ofjetivos algunas estas se enlista en la siguiente tabla tabla topicos la inteligencia artiﬁcial mineria datos computación evolutiva algoritmos reconocimiento imagenes reconocimiento patrones ia distribuidad y sistemas multiagentes sistemas expertos y sistemas basados en conocimientorepresentación y cion del conocimientoprocesamiento del lenguaje natural ontologias interface inteligentes redes neuronales lógica difusa algoritmos genéticos aprendizaje máquina vida artiﬁcial programación lógica sistemas hibridos inteligentes sistemas tutores inteligentes razonamiento basado en sosrealidad aumentada programación evolutiva optimización multiobjetivo teoria automatas actividades aprendizaje después haber haber concluido la lectura del capítulo introducción y antecedentes la inteligencia artiﬁcial responda la siguientes preguntas en que lenguaje programación se construyó el sistema conocido como logic theorist cuyo propósito era el resolver fue saymour papert mencione evento enorme interés para la inteligencia artiﬁcial que tuvo lugar en e el creador del lenguaje conocido como smalltalk quién se le atribuye el desarrollo la familia lenguajes ops lenguaje programación se empleó para el desarrollo mycin e dendral describirías al software eliza introducción y antecedentes la inteligencia artiﬁcial material referencias consultar opcional lecturas adicionales libros herken universal turing machine segunda edición londres oxford versity press incluye una descripción la computadora universal turing mccorduck pamela machine think natick mass peter sión del trabajo john mccarthy y otros investigadores pioneros la inteligencia artiﬁcial shasha dennis cathy lazere mind life discovery great computer scientist new york incluye entre otros grandes pensadores la ciencias la computación información mccarthy y genbaum alonso angeles representación y manejo información semántica heterogénea en interacción tesis doctoral en ciencias la computación instituto politécnico nacional noviembre méxico sitios web hodges alan turing home disponible en línea url http accesado en diciembre homepagede http accesado en diciembre homepagede edwardsshortliﬀe http en diciembre referencias asimov robot new york ny gnome press colmenauer roussel birth prolog acm itam breve historia la inteligencia artiﬁcial url http recuperado en noviembre mccarthy j recursive function symbolic expression tation machine cacm vol pp newell y simon gps program simulates human thought en feigenbaum y feldmann hrsg computer thought isbn charles forgy eﬃcient implementation production thesis university hayes rule based system encyclopedia artiﬁtial intelligence volume john wiley son pp henderson artiﬁcial intelligence mirror mind chelsea house material referencias consultar opcional ingalls daniel design principle smalltalk byte gazine company agosto url http kay alan reactive engine extractos url http pajares y santos inteligencia artiﬁcial e ingeniería del conocimiento alfaomega isbn mexico rusell norving inteligencia artiﬁcial enfoque moderno segunda edición prentice hall roussel turing computing machinery intelligence mind vol pp rolston principios inteligencia artiﬁcial y sistemas expertos editorial graw hill isbn feigenbaum edward age intelligent machine knowledge file server knowledge kurzweilai net available online url http visitado en diciembre filman kee encyclopedia artiﬁcial intelligence volume john wiley son pp fatima sayuri quezada aguilera universidad autónoma aguascalientes mexico introduccion el ser humano constantemente se hace preguntas referentes la actividades que realiza cotidianamente como los juegos dominados por el azar la forma en como se solucionan los problemas mediante el razonamiento la labores en el trabajo la solución blemas numéricos la relaciones interpersonales y sus efectos el lenguaje y sus reglas entre otros así mismo también se pregunta sobre los fenómenos o sistemas que observa en el medio ambiente en que se desenvuelve sobre si mismo y los seres que lo rodean estas preguntas no conlleva problema o más del cuál se desea encontrar la solución si esta existe y sólo una solución sino la mejor solución que se pueda obtener e implementar tomando en cuenta todos los recursos disponibles sistema informático e el producto ﬁnal la solución que se proponga siendo así la síntesis del problema e por esto que el hombre lleva cabo do tareas o procesos principales analizar y sintetizar abstraer la primera e para comprender identiﬁcar elementos y medir el fenómeno actividad o sistema bajo estudio seguido esto viene la síntesis que permite abstraer todos o la mayoría los elementos y detalles más relevantes desde la perspectiva quien o quienes llevan cabo esta tarea en forma especiﬁcaciones en esta última tarea generalmente existen varios niveles abstracción los que pueden variar cuerdo al problema y el nivel detalle al que se desee o se pueda llegar estos problemas los encontramos en toda la áreas la ciencia y la vida del ser humano porlocualsepuededecirquehayunacantidadinﬁnitadeproblemasaresolver ahora bien posible resolver todos estos problema cuenta la herramientas matemáticas o otro tipo para resolverlos los investigadores del área la inteligencia artiﬁcial han desarrollado herramientas para resolver cierto tipo problemas que otros enfoque clásicos ha sido difícil encontrar la mejor solución obteniendo muy buenos resultados la búsquedas que mediante agentes inteligentes realizan el procedimiento o sin información parallegaralasolución sonunabuenaformaderesolverproblemasusando la herramientas la inteligencia artiﬁcial para hacer el uso adecuado la técnicas la inteligencia artiﬁcial e importante deﬁnir si el problema puede ser resuelto mediante la mismas y plantear el problema planteamiento del problema la manera adecuada clasiﬁcación los problemas los problemas se clasiﬁcan según la complejidad para resolverlos tanto en tiempo como en espacio ya que son los recursos críticos en la solución los diferentes problemas por su complejidad para resolver los problemas se deﬁnen do clases principales que son viene del inglés polinomial que quiere decir que el algoritmo requiere po polinomial o polinómico en función del tamaño la instancia del problema para resolverlo np del inglés non deterministic polinomial que signiﬁca que el algoritmo tiempo que tiende ser exponencial en función del tamaño la instancia del problema para resolverlo en la clase np existe otra clases problemas llamados completos npc por lo cual muchos cientíﬁcos creen que p np los problemas np completos tienen la característica que si se encuentra algoritmo polinomial para resolver cualquiera los problemas completos entonces toda esa clase problemas puede ser resuelta por algoritmo polinomial hasta el momento se ha encontrado ningún algoritmo polinomial para resolver estos problemas continuación se muestran gráﬁcamente la relaciones que hay entre la clases problemas p y np y la clases p np y npc figura esta e la relación que más cientíﬁcos creen que existe entre estas clases problemas figura esta e la relación que muchos investigadores creen que hay entre estas clases problemas en el libro garey y johnson los autores dedican apéndice al compendio los problemas np y los cuales son agrupados cuerdo sus características estos son problemas base o tipo e decir son una generalización en la cual se deﬁne formalmente matemáticamente el problema considerando la variable y la restricciones además otros elementos esta manera si encontramos problema en cualquier área la ciencia en la vida real que se plantee como cualquiera estos problemas plantear problema se tendrá una idea más clara que tipo herramienta o técnica se deberá usar para solucionarlo plantear problema el planteamiento del problema inicia la descripción del mismo en lenguaje natural donde se establece la meta solución que se quiere obtener se delimita el problema y los elementos que intervienen como los son la variable restricciones función objetivo o optimizar punto partida todo esto manera tanto informal aquí e donde se identiﬁca el nivel conocimiento que se tiene del problema luego obtener la descripción en lenguaje natural se sigue proceso deﬁnición formal y estructurada que se representará en algún lenguaje lo cual no lleva otro nivel abstracción o síntesis en este nivel e necesario deﬁnir la entidades que van interactuar y eliminar ciertos detalles que se consideren relevantes aquí e donde se puede determinar que parte la descripción del problema puede ser validada y representada simbólicamente parte del proceso requiere que se determinen la entradas la salidas y el proceso cálculos y acciones que realizará cada entidad cada nivel y la forma en como se comunicaran entre ellas ser posible e importante formalizar aspectos del problema como función objetivo o optimizar variable parámetros que intervienen restricciones la forma la solución si sólo se desea obtener valor ﬁnal o la serie pasos para llegar ella en este proceso formalización del problema resolver e importante veriﬁcar si este e similar los problemas tipo ya deﬁnidos en la literatura como los problemas np los cuales ya hay una deﬁnición muy especíﬁca pudiendo así concentrarse en los aspectos como ciertas restricciones que puedan variar poco respecto al problema tipo pero que lo hacen diferente del problema resolver figura representación del espació soluciones también se debe determinar el espacio soluciones la cuales se van considerar sólo la soluciones factibles e decir la soluciones que cumplan la restricciones previamente establecidas la cuales una o más pueden ser la solución optimum que resuelve el problema además lo anterior se requiere la información o datos los que se trabajará que representarán la instancia del problema resolver una vez determinado esto se podrá elegir la estrategia seguir para obtener la solución del problema que en este caso será la búsqueda mediante planteamiento del problema planteamiento del problema para ser resuelto mediante la búsqueda como se mencionó la solución problema se puede llevar cabo mediante métodos búsqueda para lo cuál se requiere abstraer los elementos la entidades y la forma en que van ser manipulados por agente que se conocerá como solucionador del problema función objetivo o optimizar variable parámetros que intervienen restricciones la forma la solución si sólo se desea obtener valor ﬁnal o la serie pasos para llegar ella tabla elementos que se deben identiﬁcar problema elementosparasolucionar problemaelementos para narunproblemamediante búsqueda función objetivo meta variable parámetros elementos valores la variable valores estados restricciones cambiar estado otro forma la solución solución instancia del problema datos estrategia algoritmo búsqueda representación del problema cuerdo la estrategia leccionadagrafo el proceso identiﬁcación obtención datos tegia y solución del problema puede ser llevado cabo por entes que tengan nivel inteligencia suﬁciente para llevar cabo dicho proceso por lo cual e tema básico en la inteligencia artiﬁcial este proceso resolución problemas requiere conjunto datos iniciales que utilizando conjunto procedimientos seleccionados priori e capaz determinar el conjunto pasos o elementos que no llevan lo que denominaremos una solución cada problema que se pueda plantear e diferente sin embargo todos tienen ciertas características comunes que no permiten en primera instancia clasiﬁcarlos y turarlos en segunda instancia esta estructuración la cual se debe llevar cabo una manera formal no puede permitir resolverlos manera automática utilizando la representación adecuada dicha representación por necesidad uniformidad y rización deberá utilizar lenguaje común para ser utilizado por los entes inteligentes si abstraemos los elementos que describen problema podemos identiﬁcar elementos como punto partida los elementos que deﬁnen la características del problema objetivo alcanzar qué queremos obtener la resolución acciones nuestra disposición para resolver el problema qué herramientas disponemos para manipular los elementos del problema restricciones sobre el objetivo qué características debe tener la planteamiento del problema para ser resuelto mediante la búsqueda elementos que son relevantes en el problema deﬁnidos por el dominio concreto que conocimiento tenemos que no puede ayudar resolver el problema una manera eﬁciente espaciodeestados setratadelaaproximaciónmásgeneral unproblemasedivideenun conjunto pasos resolución que enlazan los elementos iniciales los elementos que describen la solución donde en cada paso podemos ver como se transforma el problema el conjunto estados que el agente debe recorrer generalmente se representa mediante ungrafo aunqueenalgunoscasosconcretos del grafo representará uno los estados el problema la n reinas e problema clásico en este caso el problema se trata colocar n reinas en tablero ajedrez n manera que se maten entre si en este problema no interesa la manera hallar la solución sino el estado ﬁnal en la ﬁgura tenemos representada la solución para problema dimensión figura ejemplo una solución para el problema la espacio estados conﬁguraciones n reinas en el tablero sólo una por ﬁla y columna estado inicial conﬁguración sin reinas en el tablero estado ﬁnal conﬁguración n reinas en el tablero en la que ninguna reina se mata entre si operadores colocar una reina en una ﬁla y columna condiciones la reina e matada por ninguna otra ya colocada transformación colocar una reina más en el tablero en una ﬁla y columna minada solución una solución pero no importan los planteamiento del problema figura ejemplo del unproblemaclásicoque consisteenuntablerodemposiciones dispuesto como una matriz n en el que hay nxn posiciones ocupadas por ﬁchas numeradas manera consecutiva empezando del uno y una posición vacía la ﬁchas se pueden mover ocupando la posición vacía si la tienen como adyacente el objetivo e partir una disposición cualquiera la ﬁchas para obtener una disposición éstas en orden especíﬁco tenemos una representación del problema en la siguiente ﬁgura la deﬁnición los elementos del problema para plantearlo en el espacio estados sería la siguiente espacio estados conﬁguraciones ﬁchas en el tablero estado inicial cualquier conﬁguración estado ﬁnal fichas en orden especíﬁco operadores mover el hueco condiciones el movimiento está dentro del blero transformación intercambio entre el hueco y la ﬁcha en la posición del vimiento solución que movimientos hay que hacer para llegar al estado ﬁnal mente no interesa la solución el menor número pasos bibliografía papadimitriou steiglitz combinatorial optimization algorithm complexity dover publication thomas cormen charles leiserson ronald rivest introductiion algorithm mit press steven skiena algorithm design manual springer segunda edición stuart russell peter norvig inteligencia artiﬁcial enfoque moderno pearson prentice hall segunda edición antonio silva sprock y ember martínez flor universidad central venezuela venezuela universidad colombia introduccion la mayoría los programas y software que trabajan ia manipulan símbolos y piezas información sobre el mundo representado partir los conocimientos adquiridos provenientes múltiples fuentes conocimiento como documentos expertos para que la máquina se comporte manera inteligente debe poseer nocimiento almacenado en una base conocimiento y debe ser capaz utilizarlo e decir basta introducir el conocimiento en la máquina o en el software hay que proveer unos mecanismos que le permitan razonar el conocimiento previamente almacenado y esto e expresar una manera formal conceptos y la relaciones surgidas lograr tal razonamiento sobre una base conocimiento implica la dad plasmarlos según algún modelo representación que en cualquier caso debe ser aquel que mejor se adecúe los conocimientos adquiridos teriormente seconcretalaelecciónparticulardelaherramientayseformaliza acuerdo ella el área la ia que estudia cómo representar el conocimiento adquirido del mundo en una computadora se llama representación del conocimiento y la distintas formas estructuras o técnicas que permiten expresar el esquema conceptual como esquema formal se denominan formalismos o técnicas representación conocimiento la ﬁgura muestra el proceso lización del mundo externo hacia una base conocimiento figura proceso modelización del mundo externo hacia una base conocimiento representación del conocimiento características deseables los formalismos representación conocimiento rich y hnight indican que buen sistema representación cimiento en dominio particular debe poseer características suﬁciencia y eﬁciencia como son suﬁciencia la representación la capacidad representar todos los tipos conocimiento necesarios en el dominio suﬁciencia deductiva la capacidad para manipular la estructuras la presentación el ﬁn obtener nuevas estructuras que se correspondan nuevo conocimiento deducido partir del antiguo eﬁciencia deductiva capacidad incorporar información adicional en la estructuras conocimiento el ﬁn que los mecanismos inferencia puedan seguir la direcciones más prometedoras eﬁciencia en la adquisición la capacidad adquirir nueva información facilidad como se observa la características mencionadas son aún deseables ya que puede encontrarse formalismo que garantice tale características sin embargo si se puede exigir que buen formalismo posea exactitud referida si el modelo utilizado e lo suﬁcientemente ﬁel la realidad como para distorsionarla adecuación referida al poder expresivo y la eﬁcacia del formalismo la mera trata todo lo que se puede decir la notación e decir si la sentación permite realizar o evitar distinciones sutiles la eﬁcacia se reﬁere la estructura concretas que se utilizan y al impacto dichas estructuras en la operaciones del sistema estas últimas exigencias permiten poder escoger conjunto neo formalismos imperfectos que logran adecuarse en alguna medida al conocimiento del dominio que se desea representar tipos conocimiento la técnica o formalismo representación conocimiento depende en gran medida del conocimiento los distintos formalismos permiten representar cualquier conocimiento del mundo exterior sin embargo unos formalismos son más adecuados que otros y esta adecuación depende del tipo miento conocimiento declarativo versus conocimiento procedimental rich y hnight llaman al conocimiento declarativo conocimiento cional simple al aﬁrmar que pueden almacenarse en estructuras del mismo tipo que la utilizadas en los sistemas base datos igualmente man que e simple por la escasa capacidad deductiva que ofrece la tabla muestra ejemplo conocimiento descriptivo figura tabla almacenando conocimiento descriptivo técnicas representación conocimientos por otra parte existe otro conocimiento operacional o procedimental que especiﬁca que hacer cuando se da una determinada situación por ejemplo pensemos en la necesidad seleccionar el mejor estudiante por cada opción la carrera considerando la preferencia y la caliﬁcación o incluir como criterio al más joven donde requerimos algunos elementos más que los cenados estáticamente mostrados en la tabla conocimiento heredable una la formas más útiles inferencia en la herencia propiedades donde los elementos una clase heredad los atributos y los valores otras clases más generales en la que están incluidos técnicas representación conocimientos la diversas técnicas representación conocimientos se pueden agrupar en tres familias dependiendo la adecuación del formalismo para tar conceptos relaciones o acciones formalismos basados en conceptos representan la principales entidades del dominio así como los posibles re que pueda tomar cada propiedad los formalismos basados en conceptos más utilizados son y los marcos marcos propuestos por marvin minsky en e una estructura datos que representa situaciones estereotipadas que posee gran capacidad para presentar aspectos semánticos sobre el conocimiento declarativo del dominio los marcos están formada por nombre y conjunto propiedades madas ranuras o nichos en inglés slot cada nicho tiene unas propiedades que reciben el nombre facetas estas facetas describen el tipo valores que puede tomar los marcos se relacionan otros marcos esta forma se puede establecer una jerarquía entre ellos en la práctica los conceptos marcos y objetos tienden asemejarse mucho según la utilidades que presentan en algunas herramientas shell ambo términos representan lo mismo composición los marcos marcos clases y marcos instanciados ver figura estándares subclase e instancia y superclase y elementos la clase ver ﬁgura estándares fraternal disjunto disjunto y cualquier otra ad hoc ver ﬁgura la relaciones permiten expresar la dependencias entre los conceptos y permite desarrollar sistema basado en marcos clase propias instancia miembros contiene al concepto propiedad y relación por tipo conocimiento facetas declarativas tipo lidad multivaluado factor certeza valores permitidos valores por omisión facetas procedimentales precondición si necesito si modiﬁco si añado si borro ver ﬁgura por tipo propiedades facetas clase y instancia tipo cardinalidad multivaluado factor certeza instancia valores mitidos valores por omisión precondición si necesito si modiﬁco si añado si borro representación del conocimiento figura jerarquía marcos mostrando la jerarquía figura ejemplo relaciones estándares figura ejemplo relaciones estándares figura ejemplo propiedades figura ejemplo del marco llamado hombre formalismos basados en relaciones capaces representar la relaciones existentes entre entidades y conceptos los más importantes son lógica redes semánticas y la teoría dencia conceptual y la ontologías lógica estos formalismos pueden ser la lógica proposicional y lógica predicados o primer orden lógica proposicional una proposición e enunciado frase o expresión quetieneunsigniﬁcadodeterminadoyquemedianteuncriterioessusceptible ser caliﬁcada como verdadero o falso son ejemplos proposiciones formalismos basados en relaciones siguientes enunciados e campeón mundial futbol e país cafetero calor dilata los cuerpos sol e planeta toda frase o expresión e una proposición por ejemplo crux la calle si hay mucho tráﬁco e su número telefónico hora e triste la brasil e campeón mundial futbol representa una proposición que puede ser caliﬁcada verdadera o falsa en este caso particular brasil ganó los mundiales del año y por la que puede ser caliﬁcada como verdadera mientras que la frase crux la calle si hay mucho tráﬁco e proposición porque e una oración imperativa que expresa una sugerencia o consejo la cual se le puede asignar caliﬁcación verdadera o falsa la proposiciones son los elementos u objetos básicos en la lógica siciones donde son representadas por letras minúsculas del alfabeto p q r s t cada una estas letras recibe el nombre símbolos proposicionales o átomos una expresión formada por solo símbolo proposicionales se llama sición atómica o simple la proposiciones compuestas relaciona do o más proposiciones por medio conector lógico la proposiciones el sol e planeta y el calor dilata los cuerpos son proposiciones simple mientras que expresiones como el número e visible por y por y colombia e país cafetero y bananero son proposiciones compuesta debido que relacionan do o más proposiciones en el primer caso se pueden identiﬁcar la proposición el número e sible por y el número e divisible por unidas por una conjunción conector lógico y en lógica proposicional la sentencias o fórmulas bien formadas se construyen usando los símbolos proposicionales p q r s t conectores lógicos y símbolos auxiliares los símbolos primitivos en lógica proposiciones son símbolos p q r s conectores lógicos conjunción disyunción negación implicación o condicional bicondicional símbolos auxiliares una expresión o fórmula bien formada cumple los siguientes criterios los símbolos proposicionales son una formula bien formada e una expresión bien formada la negación la expresión e una formula bien formada y b son expresiones bien formadas entonces la expresión formada por la composición y b través conector lógico e una expresión bien formada e una expresión bien formada si e resultado la aplicación la reglas anteriores número ﬁnito veces por ejemplo si se consideran la siguientes proposiciones la inﬂación e representación del conocimiento el tasa desempleo e alta el índice pobreza crece se pueden construir la siguientes formula bien formadas dado los valores verdad la proposiciones se puede obtener el valor verdad una expresión o formula bien formada utilizando la semántica los conectivos lógicos como se muestra continuación vvvvfv v vffvff f fvfvvv f ffffvv v en la lógica proposicional se puede determinar el valor verdad una proposición sin necesidad tener en cuenta la semántica la expresión e suﬁciente conocer su estructura por ejemplo se puede calcular el valor verdad para la expresión pq pq la siguiente forma vvvvv vffvv fvfvv ffffv lógica predicados en el lenguaje natural existen argumentos que son intuitivamente válidos pero cuya validez puede ser probada por la ca proposicional esto se debe la falta mecanismo que le permita indagar la estructura interna la variable proposicionales generalizar y diferenciar objeto una propiedad por ejemplo considérese la te expresiones persona que practican algún deporte son más saludables persona e sexo masculino o femenino alumnos aprobaran la materia ciudades cálidas son más apetecidas por los turistas la lógica predicados permite enunciar algo sobre los objetos e decir deﬁnir atributos y relaciones entre elementos través objetos atributos y relaciones se puede expresar prácticamente cualquier tipo expresión inclusive como la listadas anteriormente redes semánticas son grafos orientados formados por nodos y por co unidireccionales los nodos representan los conceptos objetos atributos características o situaciones y los arcos entre los nodos representan la ciones entre los conceptos los arcos pueden ser estructurales donde la semántica e independiente del conocimiento que se está representado y pueden ser generalización laciona una clase otra más general y permite formar una red nodos por especialización conceptos ejemplo ciación relaciona objeto concreto su tipo o clase genérica ejemplo agregación relaciona objeto o concepto sus componentes ejemplo los arcos descriptivos pueden formalismos basados en relaciones propiedades relaciona objeto alguna propiedad especíﬁca plo caliﬁcación y los arcos relacionadas otras relaciones permiten deﬁnir otras relaciones estructurales ejemplo los arcos descriptivos sirven para describir los tos mediante atributos propios del dominio la ﬁgura muestra una red semántica figura ejemplo red semántica ontologías entremuchasdeﬁniciones lópez y corcho tramullas la ofrecida por gruber e la más aceptada e una especiﬁcación formal y explícita una lización compartida la ontologías son por ser una organización teórica términos y relaciones do como herramienta para el análisis los conceptos dominio por capturar conocimiento consensual que e aceptado por una comunidad por estar referida la especiﬁcación los conceptos y la restricciones sobre estos yagregando mássentido ala deﬁnición sepuedeadicionarque unaontología debe ser legible y libre ambigüedades componentes la ontologías varían acuerdo al dominio interés y la necesidades los desarrolladores lozano y otros indican que por lo general entre los componentes se encuentran los siguientes la clases son la base la descripción del conocimiento en la ontologías ya que describen los conceptos idea básicas que se intentan formalizar del dominio la clases usualmente se organizan en mías la que por lo general se le aplican mecanismos herencia representan la interacciones entre los conceptos del dominio la ontologías por lo general contienen relaciones binarias el primer argumento la relación se conoce como el dominio y el segundo como el representación del conocimiento son tipo concreto relación donde se identiﬁca mento mediante el cálculo una función que considera varios elementos una ontología representan objetos determinados concepto conjunto conceptos organizados jerárquicamente la xonomías deﬁnen la relaciones entre los conceptos pero los atributos éstos usados para modelar sentencias que son siempre ciertas los axiomaspermiten juntoconlaherenciadeconceptos que esté indicado explícitamente en la taxonomía conceptos los axiomas deﬁnidos en una ontología pueden ser estructurales o turales axioma estructural establece condiciones relacionadas la jerarquía la ontología conceptos y atributos deﬁnidos axioma estructural establece relaciones entre atributos concepto y son pecíﬁcos dominio los axiomas se utilizan también para veriﬁcar la consistencia la ontología slot sonlascaracterísticasoatributosquedescribenalos conceptos la especiﬁcaciones rangos y restricciones sobre los valores la propiedades se denominan facet para concepto dado la propiedadesylasrestriccionessobreéstossonheredadasporlassubclases y la instancias la clase la ﬁgura muestra una implementación una ontología estilos aprendizaje en el software desarrollo ontologías protégé figura implementación en ptotege una ontología estilos aprendizaje silva sprock y ponce gallegos clasiﬁcación la ontologías la ontologías se pueden clasiﬁcar doencuentadiferentescriterios comoporejemplo laintencióndeusootarea en particular la formalidad del lenguaje utilizado para su construcción la neralidad entre otros sin embargo existe una taxonomía estándar la ontologías que permitan manejar una clasiﬁcación exacta la ontologías e decir múltiples autores presentan múltiples clasiﬁcaciones y otros uschold y grüninger fipa uschold uschold y grüninger presenta tres dimensiones sobre la formalismos basados en relaciones le varían los tipos ontologías para referirse al grado formalismo del lenguaje usado para expresar la conceptualización para referirse la intención uso la ontología para expresar la naturaleza los objetos que la ontología racteriza ontología según su formalidad los tipos ontologías según el grado formalidad del lenguaje usado son los siguientes altamente informal expresada en lenguaje natural glosario términos informal estructurada utiliza lenguaje natural estructurado y restringido que permite reducción la ambigüedad usa lenguaje deﬁnición formal como lingua rigurosamente formal la deﬁnición términos se lleva bo manera meticulosa usando semántica formal y teoremas tove toronto virtual enterprise ontología según su propósito los tipos ontologías según el propósito o uso que se le vaya dar son la siguientes para comunicación entre persona una ontología informal puede ser suﬁciente para entre sistemas para llevar cabo ducciones entre diferentes métodos lenguajes software en estos so la ontología se usa como formato intercambio conocimiento para beneﬁciar la ingeniería sistemas en cuanto la ontología e la base para una codiﬁcación formal entidades importantes atributos procesos y sus interrelaciones en el minio interés esta representación formal podría ser componente reusable compartido en sistema software conocimiento la velocidad y la conﬁabilidad podría ser incrementada usando una ontología existente como punto partida y como base para la adquisición conocimiento cuando se construye sistema basado en conocimiento una representación formal hace posible que la automatización del chequeo consistencia resulte en software más conﬁable la ontología puede asistir al proceso identiﬁcación requerimientos y deﬁnición una especiﬁcación para sistemas nologías información ontología según su materia según los objetos o problemas que se tericen en la ontologías éstas pueden ser dominio caracterizan objetos especíﬁcos tale como dicina ﬁnanzas química biología para resolver problemas conceptualizan el problema o tarea resolver en dominio el objeto que se caracteriza e lenguaje tación representación del conocimiento formalismos basados en acciones estos formalismos permiten representar los conocimientos del dominio diante acciones básicas los más importantes son reglas producción y los guiones reglas producción la representación basada en reglas parte del cipio que la relación lógica entre conjunto objetos pueden ser tadas mediante una regla cada regla tiene la forma si p entonces q donde p e la e el antecedente premisa condición o situación la regla y q e el consecuente conclusión acción o respuesta el antecedente y la conclusión la regla son expresiones lógicas que contiene una o más proposiciones simple o compuestas una proposición como si el fuego e producido por líquido combustible inﬂamable entonces incendio e clase b puede ser simbolizada en lógica la siguiente forma si fuego producido por líquido combustible inﬂamable entonces incendio e clase b f x b para todo x si x e fuego producido por líquido combustible inﬂamable entonces fuego clase algunas representaciones imponen restricciones la reglas por ejemplo el antecedente debe ser una expresión lógica que solo admiten conectores conjuntivos y el consecuente solo admite expresiones lógicas simple estas restricciones se toman para facilitar la manipulación y procesamiento tacional también se aplican este tipo restricciones debido que se puede remplazar cualquier expresión lógica través la reglas sustitución o equivalencia sin pérdida generalidad otra forma más general estructurar reglas producción e formando el antecedente la forma si y consecuente la forma entonces cuando los hechos descritos en el antecedente son ciertos se tienen los hechos que forman el consecuente entonces entonces entonces referencias ceccaroni l support management wastewater treatment plant tesis doctoral universidad politécnica cataluña españa corcho y lópez ding legal ontology methontology webode law semantic web legal ontology methodology legal information val application lnai marzo foundation intelligent physical agent fipa ontology service speciﬁcation número documento descargado el julio http referencias y corcho o ontological gineering springer verlag gruber principle design ontology used knowledge sharing available technical report ksl knowledge system laboratory stanford university descargado el julio dehttp lozano métrica idoneidad ontologías tesis doctoral cuela politécnica cáceres departamento informática universidad extremadura españa isbn rich y knight inteligencia artiﬁcial segunda edición interamericana silva sprock ponce gallegos j reingeniería una ontología estilos aprendizaje para la creación objetos aprendizaje revista tecnología información y comunicación en educación eduweb issn vol tramullas j agentes y ontologías para el tratamiento ción clasiﬁcación y recuperación en internet actas del iv congreso isko españa abril granada uschold y grüninger ontology principle method application knowledge engineering review vol number ana casali universidad nacional rosario argentina dentro la ia área que ha ganado relevancia en la últimas do décadas e el desarrollo agentes esto ha surgido por lado por la necesidad abordar problemas complejos que son muchas veces difíciles tratar por sistema monolítico o que son naturaleza distribuida ya sea porque los haymuchosautoresdonde consideran que ciertos comportamientos inteligentes más que ser modelados como conductas complejas individuales pueden surgir la interacción conductas simple esto ha llevado revisar muchas la lineas principales la ia este enfoque orientado agentes como e el reconocido libro inteligencia artiﬁcial russell norvig dada la relevancia del tema en este libro se incorpora este capítulo para dar una introducción los agentes inteligentes luego dar algunas ne la noción agencia en primer lugar se presenta el enfoque individual agente en esta dirección se plantean modelo teórico y distintas tecturas haciendo énfasis en la que se basan en los sistemas intencionales la cuales consideran que la acciones que realizan los agentes son cia ciertos estados mentales como sus creencias información que posee él y su entorno deseos objetivos ideales e intenciones objetivos que decide alcanzar luego se presenta una introducción al lenguaje jason como ejemplo lenguaje que permite implementar agentes concretos razonamiento práctico sistemas pr en la última sección se presentan los tópicos relevantes los aspectos sociales los agentes en los sistemas tiagentes como la características considerar para que la performance estos agentes en sociedad sea adecuada se plantea la necesidad tocolo comunicación e interacción y alguna la formas interacción más relevantes destacando la negociación se acompaña este capítulo la bibliografía que se ha citado en la distintas secciones y que servirá al lector para ampliar y profundizar la cobertura los temas que se han desarrollado introducción en los últimos años se ha incrementado el diseño e implementación ma multiagentes ma para abordar el desarrollo sistemas distribuidos complejos estos sistemas están compuestos por agentes autónomos que teractúan entre sí aplicaciones orientadas los agentes se han utilizado en distintos dominios como el comercio electrónico sistemas gestión agentes inteligentes cesos distribuidos sistemas control tráﬁco en gran parte esto se debe que el paradigma sistemas multiagentes ofrece conjunto ceptos y técnicas para modelar diseñar e implementar sistemas distribuidos complejos hay distintas razones que sostienen la importancia enfoque ia tribuida muchos los problemas están físicamente distribuidos el mundo está compuesto por entidades autónomas que interactúan entre sí y el entorno uno los principales objetivos este enfoque la ia e resolver problemas que son muy complejos para abordarlos sistema monolítico y además entender los principios subyacentes al comportamiento ples entidades del mundo denominadas agentes sus interacciones y cómo producen comportamiento general del sistema multiagente ma la noción agencia surge como ilustra la figura del aporte y conﬂuencia distintas lineas trabajo como el eje principal la inteligencia ﬁcial distribuida pero también puede considerarse como nuevo enfoque la ingenieria software orientada agentes aose agent oriented software engineering por otra parte puede verse como una evolución la programación orientada objetos donde estos objetos van tener mayor autonomía decidiendo qué método ejecutar y cuándo hacerlo todo estos foques han podido concretarse su vez dado los avances del soporte que le da el área sistemas distribuidos y redes cuando se hace referencia la noción agente surgen do ámbitos bajo similitud lo que sucede nivel humano el agente en sí mismo aspectos personales y los conjuntos agentes aspectos sociales en chos escenarios los agentes que conforman el sistema necesitan interactuar diferentes maneras el ﬁn cumplir sus metas o mejorar su peño el objetivo estas interacciones puede ser diferente naturaleza intercambiar información u objetos coordinar acciones negociar colaborar competir en este capítulo se tratarán principalmente los aspectos duales la agencia y luego se verá como los agentes conforman los llamados sistemas multiagentes qué e agente agente e una entidad física o virtual que posee ciertas características generales e capaz percibir el entorno y tener una representación parcial del mismo e capaz actuar sobre el entorno puede comunicarse qué e agente otros agentes pueden ser humanos o que comparten su hábitat tiene conjunto objetivos que gobiernan su comportamiento y posee recursos propios para ver que elementos distinguen agente software softbot otro tipo programa presentaremos algunas deﬁniciones segúnnorvig russel russel agente inteligente e aquél que puede percibir su ambiente mediante sensores y actuar sobre ese mundo mediante efectores o actuadores diseñar agente inteligente o racional que opere o actúe adecuadamente en sus ambientes esto signiﬁca que el agente debe hacer siempre lo correcto acuerdo sus percepciones y que emprenderá la mejor acción posible en una situación dada la racionalidad dependerá la secuencia percepciones lo que el agente ha percibido hasta ahora la medida éxito elegida cuántoconoceelagentedelambienteenqueoperaylasaccionesqueelagente esté en condiciones realizar ejemplo presentado en russel norvig e considerar taxi piloto automático taximetrero reemplazado por agente inteligente en este ejemplo podemos distinguir los siguientes elementos en relación al agente video acelerómetro instrumental del tablero sensores del motor seguridad llegar destino maximizar ganancias obedecer la leyes satisfacción del cliente callesurbanas avenidas tráﬁco peatones clima te si ahora se considera agente recomendador turismo en la web en este caso se tendría sitios web visitados por ususarios consultas realizadas compra pasajes y servicios vender productos turísticos promover destino satifacer al usuario la web wooldridge jennings deﬁnen agente como sistema computación situado en algún entorno que e capaz una acción autónoma y ﬂexible para alcanzar sus objetivos diseño que e sistema software hardware la siguientes propiedades fundamentales actuar sin intervención control sistema autónomo e capaz actuar independientemente exhibiendo control sobre su estado interno social lenguaje comunicación e la capacidad acción otros agentes posiblemente humanos través algún tipo delenguaje comunicación agentes la mayoría los entornos santes son dinámicos sistema reactivo e aquél que mantiene una interacción continuum el entorno y responde los cambios que se ducen en él en tiempo respuesta agentes inteligentes dirigido la meta toma iniciativa generalmente se espera que agente haga cosas para nosotros sistema proactivo e aquél que genus e intenta alcanzar metas e dirigido sólo por eventos toma iniciativa y reconoce oportunidades modelos abstractos agentes siguiendo weiss wooldridge se puede formalizar ción modelo abstracto agente que ciertas variantes puede lizar distintos tipos agentes primero se asume que el entorno del te puede caracterizarse por conjunto numerable estados del entorno la acciones que el agente puede realizar están da por el siguiente conjunto acciones luego agente estandar puede deﬁnirse mediante una función que mapea la secuencias estados acciones intuitivamente puede verse que este tipo agente decide que acción lizar en base su historia experiencias pasadas el comportamiento determinista del entorno puede modelarse mediante la función env p que toma el estado actual del entorno sy una acción aque ejecuta el agente y los mapea conjunto estados del entorno env s si todos estos conjuntos tienen sólo estado el entorno e determinista se puede representar la interacción del agente su entorno mediante su historia la cual se deﬁne como una secuencia partir del estado inicial h do agentes serán equivalentes respecto entorno env si sus historias son iguales hay agentes que toman sus decisiones respecto su historia sino que se basan sólo en el estado actual del entorno estos agentes suelen denominarse puramente reactivos y pueden representarse mediante una función que va cada estado del entorno una acción ejemplo simple este tipo agente e termostato tanque al que debe mantenerse en cierta temperatura t si la temperatura percibida e menor t el agente activará el calentador en caso contrario hará nada este modelo abstracto agente no conduce su implementación ya que se especiﬁca como desarrollar la función acción se deberá considerar reﬁnamiento este modelo y tomar decisiones diseño para poder desarrollar agentes concretos otra aspecto que hay que tener en cuenta e la habilidad del agente obtener información su entorno esto se puede representar mediante la funciónver que va los estados del entorno al conjunto pde percepciones ver enlosagentesquetenganalgunaestructurainternadedatos agentes basados en estados se considera que la decisión la acción tomar dependerá al menosparcialmente ielconjuntodelosposiblesestados internos la función selección la acción puede deﬁnirse para estos agentes la siguiente arquitecturas agentes además otra función nextmapeará la transiciones estado y la cepciones recibidas nuevo estado se pueden citar ejemplos agentes triviales como termostato o demonio en unix biﬀ actualmente hay muchas implementaciones agentes ligentes entre la cuales podemos mencionar agentes planiﬁcadores vuelos interfaz recomendadores agentes para comercio electrónico entre otros russel norvig presentan distintos tipos básicos agentes que concuerdan estos modelos planteados agentes reactivos actitud reﬂeja y ii agentes estado interno informados lo que pasa también plantean modelos razonamiemto más complejo pero que tienen comportamiento más ﬂexible iii agentes basados en metas o en una medida utilidad wooldridge jennings presentan también una noción más fuerte agente donde además la propiedades agente mencionadas mente se agregan nociones mentales como actitudes información cimiento creencias y deseos intenciones obligaciones esta noción agente se verá representada claramente en algunas la arquitecturas que se describirán en la próxima sección arquitecturas agentes el ﬁn dar los sistemas multiagente soporte formal se han puesto diversas teorías y arquitecturas agentes la teorías agentes son esencialmente especiﬁcaciones del comportamiento los agentes expresadas estas propiedades ayuda al diseñador razonar sobre el esperado del sistema la arquitecturas agentes representan punto medio entre la especiﬁcación y la implementación en ellas se identiﬁcan la principales funciones que determinan el comportamiento del agente y se ﬁnen la interdependencias que existen entre ellas luego esas arquitecturas se implementarán en lenguaje programación adecuado el ﬁn desarrollar agentes concretos para la aplicación deseada la teorías del agente basadas en enfoque intencional son la más da y estudiadas estos enfoques se basan en una psicología popular mediante el cual se predice y se explica el comportamiento humano través la bución actitudes por ejemplo la hora explicar la conducta humana menudo e útil y común hacer declaraciones como la siguiente tomó su abrigo porque creía que iba ser frío trabajó duro porque quería recibirse en estos ejemplos los comportamientos jorge y pedro se pueden explicar en términos sus actitudes como creer y querer se ha utilizado el término sistema intencional para describir entidades cuyo comportamiento puede ser predicho por el método atribuir ciertas actitudes mentales tale como creencia deseo y la visión racional dennet cuando el proceso del sistema subyacente e bien conocido y comprendido hay razón para tomar una postura intencional pero e lo que ocurre en muchas aplicaciones la nociones intencionales son herramientas ción que proporcionan una forma familiar describir explicar y agentes inteligentes el comportamiento sistema complejo considerando que agente e sistema que está convenientemente descrito por sistema intencional vale la pena evaluar cuáles son la actitudes apropiadas para representar agente la do categorías más importantes son la actitudes ción por conocimiento y creencias y deseos intenciones la obligación la actitudes información están relacionadas el conocimiento o cia que el agente tiene sobre el mundo mientras que la son la que alguna manera orientan la acciones los agentes la actitudes ambas categorías están estrechamente relacionadas y gran parte del bajo la teorías agentes consiste en esclarecer la relaciones entre ellas parece razonable que agente debe estar representado en términos al menos una actitud información y una se necesita marco lógico capaz establecer cómo los atributos agencia están relacionados cómo se actualiza el estado cognitivo agente cómo afecta el ambiente la creencias del agente y cómo la información y del agente lo conducen realizar acciones considerando ahora el área arquitecturas agentes este campo senta el paso desde la especiﬁcación hasta la implementación se abordan cuestiones tale como la siguientes se va construir sistemas máticos que satisfagan la propiedades especiﬁcadas por una particular teoría agentes el agente se puede descomponer en la construcción conjunto módulos componentes y cómo estos módulos deben interactuar estructuras software hardware son apropiadas maes ﬁnió una arquitectura agentes como una metodología especíﬁca para la construcción los agentes en él se especiﬁca la forma en la que el agente se puede descomponer en la construcción conjunto módulos nentes y cómo estos módulos deben interactuar el conjunto los módulos y sus interacciones tiene que dar una respuesta la cuestión cómo los datos los sensores y el estado mental actual del agente determinan la acciones y el futuro estado mental del agente distintas arquitecturas agentes existen diferentes propuestas clasiﬁcación la distintas arquitecturas agentes siguiendo wooldridge se presentan los lineamientos cuatro clases arquitecturas la cuales son ni exaustivas ni excluyentes y luego se detallan la arquitectura pr y los modelos agentes bdi basadas en la lógica agentes deductivos una forma clásica construir agentes sigue la linea tradicional ia desarrollar sistemas inteligentes basados en una representación simbólica su entorno y sus deseos que permita realizar una manipulación esta representación estos agentes toman decisiones través del razonamiento lógico basado en la coincidencia patrones y la manipulación simbólica la idea desarrollar agentes deductivos como demostradores teoremas e atractiva y se ha implementado en algunos agentes sin embargo hay algunos problemas que deben resolverse por ejemplo cómo trasladar el mundo real una descripción simbólica certera y adecuada en tiempo adecuado y la complejidad computacional los demostradores teoremas lo que pone en duda la efectividad estos mecanismos en entornos tiempos arquitecturas agentes reactivas agentes reactivos estas arquitecturas plantean diferentes alternativas al paradigma simbólico y proponen una arquitectura que actúa siguiendo enfoque conductista modelo la arquitecturas reactivas tienen modelo del mundo simbólico como elemento central la representación del conocimiento y utilizan razonamiento simbólico complejo la inteligencia y el comportamiento racional son el producto la interacción que el agente mantiene el medio y la conducta inteligente emerge la interacción varios comportamientos simple una la arquitecturas alternativas más conocida e la arquitectura subsunción brook en capas agentes híbridos muchos investigadores han argumentado que ni enfoque completamente reactivo o deliberativo e adecuado para la construcción agentes teniendo en cuenta el requisito que agente debe ser capaz comportamiento reactivo y proactivo enfoque interesante consiste en la creación sistemas separados para hacer frente estos tipos comportamientos una clase arquitecturas en la que los subsistemas deﬁnidos se organizan en capas jerárquicas y que interactúan implementa esta idea en este enfoque agente se deﬁne en términos do o más capas para hacer frente la conductas reactivas y proactivas respectivamente ejemplos la turas capas son la arquitectura ferguson touringmachines capas horizontales donde toda la capas tienen acceso los datos del entorno y realizar acciones en el entorno ferguson y muller interrap capas verticales do pasadas donde una capa tiene el acceso los datos del entorno y realizar acciones en él muller te bdi e modelo agente que decide momento momento que acción seguir en orden satisfacer los objetivos esta arquitectura incluye do agentes inteligentes te procesos deliberación en cada caso que objetivos y razonamiento la forma en que se alcanzarán dichos objetivos luego la generación los objetivos el te debe elegir uno y comprometerse alcanzarlo los objetivos que decide alcanzar son sus intenciones la cuales juegan papel crucial en el proceso razonamiento práctico la arquitectura bdi belief desire intention e una la más relevantes dentro esta línea y fue originada por el trabajo rao george rao georgeﬀ esta arquitectura está caracterizada porque los agentes tán dotados los estados mentales que representan la creencias deseos e intenciones incluyendo la correspondientes estructuras datos belief representan el conocimiento que el agente tiene sobre sí mismo y sobre el entorno desire son los objetivos que el agente desea cumplir intention se puede considerar como subconjunto seos consistentes entre sí que el agente decide alcanzar la intenciones van en la acciones que ejecutará el agente en cada momento el proceso agente bdi se ilustra en el esquema presentado en la guiente figura weiss en dicha ﬁgura además los tres componentes principales del modelo b d e aparecen otros componentes que se ben continuación conjunto creencias actuales bel función revisión creencias brf que toma la entrada sensada y el estado actual creencias del agente para determinar nuevo conjunto creencias donde el conjunto partes conjunto brf bel bel función generadora opciones generate option que determina qué opciones están disponibles para el agente sus deseos en base sus creencias e intenciones actuales opciones bel int de función ﬁltrado ﬁlter que representa el proceso deliberación del agente en la que el agente determina sus intenciones basado en sus actuales creencias deseos e intenciones filtrado bel de int int función selectora acciones action la cual determina en cada caso qué acción llevar cabo en base la intenciones vigentes ejecutar int el proceso resultante agente bdi e una función acción p la cuál para cada percepción elemento del conjunto p decide una acción del conjunto y puede deﬁnirse por el siguiente pseudocódigo function accion p p begin brf b p opciones b ﬁltrado b d return ejecutar end function arquitecturas agentes figura diagrama una arquitectura genérica agente bdi dentro los modelos agentes el modelo bdi e uno los más dido y estudiados y hay varias razones que contribuyen su importancia el lector puede ver análisis su evolución en georgeﬀ et al por lado esta arquitectura está provista componentes esenciales que le permiten abordar aplicaciones del complejo mundo real ya que suelen tar situados en entornos dinámicos e inciertos por otra parte el modelo bdi e también interesante porque se ha realizado sobre él gran zo para su formalización través la lógicas bdi rao georgef además la importancia del modelo se suscribe al marco teórico sino que se han presentado diferentes plataformas que implementan esta ra entre la implementaciones podemos mencionar por ejemplo irma intelligent resourcebounded machine architecture bratman et dmars distribute reasoning d inverno et entre otras en el modelo bdi sus distintas variantes y muchas sus implementaciones están construidas sobre lógicas estos presentan limitaciones al momento representar mundos inciertos ya que carece una forma representar una estimación acerca la incertidumbre posibilidad lidad que el mundo planteado sea el real esto ha llevado casali et proponer en modelo graduado que mejore la performance del agente utilizando grados en la actitudes mentales b d agentes razonamiento procedural pr la arquitectura pr reasoning georgeﬀ lansky fue quizás la primera arquitectura basada en el paradigma bdi esta se ha convertido en una la más conocidas y ha sido utilizada en distintas aplicaciones agente arquitectura pr trata alcanzar cualquier meta que se proponga basándose en sus creencias sobre el mundo entorno tambiénpuedesimultáneamentereaccionarantelaocurrenciadealgúnnuevo agentes inteligentes por los objetivos y dirigido por los eventos pueden ser fácilmente integrados estos sistemas consisten en conjunto herramientas y métodos para la representación y ejecución plane estos plane o procedimientos son secuencias condicionales acciones la cuales pueden ejecutarse para alcanzar ciertos objetivos o reaccionar en situaciones particulares una arquitectura pr consiste básicamente los sigunientes componentes creencias belief actuales sobre su entorno la cual e zada para reﬂejar cambios objetivos o deseo s actuales goal alcanzar plane o procedimientos que describen secuencias re acciones y pruebas que pueden realizarse para alcanzar ciertos objetivos o para reaccionar ante ciertas situaciones y intenciones que consiste conjunto ordenado cialmente todos los plane elegidos para ejecución intérprete mecanismo inferencia manipula estos componentes como se ilustra en la figura figura arquitectura agente pr en cada ciclo este intérprete recibe nuevos eventos y objetivos internos selecciona plan procedimiento apropiado teniendo en cuenta los vos eventos objetivos y creencias ubica el plan dentro la estructura intenciones grafo elije plan intención en la estructura y ﬁnalmente ejecuta paso del plan activo esto puede resultar en una acción tiva o en la formulación nuevo objetivo el sistema interactúa el entorno través su base conocimientos y la acciones básicas o primitivas la estructuras básicas agente pr pueden tener distintas representaciones dependiendo la plataforma elegida en general la lógica utilizada para la representación del conocimiento e muy similar para toda la implementaciones pr lenguajes agentes luego que se ha deﬁnido una arquitectura agente cara su mentación surgen la siguientes preguntas cómo deben programarse estos agentes cuáles deben ser la primitivas para esta tarea cómo e ble hacer que estos lenguajes provean marco efectivo se han distintos lenguajes que permite programar sistemas computacionales lenguaje para desarrollar agentes introducción jason términos los conceptos desarrollados en los distimtos modelos le agentes si bien se puede programar agentes utilizando lenguajes programación propósito general podemos destacar los siguientes jes orientados agentes shoham concurrent metatem fisher la familia pr hay una variedad lenguajes entre los que se pueden mencionar jason http jack http openprs y la familia apl http en la próxima sección se rán los componentes principales jason como ejemplo lenguaje para especiﬁcar agentes lenguaje para desarrollar agentes introducción jason en esta sección se hará una reseña los conceptos más importantes la herramienta jason http como ejemplo plataforma que permite diseñar agentes pr si bien jason puede usarse mediante su integración sistemas multiagentes como por ejemplo lizando jade http este trabajo se centrará en el portamiento individual los agentes el lenguaje interpretado por jason e una extensión del lenguaje para especiﬁcar agentes agentspeak l geﬀ lansky el cual e una extensión eﬁciente la programación lógica para sistemas bdi los tipos agentes especiﬁcados agentspeak l son referidos veces como sistemas planiﬁcación reactivos jason comparación otros sistemas para desarrollar agentes bdi posee la ventaja ser multiplataforma al estar desarrollado en el lenguaje java está disponible su código open source y e distribuido bajo la licencia gnu lgpl además interpretar el lenguaje agentspeak l original posee la siguientes características fuerte fórmulas plane falla entre agentes en la creencias del desarrollo entornos programados en java en la etiquetas o label los plane que pueden ser usadas por funciones selectoras modiﬁcadas o extendidas correr sistema multiagente distribuido sobre la red funciones selectoras funciones verdad y la arquitectura completa acciones internas esenciales internas extensibles por el usuario programadas en java arquitectura agente en agentspeak agente en agentspeak l e creado especiﬁcando conjunto cia belief y conjunto plane plan otros elementos relevantes son los objetivos goal del agente y los eventos disparadores trigger event que sirven para representar la parte reactiva agente creencias representarán la creencias del agente respecto su entorno átomo creencia belief atom e predicado primer orden los atomos creencias y sus negaciones son literales creencia belief literal conjunto inicial creencias e tan sólo una colección átomos agentes inteligentes objetivos representarán los objetivos del agente agentspeak l gue sólo do tipos objetivos goal achivement goal ytest goal estos do son predicados preﬁjados por los operadores y respectivamente achivement goal denota que el agente quiere alcanzar estado en el mundo donde el predicado asociado sea verdadero en la práctica esto lleva la ejecución subplanes y ii test goal devuelve una uniﬁcación asociada predicado en el junto creencias del agente si hay asociación simplemente falla evento disparador trigger event deﬁne que eventos pueden iniciar la ejecución plan evento puede ser interno cuando tiene que ser logrado o externo cuando e generado por actualizaciones creencias debido una percepción del ambiente hay do tipos eventos disparadores relacionados el hecho que agregan o quitan actitudes mentales creencias u objetivos estos son preﬁjados por y vamente plane son acciones básicas que agente puede realizar sobre su te estas acciones están también deﬁnidas como predicados primer orden peroconsímbolosespeciales llamadossímbolosdeacción guirlos otros predicados plan está formado por evento disparador denotando el propósito del plan seguido por una conjunción literales creencia representando contexto para que el plan sea aplicable el texto debe ser una consecuencia lógica la actuales creencias del agente el resto del plan e una secuencia acciones básicas o subobjetivos que el agente tiene que lograr o testear cuando el plan e elegido para su ejecución ejemplo plan en agentspeak l v gusta v v ocupado tel llamar v v este ejemplo representa que cuando el agente obtiene el conocimiento que concierto ase va desarrollar en el lugar v representado por v y si le gusta al agente el concierto gusta entonces drá como nuevo objetivo reservar ticket para este evento v luego cuando el objetivo e agregado la creencias del agente el plan que se activará e el siguiente si el teléfono está ocupado tel llamar v lugar reserva más otras acciones denotadas por ﬁnalizadasporelsubobjetivodeescogerlosasientos v en agentspeak l agente ag e especiﬁcado como conjunto cia b la base creencia inicial y conjunto plane p la librería plane del agente la fórmulas atómicas atdel lenguaje son predicados p tn dondepes símbolo predicado aes símbolo acción tnson términos estándar lógica primer orden unplanestá deﬁnido por p ct dondetees evento disparador ctes el contexto del plan y he una secuencia acciones objetivos o actualizaciones creencias te ctes la cabeza del plan y he el cuerpo conjunto plane está dado por pscomo una lista lenguaje para desarrollar agentes introducción jason evento disparador puede ser el agregado o eliminado una creencia o el agregado o quitado objetivo respectivamente finalmente el cuerpo del plan hpuede estar constituido por una acción tn goal la actualización la creencias para ver detalles la sintaxis del agentspeak l se puede consultar dini hübner semántica informal el intérprete agentspeak l también maneja conjunto eventos y conjunto intenciones que será la lista acciones que el agente decide ejecutar su funcionamiento requiere tres funciones selección la función selección eventos se que selecciona sólo evento del conjunto eventos una función selección opciones que selecciona plan del conjunto plane aplicables por último una función selección intenciones si estas funciones selectoras pueden deﬁnirse según el portamiento cada agente que la utilice la intenciones son cursos acciones que agente se compromete hacer para manejar cierto evento cuando evento e interno consecuencia una acción ejecutada por agente éste e acompañado por la intención que lo generó al estar el agente interactuando el ambiente través sus percepciones recibirá nuevas creencias que serán eventos externos estos eventos externos crean nuevas intenciones representando focos atención separados los eventos internos son generados por el comportamiento interno del sistema o ejecución del mismo y los externos son los eventos percibidos por los agentes la figura cómo trabaja intérprete agentspeak l figura máquina estados agente pr bordini hübner en cada ciclo interpretación agente se actualiza la creencia del agenteyconellolalistadeeventos quepudosergeneradoporunapercepción del ambiente evento externo o por la ejecución intenciones acciones lo cual produce evento interno ver en la ﬁgura se asume que la creencias son actualizadas por la percepciones la función revisión agentes inteligentes creencias e parte del intérprete pero e componente necesario la arquitectura del agente después que el selector eventos se haya seleccionado el evento el agente tiene que uniﬁcar este evento eventos disparadores en la za los plane esto genus conjunto plane relevantes sus respectivos contextos se eliminan aquellos cuyos contextos se satisfagan la base creencias del agente para formar conjunto plane cable este conjunto plane se denominan opciones estas opciones se generaron partir evento externo o interno entonces el selector opciones elige uno estos plane luego pone este plan alguna intención existente si el evento fue interno o crea una nueva intención si el evento fue externo todo lo que queda al agente e seleccionar una intención para ser tada en el ciclo la función selección intenciones si se encarga esto la intención incluye plan y la primer fórmula e tomada para su ejecución jason presenta mejoras respecto la sintaxis agentspeak l siempre se deberá tener en cuenta que el estado agente lo largo su ciclo vida está representado por conjunto creencias belief y conjunto plane plan y su comportamiento estará reﬂejado en el la funciones selectoras una la diferencias m ás importante que distingue jason la sintaxis agentspeak l e la inclusión la anotaciones tanto en la creencias como en los plane la anotaciones en la creencias permiten introducir por ejemplo información sobre la fuente la información grado creencia por ejemplo se puede crear una creencia que sea x mianotacion la anotaciones en los plane pueden ser usadas para dar la relevancia del plan modo ordenar la ejecución los plane aplicables acuerdo su relevancia también son válidas en jason fórmulas atómicas p tn tn una negación fuerte la negación por falla e usada en los textos los plane y se denota por precediendo literal el contexto e por lo tanto una conjunción literales los términos en jason pueden ser variable listas estilo prolog como también números enteros punto ﬂotante o string como en prolog los operadores relacionales jos son permitidos en los contextos plan y e usada como variable anónima enjasonlasfórmulasatómicaspuedenconteneranotaciones representados por una lista términos encerradas en corchetes inmediatamente siguiendo una fórmula dentro una base creencias belief la anotaciones son usadas por ejemplo para registrar la fuentes la información o para presentar valor asociado al grado creencia belief degree que esa fórmula e cierta debidoalasanotaciones se intenta uniﬁcar una formula atómica anotaciones s conotrafórmulaatómica s nosolamente que s debe estar incluido s si por ejemplo en contexto plan y la base belief solamente uniﬁcar que toda la listas términos la anotación asociada ser corroboradas por la anotación asociada lenguaje para desarrollar agentes introducción jason como caso más general además que agente esté representado por conjunto belief iniciales y conjunto plane los agentes pueden contener goal iniciales que pueden aparecer entre los belief iniciales agente los goal iniciales se representan como belief preﬁjo y pueden contener variable otro cambio sustancial jason e que la base belief puede contener reglas estilo prolog y la misma sintaxis usada en el cuerpo una regla puede ser usada en el contexto los plane los operadores y en los cuerpos los plane son usadas para poner o sacar creencias que trabajan como notas mentales del agente mismo el operador agrega una creencia después remover si existe la primer ocurrencia la misma en la base belief por ejemplo primero remueve y agrega la variable pueden ser usadas en lugares donde una formula atómica e esperada incluyendo eventos disparadores contextos y cuerpos los plane en el contexto o el cuerpo plan también se puede ubicar una variable en vez una formula atómica pero manteniendo la anotaciones explícitas observar los siguientes ejemplos uniﬁcación sea x una variable y p una constante x b c p b c d uniﬁcan y x e p p b x b c uniﬁcan y x e p x b p uniﬁcan pues b está incluido en los plane tienen etiquetas representados por una queta plan puede ser cualquier fórmula atómica incluyendo ne la anotaciones dentro la etiquetas o label plan pueden ser utilizadas para la implementación funciones selectoras para plane más complejos finalmente la acciones internas pueden ser usadas tanto en el contexto mo en el cuerpo plan cualquier símbolo acción empezando o conteniendo denota una acción interna la mismas son acciones deﬁnidas por el usuario la cuales son ejecutadas internamente por el agente se minan internas para marcar una distinción la acciones que aparecen en el cuerpo plan que denotan la acciones que agente puede realizar para cambiar el entorno compartido caso estudio se presenta caso estudio que muestra el potencial esta plataforma para el desarrollo agentes se desea modelar agente supervisor horno rotativo utilizado para la fundición metales el horno además posee motor que le permite girar lentamente alrededor su eje principal este tipo hornos e utilizado para la fundición cobre latón bronce y aluminio el agente deberá analizar constantemente tres variable fundamentales en la operación del horno del horno los gas en el interior del horno del motor rotación para esta tarea se cuenta tres sensores estratégicamente situados en este contexto se implementará agente supervisión que contará agentes inteligentes lecturas los tres sensores y partir la mismas deberá tomar acciones lossensoresabasteceránalagentedecreenciassobre la lecturas y sus grados certeza asociados los cuales dependerán la precisiones los instrumentos utilizados estas precisiones pueden variar acuerdo al rango valores la variable en los cuales el horno esta trabajando en base la lecturas los sensores y la acciones preventivas se modelarán los plane del agente en momento tiempo el horno se encuentra trabajando una temperatura grados creencia una presión bar y nivel vibración los hechos sensados ingresarán acuerdo la sincronización los lectores el agente además posee acciones supervisión acuerdo la lecturas los sensores encender el ventilador para que el horno comience enfriarse esta acción se encuentra modelada en el plan alerta temperatura si la temperatura supera los grados el horno comienza operar en estado crítico temperatura por lo cual se debe apagar el horno para lograr enfriamiento total esta acción se encuentra modelada en el plan urgencia temperatura y posee mayor relevancia que el plan para el caso la variable presión si la lectura supera los bar se deberá cerrar una válvula inyección del horno plan y si la presión supera los bar se deberá encender una alarma general dado el peligro explosión en el horno y se deberán tomar medidas precaución plan la falla presión son la causa más frecuentes accidentes por lo cual el control esta variable e la más relevante para este sistema horno también se deberá supervisar el trabajo del motor rotación del horno cierta cantidad tiempo trabajo empieza sufrir el desgaste sus piezas por lo cual comienza producir nivel elevado vibración para evitar una rotura inminente del motor nivel superior vibración se procede el frenado del mismo plan elagente supervisor se especiﬁcará en jason mediante una base cia y conjunto plane iniciales creencias plane t em p tem p t em p tem p p re pres p re pres n v l n v l lenguaje para desarrollar agentes introducción jason la creencias del agente generan el conjunto eventos y los plane iniciales forman la librería plane del agente los eventos se evalúan en el orden que ingresan en el sistema los principales pasos la ejecución para este ejemplo se resumen en se tomará el evento generado partir dado que la selectora eventos toma el primero el evento uniﬁca los eventos disparadores los plane y lo cual los convierte los mismos en relevantes los plane y uniﬁcan el contexto contra lo cual se generan do opciones partir los plane laselectoradeopcionesseleccionarálaprimeraopciónqueeslagenerada por y se crea una intención se ejecuta la acción la intención generada partir se selecciona el segundo evento que e el generado partir el evento uniﬁca los eventos disparadores los plane y lo cual los convierte en relevantes los plane y uniﬁcan el contexto contra lo cual se generan do opciones partir los plane la selectora seleccionara la opción por ser la primera y se crea una intención se tomará el evento generado partir el evento uniﬁca el evento disparador y lo convierte en vante el plan uniﬁca el contexto contra y se agrega los plane bles la selectora opciones toma la primera entre la opciones luego para este caso el orden la acciones resultantes ejecutar por el agente e dado el orden sincronización los sensores se ejecutó la acción nada la variable temperatura primero por ser la que primero ingresó al conjunto creencias del agente luego se trató el sensor depresión y por último el vibración además se ejecutó ante el plan para el horno sobre siguiendo el orden ejecución los plane en el jason que por defecto respeta el orden los plane en la librería otras estrategias se puede alterar este orden por ej utilizando grados relevancia los plane en la anotaciones continuación se muestra la traza la ejecución este ejemplo en jason agentes inteligentes sistemas multiagentes los agentes operan en algún entorno que suele ser tanto computacional como físico por ejemplo agente recomendador en la web o robot que se desplaza en hospital el entorno puede ser abierto o cerrado y suele tener más agente si bien hay situaciones donde agente puede rar solo creciente número sistemas están siendo vistos en término sistemas multiagentes compuestos por agentes autónomos que interactúan entre sí aplicaciones orientadas los agentes se han utilizado en distintos dominios como sistemas comercio electrónico sistemas gestión cesos distribuidos sistemas control tráﬁco en gran parte esto se debe que el paradigma sistemas multiagentes ofrece conjunto ceptos y técnicas para modelar diseñar e implementar sistemas distribuidos complejos por otra se debe que los sistemas computos operan cada vez más en forma distribuida y en múltiples dispositivos además la información también suele estar distribuida siguiendo el paradigma la ingeniería software orientada agentes agent oriented software jennings estos ma pueden desarrollarse como organizaciones agentes denominados temas multiagentes ma system donde cada agente tendrá su funcionalidad e interactuarán unos otros y el entorno en el cuál habitan e necesario entonces analizar propiedades del entorno para que los agentes puedan operar efectivamente e interactuar unos otros nientemente los entornos proveen una infraestructura computacional para que la interacciones se puedan realizar hay que considerar los protocolos comunicación y interacción que utilizarán los agentes los protocolos comunicación permiten los agentes intercambiar y der mensajes actualmente el lenguaje comunicación entre agentes fipa acl e considerado estandar por otra parte los protocolos ción permiten los agentes tener conversaciones que serán intercambios mensajes estructurados para dar ejemplo concreto estos conceptos protocolo comunicación puede especiﬁcar que los siguienetes tipos mensajes pueden ser intercambiados entre do agentes curso acción una acción una acción una acción en desacuerdo una acción una contrapropuesta acción partir estos tipos mensajes la siguiente conversación puede darse entre do agentes y como una instancia una interacción para la negociación agentes le propone curso acción evalúa la propuesta y una aceptación o una contrapropuesta o desacuerdo o sistemas multiagentes características los sistemas multiagentes algunas la características más relevantes considerar en los ma son la siguientes sistemas multiagentes proveen una infraestructura que especiﬁca los protocolos comunicación y interacción entre agentes entornos multiagentes suelen ser abiertos y suelen tener diseño centralizado agentes autónomos y que pueden tener intereses propios o ser cooperativos pueden tener una meta común o metas independientes si grupo agentes comparte una meta global suelen denominarse colaborativos por equipo futbol en cambio si tienen distintas metas generalmente opuestas suelen ser competitivos por ej agentes do equipos futbol que se enfrentan conocimientos sobre el problema y la posibles ne elconocimiento global que cada agente tiene puede incluir control global consistencia global metas globales que conjunto agentes pueda desarrollar una actividad junta en entorno compartido debe existir algún tipo coordinación la cual puede ser muy compleja en grupo agentes cooperativos puede utilizarse planiﬁcación tareas y en escenario competitivo pueden negociarse propuestas además estas características para que agente o sociedad agentes pueda tener una buena performance e necesario analizar el entorno en que se encuentra análisis detallado la distintas propiedades del entorno tener en cuenta se presenta en russell norvig y una breve cripción e la siguiente en entorno accesible los sensores proporcionan toda la información relevante del entorno para el agente deterministas en entorno determinista el estado guiente puede obtenerse partir del actual y la acciones del agente episódicos en entorno episódico la experiencia del agente está dividida en episodios independientes entorno dinámico puede sufrir cambios mientras el agente está razonando discretos v continuo en entorno discreto existe número concreto percepciones y acciones claramente deﬁnidos comunicación si do agentes van comunicarse sobre algún tema en particular e necesario que ellos acuerden sobre la terminología dicho dominio la alternativa que se plantea e utilizar ontologías como una deﬁnición formal cuerpo conocimiento conformadas por especiﬁcaciones conjunto términos el ﬁn proveer una base común entendimiento sobre dominio en particular por otra parte la comunicación e tema relevante importancia en ciencias la computación y muchos formalismos se han desarrollado para representar la propiedades comunicación en sistemas concurrentes donde e necesario sincronizar distintos procesos como son los agentes en general los agentes pueden forzar otros agentes realizar acciones lo que agentes inteligentes pueden realizar son acciones comunicación speach act la intención inﬂuenciar otros apropiadamente por ejemplo si agente le comunica otro que e día cálido en buenos aire querrá inﬂuenciar la creencias del otro agente modo que él incorpore ese conocimiento su base la teoría actos del habla trata la comunicación como ciones y que al igual que otras acciones dependen la intenciones los agentes cohen levesque kqml e lenguaje basado en sajes para la comunicación agentes mensaje puede verse como objeto donde cada mensaje tiene una performativa que puede pensarse mo la clase objeto y número parámetros pares que puedenverse comoinstancias devariables laaceptación deeste lenguaje por parte la comunidad ma fue importante sin embargo tuvo algunos problemas que llevó al consorcio fipa foundation intelligent physical system http al desarrollo lenguaje muy cercano fipa agent communication language acl la principal diferencia entre el lenguaje fipa acl y kqml e el conjunto performativas que proveen y que está provisto una semántica formal ejemplo mensaje en este lenguaje e el siguiente inform sender receiver content price language sl ontology para facilitar el rápido desarrollo sistema multiagente usando fipa acl se han generado varias plataformas que soportan este protocolo municación la ma conocida y utilizada e jade agent development http esta plataforma provee paquetes y herramientas para que desarrolladores java puedan crear sistemas te en concordancia fipa coordinación para que los agentes que integran ma puedan realizar alguna actividad en entorno compartido e necesaria algún tipo coordinación sus comportamientos y actividades en agentes la coordinación suele ser una cooperación que hace necesaria una planiﬁcación distribuida o centralizada mientras que entre agentes competitivos o que tienen intereses individuales en agentes colaborativos que tienen que intercambiar recursos para lograr sus objetivos la distintas formas interacción se analizará continuación la negociación ya que ha ganado gran interés en este último tiempo por ser aspecto fundamental en distintos sistemas multiagentes negociación en jennings et se la negociación como una forma interacción en la que do o más agentes que tienen diferentes intereses intentan encontrar compromiso o consenso sobre algún asunto los tore consideran que la investigación en el área debe tratar los sistemas multiagentes tres temas fundamentales el objeto negociación que e asunto por el cual se negocia por ej el precio producto la fecha o el lugar una reunión el protocolo negociación que está conformado por la glas que gobiernan la interacción por ej subastas holandesas inglesas y los modelos toma decisiones que describen el comportamiento los participantes también aﬁrman que la negociación puede ser vista como una búsqueda distribuida sobre espacio potenciales acuerdos entre la partes la dimensión y la topología este espacio son determinadas por la estructura del objeto negociación y del protocolo utilizado la negociación automática tiene impacto directo en distintas aplicaciones entre la que se destaca el comercio electrónico desde subastas donde se negocian asuntos simple por ej el precio producto hasta negociaciones más complejas donde se discuten varios asuntos por ej garantía forma pago tiempos otra aplicación relevante la negociación e en problemas cación donde se deben asignar tareas recursos ejemplo sistemas que negocia e cognitor http sistema mo que automatiza la negociaciones clientes disconformes que realizan quejas una empresa en la literatura que trata la negociación la noción recursos e muy ral los recursos pueden ser distinto tipo por ejemplo cuadro valioso el derecho explorar área en busca mineral una cantidad ciclos del procesador una pc el tiempo entrega una mercadería el nocimiento para llevar adelante una tarea una característica tener en cuenta respecto los recursos e que estos suelen ser escasos y demandados por uno o más agentes los principales enfoques negociación automatizada en los sistemas multiagente pueden agruparse en la siguientes clases pale según su enfoque jennings basados en teoría juegos basados en heurísticas y basados en argumentación continuación se describen sus características fundamentales negociación basada en teoría juegos la teoría juegos e una rama la economía que estudia la estrategias e interacciones entre agentes que intentan maximizar su propia utilidad en base los movimientos que pueden realizar y la utilidad que reciben luego que se realizan los movimientos en teoría juegos se intenta determinar la estrategia óptima analizando la interacción juego participantes idénticos dado escenario negociación particular que involucre agentes negociación la técnicas teoría juegos pueden ser aplicadas para resolver do problemas claves el diseño protocolo apropiado que gobernará la interacciones entre los agentes participantes y el diseño la estrategias modelo decisión del agente do desventajas al aplicar este enfoque por lado la estrategias que dan mejores resultados en la teoría tienden ser computacionalmente intratables y por lo tanto pueden aplicarse al desarrollo agentes concretos por otra parte la teoría considera que el espacio resultados e completamente conocido lo que suele ocurrir en escenarios realistas ya que mucha mación se puede obtener durante el proceso negociación ejemplos este enfoque se puede ver en rosenschein negociación basada en heurísticas el objetivo atacar la limitaciones computacionales han emergido los enfoques negociación basados en agentes inteligentes rísticas la heurísticas son reglas generales que producen buenos resultados en contextos donde la suposiciones son relajadas en este tipo enfoque la estrategias están determinadas por heurísticas que permiten realizar una búsqueda exhaustiva en el espacio negociación mientras los métodos heurísticos pueden superar algunas la deﬁciencias los enfoques do en teoría juegos sufren algunas desventajas la primera e que la soluciones son subóptimas y la segunda e que los modelos necesitan una evaluación empírica faratin negociación basada en argumentación abn sibienlosenfoquesanteriores son adecuados para resolver gran rango problemas en estos modelos negociación los agentes sólo pueden intercambiar potenciales acuerdos puestas y pueden intercambiar otra información adicional esto puede ser problemático cuando el agente tiene información parcial del entorno o sus decisiones dependen la decisiones los otros agentes además otra limitación que presentan los enfoques anteriores e que la utilidades o ferencias los agentes se suponen completamente caracterizadas ante la interacción y cambian durante la negociación situaciones más complejas donde la información e incompleta responden esta caracterización los enfoques basados en argumentación permiten superar estas deﬁciencias en el contexto la negociación basada en argumentación argumento e una pieza información que permite agente justiﬁcar su postura negociación o inﬂuenciar la postura otro agente los argumentos que la propuestas además ser simplemente aceptadas o rechazadas también puedan ser criticadas esta manera la negociación puede ser más eﬁciente ya que la contraparte puede tener una mejor posición para zar una oferta diferente si bien existe consenso sobre los elementos que caracteriza framework negociación basado en argumentación en rahwan se menciona que deben considerarse algunos aspectos no e internos los agentes entre los elementos externos los agentes se destacan los siguientes el lenguaje comunicación que permite expresar propuestas críticas creencias preferencias objetivos ii el lenguaje dominio que permite expresar información del dominio relevante color rantía forma pago iv el protocolo negociación compuesto por la reglas que regulan la comunicación v la base información riodonde se mantiene información importante para la negociación historial del diálogo reputación los participantes por otro lado los elementos internos los agentes corresponden la nalidades que deben realizar los agentes basados en argumentación través una arquitectura adecuada la funcionalidades que estos autores citan son interpretar la locuciones entrantes evaluar los argumentos actualizar el estado mental generar argumentos candidatos seleccionar argumentos didatos y generar la locución salida escenario negociación cooperativa escenario tıpico negociación involucra do agentes cooperativos que poseen recursos y tienen la necesidad realizar intercambio para zar sus objetivos además los agentes pueden tener creencias incompletas o erróneas sobre el oponente para acordar cuales recursos trocar establecen una comunicación en donde se ofrecen propuestas posibles o intercambios y se responden críticas y contrapropuestas el rumbo la comunicación sistemas multiagentes cambiando en la medida que los agentes revelan los recursos que poseen y la características estos modelo negociación automática basada en argumentación para agentes intencionales que quieren negociar en este tipo escenarios se presenta en pilotti et al continuación mostraremos ejemplo diálogo entre do agentes que negocian siguiendo una variante ejemplo la literatura ejemplo sean do agentes benevolentes y los cuales se ilustran en la siguiente figura el agente tiene como objetivo colgar cuadro y tiene como recursos tornillo destornillador y martillo el tiene el conocimiento como colgar el cuadro clavo y martillo y además conoce como colgar espejo tornillo y destornillador por su parte el tiene como objetivo colgar espejo tiene clavo y el conocimiento cómo colgar espejo clavo y martillo ninguno los do agentes puede lograr su objetivo sus propios so y conocimento necesitan intercambiar elementos conocimiento para lograrlo utilizando agentes intencionales que siguen modelo ción que utiliza revisión creencias se puede obtener este diálogo entre los agentes través del cuál alcanzan negociar intercambio recursos la orepresentan el knowhow cómo ciertos recursos por y se puede lograr el objetivo o te propongo que proveas clavo porque uso martillo clavo martillo colgarcuadro puedo lograr corgarcuadro cambio tornillo te propongo que proveas colgarespejo porque uso puedo lograr colgarespejo cambio clavo te propongo que proveas clavo porque uso martillo clavo martillo colgarcuadro puedo lograr cuadro cambio tornillo destornillador tornillo destornillador colgarespejo acepto te doy clavo y da tornillo destornillador tornillo destornillador colgarespejo encontrar distintos modelos negociación colaborativa o competitiva que tengan sustento teórico pero puedan llevarse modelo computacional eﬁciente para ser aplicados en sistemas multiagentes e campo abierto agentes inteligentes investigación bibliografía continuación se presenta la bibliografía que se ha referenciado en el pítulo y otras citas donde los lectores pueden ampliar algunos los temas desarrollados bergenti gleizes zambonelli f ed methodology software engineering agent system handbook software engineering kluwer academic publishing new york ny july bordini hübner system agentspeak using jason john wiley son bratman israel pollack plan practical reasoning computational intelligence casali agradedbdiagentmodeltorepresentand reason artiﬁcial intelligence special issue preference artiﬁcial intelligence cohen levesque speech act rationality proceeding acl proceeding annual meeting association computational linguistics pp stroudsburg pa usa dennet intentional stance mit press cambridge ma d inverno kinny luck wooldridge formal speciﬁcation dmars intelligent agent iv proceeding fourth international workshop agent theory architecture language ed singh rao wooldridge montreal tiation international conference multiagent system boston ma ferguson touringmachines architecture dynamic rational mobile agent phd thesis clare hall university cambrage uk ding sixth national conference artiﬁcial intelligence seattle wa georgeﬀ pell pollack tambe wooldridge model agency muller singh rao ingrand oprs development environment ingrand georgeﬀ rao architecture real time reasoning control ieee expert jennings faratin lomuscio parson sierra dridge automated negotiation prospect method challenge ternationaljournal ofgroup decisionandnegotiation jennings sycara wooldridge roadmap agent research development autonomous agent system maes agent netword architecture ana sigart bulletin luck mcburney preist agent technology enabling bibliografía http muller cooperation model autonomous agent muller wooldridgde jennings ed intelligent agent iii lnai volume springer berlin based negotiation cooperative agent proceeding tion system workshop argmas peter mcburney simon parson iyad rahwan ed pp valencia españa junio rahwan ramchurn jennings mcburney parson sonenberg negotiation knowl eng rev vol p rao bdiagents international conference system pp rosenschein zlotkin rule encounter mit press jennings software engineering artiﬁcial intelligence russell norvig artiﬁcial intelligence modern approach edition prentice hall englewoods cliifs nj weiss weiss g ed multiagent system modern approach distributed artiﬁcial intelligence mit press wooldridge m jennings intelligent agent theory practice knowledge engineering review wooldridge introduction multiagent system edition john ley son eliana scheihing universidad autral chile chile concepto aprendizaje en la actualidad gracias los avances la informática e posible almacenar y procesar grandes cantidades datos así como acceder datos ubicados físicamente en otras localidades geográﬁcas través la redes nales en este contexto aparece el concepto aprendizaje en informática minado también aprendizaje máquina o automático que corresponde programas computacionales que buscan optimizar los parámetros delo usando datos previos o datos entrenamiento los modelos pueden ser inductivos cuando permiten hacer predicciones sobre el futuro o bien criptivos cuando permiten generar conocimiento partir los datos el aprendizaje automático usa la teoría estadística para construir modelos matemáticos pues esta manera e posible hacer inferencias partir una muestra la ciencia la computación e requerida en la fase namiento para la implementación algoritmos optimización eﬁcientes además ser necesaria en la tareas almacenamiento y procesamiento grandes volúmenes datos una vez que modelo e ajustado se requiere también eﬁciencia en su representación y solución algorítmica para la fase inferencia la minería datos e el concepto acuñado en el mundo del negocio ra la aplicación del aprendizaje automático en grandes volúmenes datos el objeto extraer información los mismos aplicaciones minería datos se han extendido diversas áreas como por ejemplo el estudio del comportamiento consumo los clientes supermercado en ﬁnanzas bancarias los datos históricos se utilizan para construir modelos riesgo créditos detección fraudes entre otros en el área manufactura los modelos aprendizaje se utilizan para optimización control y resolución problemas en medicina existen aplicaciones para el diagnóstico médico en telecomunicaciones los patrones llamadas son analizados para ción y maximización la calidad servicio en ciencia grandes volúmenes datos se pueden analizar también estas introduccion al aprendizaje los algoritmos reconocimiento patrones son otro ejemplo aplicación del aprendizaje automático para solucionar problemas visión miento discurso y robótica los algoritmos aprendizaje automático se pueden clasiﬁcar en do y supervisados el aprendizaje supervisado corresponde la situación en que se tiene una variable salida ya sea cuantitativa o cualitativa que se desea predecir basándose en conjunto características se establece modelo que permite relacionar la características la variable salida luego se considera conjunto datos entrenamiento en los cuales se observan tanto los valores la variable salida como la ca para determinados individuos persona u otros usando tale datos se ajustan los parámetros del modelo lo cual e posible predecir valores la variable salida para nuevos individuos este proceso ajuste del modelo se denomina aprendizaje supervisado puesto que e proceso aprendizaje guiado por los valores la variable salida el aprendizaje supervisado corresponde la situación en que existe conjunto datos que contienen diversas características determinados dividuos sin que ninguna ellas se considere una variable salida que se desee predecir en este caso la tarea aprendizaje e describir como están organizados los datos posibles asociaciones entre ellos o agrupamientos aprendizaje supervisado el objetivo del aprendizaje supervisado e la predicción dado el valor vector entrada x generar una buena predicción ˆy la salida y primer ejemplo la regresión lineal dado el vector entradas xp predecir la salida y el modelo si se incluye la constante en x el modelo queda aprendizaje supervisado aquí y e escalar si y e vector dimensión k entonces x sería una matriz dimensión pxk en el espacio x ˆy representa perplano si la constante se incluye en x entonces el hiperplano pasa por el origen f x e una función lineal y en consecuencia x e el vector que apunta en dirección perpendicular al plano procedimiento entrenamiento método mínimos cuadrados n observaciones minimizar la suma los cuadrados los errores rss β iβ o manera equivalente en notación vectorial rss β t donde yn x conyila salida la observación cuyos datos entrada son xip esta función cuadrática siempre tiene mínimo global aunque mente único derivando respecto βse construyen la ecuaciones male xt sixtxes entonces la solución única e xtx el valor ajustado dada una entrada x e ˆy x la superﬁcie e caracterizada por la siguiente introduccion al aprendizaje el problema la clasiﬁcación uno los problemas clásicos que abordan los algoritmos aprendizaje pervisado e la clasiﬁcación consideremos el siguiente ejemplo supongamos que se disponen datos que consisten do variable entrada y y una variable salida do valores ó clasiﬁcador lineal una estrategia aprendizaje sería ajustar una regresión los datos entrenamiento ˆy x y luego deﬁnir como criterio clasiﬁcación c x en la figura se ha considerado el ajuste una regresión para datos la naturaleza del ejemplo en dónde se ha codiﬁcado en rojo los datos cuya variable salida toman el valor y verde cuando el valor e la línea rectum corresponde al criterio clasiﬁcación para valores entrada que se ubiquen en el plano sobre la línea rectum el clasiﬁcador predice una salida valor y en caso contrario el valor que predice e los círculos rojos y verdes corresponden los datos los cuales se ha entrenado el algoritmo e decir los cuales se ha realizado el ajuste la regresión y como se observa en la ﬁgura varios los datos miento resultan mal clasiﬁcados círculo verde en zona roja o círculo rojo aprendizaje supervisado figura clasiﬁcador lineal para do variable entrada y una variable salida dicotómica zona verde si bien esta estrategia e simple resulta en muchos datos mal clasiﬁcados si el problema e lineal los k vecinos más cercanos knn este algoritmo hace suposiciones sobre la relación entre la variable entrada y salida si que estima el valor la variable salida en ción los k vecinos más cercanos respecto la variable entrada el estimador tiene la forma ˆy x x yi dondenk x e el conjunto k puntos más cercanos x entre los datos entrenamiento y toma el promedio sus salidas para predecir el clasiﬁcador queda nuevamente como c x x x en la figura se ha considerado el ajuste knn para los datos do previamente do valores k y en este ejemplo e claro que disminuye el número datos mal clasiﬁcados respecto del ajuste una regresión pero al aumentar el número vecinos se genus clasiﬁcador poco robusto que e muy sensible nuevos introduccion al aprendizaje figura clasiﬁcador knn para do variable entrada y una variable salida dicotómica resultados para y respectivamente comparación los do enfoques bibliografía alpaydin ethem introduction machine learning mit press segunda edición james witten hastie y tibshirani introduction statistical learning application series springer text tistics hastie trevor tibshirani robert y jerome friedman element statistical learning data mining inference prediction series ger series statistic segunda edición russell stuart y peter norvig inteligencia artiﬁcial enfoque derno bibliografía mínimos cuadrados k vecinos más cercanos knn número parámetros p ticasnúmero parámetros donde n observaciones poca varianza robusto mucha varianza e robusto muy sesgado depende condiciones muy restrictivas escasosesgo requieresupuestosmínimos útil cuando datos provienen ciones normales bivariadas te y distinta medium para cada cuando datos provienen una cla varias distribuciones normales varianza pequeña y medias también buidas normales mezclas diferentes para cada yván jesús túpac valdivia universidad católica san pablo perú el objetivo una optimización global e encontrar los mejores elementos posibles conjunto x que siga criterio f fn estos criterios son expresados como funciones matemáticas f x que en el área optimización se suelen denominar funciones objetivo o funciones costo que son deﬁnidas continuación deﬁnición función objetivo una función objetivo f x donde r e una función matemática para ser optimizada la imagen y la función objetivo suele ser subconjunto del los números real o sea y al dominio x la función f se le denomina espacio problema ser representado computacionalmente por cualquier tipo elemento aunque principalmente como listas o vectores cabe tacar que la funciones objetivo se limitan ser expresiones matemáticas sino que pueden estar compuestas por ecuaciones o algoritmos complejos que para calcularse necesiten múltiples simulaciones así la optimización global debe comprender toda la técnicas analíticas y analíticas que puedan usarse para encontrar los mejores elementos x acuerdo la función en resumidas cuentas la optimización consiste en buscar y encontrar la lución ó soluciones optimas determinado problema tomando en cuenta determinadas restricciones como ejemplos podemos citar la rentabilidad negocio gastos multas o pérdidas la eﬁcacia determinado proceso para poder encajar problema cualquiera la vida real como problema optimización e necesario identiﬁcar la siguientes entidades el problema sus características restricciones y variable la variable decisión x xn del problema cuyos valores uyen en la solución la función f x que calcula la calidad la solución función optimizacion y heurísticas método algoritmo o heurística búsqueda soluciones el espacio soluciones válidas x discreto o continuo del problema los recursos computacionales necesarios para implementar el proceso la función evaluación o simulación tratamiento características del problema y selección la mejor solución deﬁniciones en optimización como fue mencionado ante el objetivo del problema optimización e contrar la soluciones optimas determinado problema e decir la mejor solución posible entonces vale la pena deﬁnir la características que hacen una solución optimum deﬁnición espacio problema el espacio problema para blema optimización denotado por x e el conjunto que contiene todos los elementos x que podrían ser la solución encontrar la mayoría veces este espacio x está sujeto restricciones lógicas que indican elementos x que pueden ser soluciones como una división entre cero o mero negativo al sacar raiz cuadrada restricciones prácticas que no limitan el espacio problema por otante ﬂoat o double que tienen precisión limitada deﬁnición candidato solución candidato solución x e mento valido del conjunto x para dado problema optimización deﬁnición espacio soluciones se deﬁne el espacio soluciones s como la unión toda la soluciones problema optimización como se ve en la ecuación el espacio soluciones contiene pudiendo ser igual al conjunto optimo global x pueden haber soluciones válidas x que son parte x lo que suele ocurrir en optimización restricciones deﬁnición espacio búsqueda el espacio búsqueda problema optimización denotado por g e el conjunto todos los elementos g g que pueden ser procesados por los operadores búsqueda así g e una codiﬁcación del espacio problema x funciones único objetivo cuando se optimiza único criterio f x optimo e máximo o nimo dependiendo si se está maximizando o minimizando por ejemplo funciones único objetivo problemasdemundoreal demanufactura sebuscaporlogeneralminimizar tiempos costos o pérdidas para determinado proceso por otro lado tándose negocios se busca maximizar la rentabilidad o el valor económico la ﬁgura muestra una función f deﬁnida en espacio x elementos x se hace destaque en el gráﬁco los óptimos locale y óptimos globales optimo global e el optimo en todo el conjunto mientras que optimo local e optimo solo en subespacio figura ejemplo función f óptimo global y local máximo local sea una función objetivo f x se deﬁne máximo local x como valor entrada que cumple f x ˆl x para todo x dentro una vecindad x ˆl si f se puede decir que f x ˆl x mínimo local sea una función objetivo f x se deﬁne mínimo local x como valor entrada que cumple f x x para todo x dentro una vecindad x si f se puede decir que f x x óptimo local sea una función objetivo f x se deﬁne óptimo local x optimizacion y heurísticas máximo global sea una función objetivo f x se deﬁne máximo global como valor entrada que cumple f ˆx x mínimo global sea una función objetivo f x se deﬁne mínimo global como valor entrada que cumple f x óptimo global sea una función objetivo f x se deﬁne óptimo global como valor entrada que cumple ser máximo o mínimo global e común encontrar más máximo o mínimo globales inclusive dentro del dominio x una función unidimensional f x ejemplo esta situación e la función coseno co x donde x x que tiene valores máximos globales en ˆx cuando ˆx valores mínimos globales cuando la solución correcta sería conjunto x entradas y mínimo o máximo aislado además el signiﬁcado óptimo depende del problema optimización objetivo signiﬁca máximo o mínimo global optimización existen varias estrategias para deﬁnir el óptimo conjunto óptimo se deﬁne el conjunto óptimo x como el conjunto que contiene todos los elementos óptimos por lo general son varias y muchas veces inﬁnitas soluciones óptimas pero dada la limitaciones computación se pueden encontrar subconjunto ﬁnito soluciones óptimas así se establece una diferencia entre el x ideal y el conjunto x sub óptimos que puede contener óptimo global este conjunto x e lo que algoritmo real optimización puede encontrar entonces podemos aﬁrmar que algoritmo ción tiene como tarea encontrar soluciones que sean lo mejor posibles para el problema y que por su vez sean lo más diferentes entre sí optimización clásica en la optimización clásica u optimización numérica se busca encontrar el valor la variable una función univariada x que maximize o minimize una determinada función f x este problema optimización genérico optimización clásica deﬁnido la siguiente manera sea la función f x el problema consiste en hallar y máx mín f x sujeto la siguientes condiciones x p hj x j n donde e el espacio problema que e subespacio rnque contiene los puntos factibles o sea puntos que satisfacen la restricciones del problema e punto en el espacio problema deﬁnido como x xn componentes xn son la denominadas variable decisión del problema f x e la función objetivo e decir la que se quiere optimizar restricciones dominio deﬁnidas como los límites n relacionados los valores mínimos y máximos la variable xi do en el espacio restricciones igualdad deﬁnidas como el conjunto tamaño p gi x p restricciones desigualdad deﬁnidas como el conjunto tamaño q hj x optimizacion y heurísticas convexidad espacio convexo sea el espacio problema se dice que x e convexo si para todo elemento y para todo se cumple que f f la interpretación la ecuación e la siguiente x e convexo si para do puntos cualesquiera el segmento rectilíneo que une estos tos también pertenece al conjunto en otras palabras x e convexo si se puede ir cualquier figura espacios convexos y convexos punto inicial cualquier punto ﬁnal en línea rectum sin salir del espacio los conjuntos la ﬁgura son convexos mientras que los la ﬁgura lo son el objetivo cualquier técnica optimización e hallar el bal cualquier problema lamentablemente sólo en casos muy limitados se puede garantizar convergencia hacia el óptimo global por ejemplo para problemas espacios búsqueda x convexos la condiciones tucker kuhn tucker son necesarias y suﬁcientes para garantizar optimalidad global punto en problemas optimización lineal estas condiciones son te por lo que en este caso cualquier técnica usada puede encontrar óptimos locale sin garantizarse la convergencia hacia el óptimo global sólo se tiza esta convergencia usándose métodos exhaustivos o está existe en tiempo inﬁnito existe una clase especial problemas optimización que son también mucho interés se trata del caso en que la variable decisión son discretas e decir el vector x está compuesto por valores xi y x e producto cartesiano o una permutación valores xi este tipo problemas do como optimización combinatoria o programación enteron son mucho interés en el área ciencias computación cuyo ejemplo más conocido e el problema del vendedor viajero travelling salesman problem tsp técnicas clásicas optimización técnicas clásicas optimización existen muchas técnicas largamente conocidas y aplicadas para solucionar problemas optimización siempre que estos satisfagan ciertas ca especíﬁcas como por ejemplo que f x sea una función lineal o que sea o que la restricciones sean lineales la importancia saber al menos la existencia estas técnicas está en que si el problema solucionar se ajusta la exigencias que estas nen se necesario usar heurísticas por ejemplo si la función e lineal el método simplex siempre seguirá siendo la opción más viable optimización lineal método simplex la idea básica la optimización lineal consiste en buscar una solución válida que mejore la función objetivo tomando como partida una solución válida inicial el problema programación lineal consiste en minimizar el producto terno mínz ctx sujeto la siguientes condiciones ax b donde r m dado el conjunto s x ax b x cualquier punto xi e una combinación lineal convexa sus puntos extremos o vértices más una combinación lineal positiva sus direcciones extremas arista optimización lineal para optimización lineal hay métodos directos como la búsqueda riaymétodosindirectoscomoelmétododelgradienteconjugado una la principales limitaciones la técnicas clásicas e optimizacion y heurísticas que exigen información que siempre está disponible por ejemplo los todos gradiente necesitan que se calcule la primera derivada la función objetivo otros métodos como el newton exigen la segunda derivada por lo tanto si la función objetivo e diferenciable estos métodos podrían aplicarse en muchos casos mundo real hay ni siquiera una forma plícita la función objetivo método steepest descent ejemplo técnicas clásicas optimización e el método del descenso empinado o steepest descent propuesto originalmente por cauchy en la idea este método e escoger punto xi cualquiera del espacio búsqueda y moverse lo largo la direcciones descenso más inclinado dirección gradiente ﬁ hasta encontrar el valor óptimo el algoritmo este método método gradiente conjugado que fue propuesto inicialmente por hestenes stiefel en como una forma solucionar sistemas ecuaciones lineales derivadas la ciones estacionarias una cuadrática algoritmo algoritmo steepest descent escoger punto repetir calcular fi encontrar la direccion si nabla fi f xi determinar el incremento optimo lambda en la direccion si calcular xi si xi fi hasta que sea optimo se puede ver como una variante del método steepest descent que usa el gradiente una función para encontrar la dirección más prometedora búsqueda el algoritmo el método algoritmo algoritmo gradiente conjugado escoger punto arbitrario calcular la direccion busqueda nabla f encontrar técnicas heurísticas optimización donde e el paso optimo en la direccion si repetir calcular fi f xi calcular si fi frac fi fi si calcular xi si xi fi calcular calcular el nuevo punto xi lambda si hasta que sea optimo también hay otras técnicas que construyen soluciones parciales ma como ejemplos tenemos la programación dinámica bellman y el método branch bound en conclusión se puede decir que si la función optimizarse se tra deﬁnida en forma algebraica e importante intentar solucionarla usando técnicas clásicas ante atacarla cualquier heurística técnicas heurísticas optimización heurísticas en optimización clásica se asume que los problemas tratarse deben sin embargo la mayoría los problemas del mundo real satisfacen estas exigencias inclusive muchos estos problemas pueden solucionarse usando goritmo tiempo polinomial usando computadores determinísticos cidos como problemas np en los cuales el mejor algoritmo que se conoce requiere tiempo exponencial hecho en muchas aplicaciones prácticas ni siquiera e posible aﬁrmar que existe una solución eﬁciente cuando enfrentamos espacios búsqueda tan grandes como el problema del viajero travelling salesman problem tsp y que además los algoritmos más eﬁcientes que existen para resolver el problema requieren tiempo exponencial resulta obvio que la técnicas clásicas búsqueda y timización son insuﬁcientes e entonces cuando recurrimos la heurísticas heurística la palabra heurística se deriva del griego heuriskein que ﬁca encontrar o descubrir el signiﬁcado del término ha variado históricamente algunos han usado el término como antónimo optimizacion y heurísticas se denomina heurística proceso que puede resolver cierto ma pero que ofrece ninguna garantía lograrlo la heurísticas fueron área predominante en los orígenes la inteligencia artiﬁcial actualmente el término suele usarse como adjetivo reﬁriéndose cualquier técnica que mejore el desempeño en promedio la solución problema aunque mejore necesariamente el desempeño en el peor caso russell norvig una deﬁnición más precisa y adecuada e la proporcionada por reef una heurística e una técnica que busca soluciones buenas e decir casi óptimas costo computacional razonable aunque sin garantizar bilidad u optimalidad la mismas en algunos casos ni siquiera puede determinar qué tan cerca del se encuentra una solución factible en metaheurística una metaheurística e método que se aplica para solver problemas genéricos combina funciones objetivo o heurísticas una forma eﬁciente y abstracta que usualmente dependen la estructura del problema algunos ejemplos técnicas y metaheurísticas aplicadas al blema optimización son la siguientes búsqueda tabú la búsqueda tabú tabu search glover laguna en realidad e una porque e procedimiento que debe acoplarse otra técnica ya que funciona por sí sola la búsqueda tabú usa una memoria para guiar la búsqueda tal forma que algunas soluciones examinadas cientemente son memorizadas y tomadas como tabú prohibidas la hora tomar decisiones acerca del siguiente punto búsqueda la búsqueda tabú e determinista aunque se le pueden agregar elementos probabilísticos simulated annealing está basado en el enfriamiento los cristales kirkpatrick et el algoritmo requiere una temperatura inicial una ﬁnal y una función variación la temperatura dicha función variación e crucial para el buen desempeño del algoritmo y su deﬁnición e por tanto sumamente portante éste e algoritmo probabilístico búsqueda local su principio está basado en el uso del algoritmo metropolis que aplicando simulación monte carlo calcula el cambio energía que ocurre durante técnicas heurísticas optimización enfriamiento sistema físico algoritmo metrópolis se genus una perturbación y se calcula el cambio energía si decrece el nuevo estado e aceptado caso rio la aceptación estará sujeta sorteo la probabilidad la ecuación p δe kt el algoritmo representa el proceso simulated annealing algoritmo algoritmo simulated annealing f entrada f la funcion objetivo minimizar dato kmax numero maximo iteraciones dato emax energia maximum dato xnew el nuevo elemento creado dato el mejor elemento conocido salida x el mejor elemento encontrado x e e x xbest x ebest e k mientras k kmax y e emax hacer encontrar xnew vecino x enew e xnew si p e enew t u t entonces x xnew e enew fin si si enew ebest entonces xbest xnew ebest enew fin si k fin mientras hill climbing el algoritmo escalando la colina o hill climbing russell norvig e una técnica simple búsqueda local y optimización aplicado para una función f único objetivo en espacio problema haciendo iteraciones partir punto inicial x que usualmente e la mejor solución conocida para el problema se obtiene nuevo descendiente xnew en la vecindad si el individuo nuevo xnew e mejor que el predecesor x lo reemplaza y optimizacion y heurísticas sucesivamente este algoritmo tiene retroceso ni lleva ningún tipo gistro histórico aunque estos y otros aditamentos son susceptibles ser incorporados e importante resaltar que hill climbing busca maximizar o minimizar la función f x donde x e discretizado o sea x se puede decir que hill climbing e una forma simple búsqueda la dirección gradiente por esto fácilmente puede quedar atrapado en mo locale el algoritmo representa al hill climbing algoritmo algoritmo hill climbing f requiere f la funcion objetivo minimizar requiere n numero iteraciones dato xnew el nuevo elemento creado dato el mejor elemento conocido salida x el mejor elemento encontrado repetir x evaluar f x encontrar xnew vecino x evaluar xnew si f xnew f x entonces x xnew fin si hasta que n referencias bellman bellman dynamic programming princeton press princeton nj glover laguna glover laguna tabu search kluwer academic norwell massachusetts kirkpatrick et kirkpatrick gelatt vecchi optimization simulated annealing science kuhn tucker kuhn tucker nonlinear man editor proceeding berkeley symposium page berkeley ca berkeley university calif ornia press rao rao engineering optimization theory practice john ley son referencias reef reef b modern heuristic technique blems john wiley son great britain russell norvig russell norvig artiﬁcial modern proach prentice hall upper saddle river new jersey second yván jesús túpac valdivia universidad católica san pablo perú ytupac tiva partiendo por la optimización los principios básicos la computación evolutiva principio basado en la naturaleza y en la evolución darwiniana paradigmas la computación evolutiva algoritmos genéticos canónicos modelos evolutivos para optimización numerica y modelos evolutivos para optimización combinatoria optimizacion y heurísticas optimización uno los principios fundamentales en la naturaleza e la búsqueda estado óptimo este principio se observa desde el microcosmos los átomos intentan formar enlaces mínima energía sus electrones nivel molecular se observa durante el proceso miento cuando moléculas se convierten en cuerpos sólidos al encontrar tructuras cristalinas energía óptima en ambo casos estos procesos son guiados estos estados energía mínima sólo por la leyes físicas por otro lado está el principio biológico sobrevivencia los más aptos que juntoalaevoluciónbiológica tación la especies su ambiente en este caso óptimo local e una especie que domina toda la otras su alrededor el homo sapiens ha canzado este nivel al dominar hormigas bacteria moscas cucarachas y toda clase criaturas existentes en nuestro planeta lo largo nuestra historia los seres humanos venimos buscando la fecciónen muchos aspectos por lado deseamos alcanzar el máximo grado bienestar haciendo el menor esfuerzo en aspecto económico se busca maximizar ventas y rentabilidad haciendo que los costos sean lo mínimo sibles así podemos aﬁrmar que la optimización e aspecto la ciencia que se extiende hasta inclusive nuestra vida diaria partir estas idea se puede inferir que e importante generalizar y prender que por detrás estos fenómenos existe formalismo matemático que estudia toda esta área optimización global que e una rama la temática aplicada y análisis numérico cuyo foco e claro optimización el objetivo una optimización global e encontrar los mejores elementos posibles conjunto xque siga criterio fn estos criterios son expresados como funciones matemáticas f x que en el área algoritmos evolutivos optimización se suelen denominar funciones objetivo o funciones costo que son deﬁnidas continuación funciónobjetivo unafunciónobjetivo f una función matemática para ser optimizada la imagenyde la función objetivo suele ser subconjunto del conjunto los números real o sea aldominio xdelafunción fseledenominaespaciodeproblemapudiendoser representado computacionalmente por cualquier tipo elemento aunque principalmente como listas o vectores cabe destacar que la funciones objetivo se limitan ser expresiones matemáticas sino que pueden estar compuestas por ecuaciones o algoritmos complejos que para calcularse necesiten múltiples simulaciones así la optimización global debe comprender toda la técnicas analíticas y analíticas que puedan usarse para encontrar los mejores elementos acuerdo la función en resumidas cuentas la optimización consiste en buscar y encontrar la lución o soluciones óptimas determinado problema tomando en cuenta determinadas restricciones como ejemplos podemos citar la rentabilidad negocio gastos multas o pérdidas la eﬁcacia determinado proceso para poder encajar problema cualquiera la vida real como problema optimización e necesario identiﬁcar la siguientes entidades el problema sus características restricciones y variable la variable decisión xn del problema cuyos valores inﬂuyen en la solución la función f x que calcula la calidad la solución función objetivo método algoritmo o heurística búsqueda soluciones el espacio soluciones válidas xdiscreto o contínuo del problema los recursos computacionales necesarios para implementar el proceso la función evaluación o simulación tratamiento características del problema y selección la mejor solución deﬁniciones en optimización como fue mencionado ante el objetivo del problema optimización e encontrar la soluciones óptimas determinado problema e decir la mejor solución posible entonces vale la pena deﬁnir la características que hacen una solución óptima deﬁnition espacio problema el espacio problema para problema optimización denotado por x e el conjunto que contiene todos los elementos xque podrían ser la solución encontrar la mayoría veces este espacio xestá sujeto logicas que indican elementos xque pueden ser ciones como una división entre cero o número negativo al sacar raiz cuadrada prácticas que no limitan el espacio problema por tiones tecnología ejemplo son los tipos variable punto tante floatodoubleque tienen precisión optimizacion y heurísticas deﬁnition candidato solución candidato solución x elemento valido del conjunto xpara dado problema optimización deﬁnition espacio soluciones se deﬁne el espacio nesscomo la unión toda la soluciones problema ción como se ve en la ecuación el espacio soluciones contiene pudiendo ser igual al conjunto óptimo global pueden haber soluciones válidas que son parte lo que suele ocurrir en optimización restricciones deﬁnition espacio búsqueda el espacio búsqueda problema optimización denotado por g e el conjunto todos los mentos pueden ser procesados por los operadores búsqueda asíges una codiﬁcación del espacio problema x funciones único objetivo cuando se optimiza único criterio f x óptimo e máximo o mínimo dependiendo si se está maximizando o minimizando por ejemplo en problemas mundo real manufactura se busca por lo general nimizartiempos costos o pérdidas para determinado proceso por otro lado tratántose negocios se busca maximizar la rentabilidad o el valor económico la ﬁgura muestra una función fdeﬁnida en espacio x elementos se hace destaque en el gráﬁco los óptimos locale y óptimos globales óptimo global e el óptimo en todo el conjunto mientras que óptimo local e óptimo sólo en subespacio deﬁnition máximo local sea una función objetivo f se deﬁne máximo local valor entrada que cumple f ˆxl x para todoxdentro una vecindad ˆxl sif puede decir que f ˆxl x deﬁnition mínimo local sea una función objetivo f se deﬁne mínimo local valor entrada que cumple f x para todoxdentro una vecindad sif puede decir que f x deﬁnition óptimo local sea una función objetivo f se deﬁne óptimo local valor que cumple ser máximo local o mínimo algoritmos evolutivos global local global figura ejemplo función f óptimo global y local deﬁnition máximo global sea una función objetivo f r se deﬁne máximo global valor entrada que cumple f ˆx x deﬁnition mínimo global sea una función objetivo f r se deﬁne mínimo global valor entrada que cumple f x deﬁnition óptimo global sea una función objetivo f r se deﬁne óptimo global valor entrada que cumple ser máximo o mínimo global e común encontrar más máximo o mínimo globales inclusive dentro del dominio xde una función unidimensional f ejemplo esta situación e la función coseno co x donde x que tiene valores máximos globales en ˆxcuando valores mínimos globales la solución correcta sería conjunto entradas óptimas y mínimo o máximo aislado además el signiﬁcado óptimodepende del problema optimización objetivo signiﬁca máximo o mínimo global optimización existen varias estrategias para deﬁnir el óptimo deﬁnition conjunto óptimo se deﬁne el conjunto óptimo como el conjunto que contiene todos los elementos óptimos por lo general son varias y muchas veces inﬁnitas soluciones óptimas optimizacion y heurísticas dada la limitaciones computación se pueden encontrar subconjunto ﬁnito soluciones óptimas así se establece una diferencia entre el conjunto óptimo y el conjunto xde subóptimos que puede contener mo global este conjunto x lo que algoritmo real optimización puede encontrar entonces podemos aﬁrmar que algoritmo optimización tiene como tarea encontrar soluciones que sean lo mejor posibles para el problema y que por su vez éstas sean lo más diferentes entre sí optimización clásica en la optimización clásica u optimización numérica se busca encontrar el valor la variable una función univariada xque maximize o minimize una determinada función f x este problema optimización genérico está deﬁnido la siguiente manera sea la función f x el problema optimización consiste en hallar ax ın f x sujeto la siguientes condiciones x p hj x n donde el espacio problema que e subespacio rnque ne los puntos factibles o sea puntos que satisfacen la restricciones del problema xn cuyos componentes xnson la denominadas variable sión del problema f x e la función objetivo e decir la que se quiere optimizar deﬁnition restricciones dominio deﬁnidas como los límites n relacionados los valores mínimos y máximos la variable do en el espacio deﬁnition restricciones igualdad deﬁnidas como el conjunto tamaño p gi x p deﬁnition restricciones desigualdad deﬁnidas como el junto tamaño q hj x q algoritmos evolutivos deﬁnition espacio convexo sea el espacio problema se dice quexes convexo si para todo elemento para todo se cumple que f f la interpretación la ecuación e la siguiente x convexo si para do puntos cualesquiera el segmento rectilíneo que une estos puntos también pertenece al conjunto en otras palabras x convexo si se puede ir cualquier punto inicial cualquier punto ﬁnal en línea rectum sin salir del espacio los conjuntos la ﬁgura son convexos mientras que los la ﬁgura lo son b figura espacios convexos y convexos el objetivo cualquier técnica optimización e hallar el óptimo global cualquier problema lamentablemente sólo en casos muy limitados se puede garantizar convergencia hacia el óptimo global por ejemplo para ma espacios búsqueda xconvexos la condiciones son necesarias y suﬁcientes para garantizar optimalidad global punto en problemas optimización lineal estas condiciones son suﬁcientes por lo que en este caso cualquier técnica usada puede encontrar óptimos locale sin garantizarse la convergencia hacia el óptimo global sólo se tiza esta convergencia usándose métodos exhaustivos o ésta existe en tiempo inﬁnito existe una clase especial problemas optimización que son también mucho interés se trata del caso en que la variable decisión son discretas e decir el vector xestá compuesto por valores producto cartesianoounapermutacióndevalores conocidos comooptimizacióncombinatoriaoprogramaciónentera sondemuchointerés en el área ciencias computación cuyo ejemplo más conocido e el problema del vendedor viajero travelling salesman problem tsp técnicas clásicas optimización existen muchas técnicas largamente conocidas y aplicadas para solucionar problemas optimización siempre que estos satisfagan ciertas ca especíﬁcas como por ejemplo que f x sea una función lineal o que sea que la restricciones sean lineales la importancia saber al menos la existencia estas técnicas está en que si el problema solucionar se ajusta la exigencias que éstas imponen tenga único máximo o mínimo que consecuentemente e el óptimo optimizacion y heurísticas se necesario usar heurísticas por ejemplo si la función e lineal el método simplex siempre seguira siendo la opción más viable optimización lineal metodo simplex la idea básica la optimización lineal consiste en buscar una solución válida que mejore la función objetivo tomando como partida una solución válida inicial el problema programación lineal consiste en minimizar el producto terno sujeto la siguientes condiciones ax donde r dado el conjunto x cualquier punto una combinación lineal convexa sus puntos extremos o vértices más una combinación lineal positiva sus direcciones extremas arista optimización lineal paraoptimizaciónnolineal haymétodosdirectoscomolabúsquedaaleatoria ymétodosindirectoscomoelmétododelgradienteconjugado una la principales limitaciones la técnicas clásicas e justamente que exigen información que siempre está disponible por ejemplo los métodos gradiente necesitan que se calcule la primera derivada la función jetivo otros métodos como el newton exigen la segunda derivada por lo tanto si la función objetivo e diferenciable estos métodos podrían aplicarse en muchos casos mundo real hay ni siquiera una forma explícita la función objetivo método steepest descent ejemplo técnicas clásicas optimización e el método del descenso empinado o steepest descent propuesto originalmente por cauchy en la idea este método e escoger punto xicualquiera del espacio búsqueda y moverse lo largo la direcciones descenso más inclinado dirección gradiente hasta encontrar el valor óptimo el algoritmo este método algorithm algoritmo steepest descent escoger punto la dirección xi determinar el incremento óptimo ien la dirección sicalcular óptimo método gradiente conjugado que fue propuesto inicialmente por hestenes stiefel en como una forma solucionar sistemas ecuaciones lineales derivadas la ciones estacionarias una cuadrática se puede ver como una variante algoritmos evolutivos métodosteepest descent que usa el gradiente una función para encontrar la dirección más prometedora búsqueda el algoritmo el método algorithm algoritmo gradiente conjugado escoger punto arbitrario la dirección búsqueda el paso óptimo en la rección xi calcular icalcular el nuevo punto isi óptimo tambiénhayotrastécnicasquecontruyensolucionesparcialesaunproblema comoejemplostenemoslaprogramacióndinámica yelmétodo branch bound en conclusión se puede decir que si la función optimizarse se tra deﬁnida en forma algebraica e importante intentar solucionarla usando técnicas clásicas ante atacarla cualquier heurística técnicas heurísticas optimización heurísticas en optimización clásica se asume que los problemas tratarse deben plir algunas exigencias que garantizen la convergencia hacia el óptimo global sin embargo la mayoría los problemas del mundo real satisfacen ta exigencias inclusive muchos estos problemas pueden solucionarse usando algoritmo tiempo polinomial usando computadores nísticos conocidos como problemas np hard en los le el mejor algoritmo que se conoce requiere tiempo exponencial hecho en muchas aplicaciones prácticas ni siquiera e posible aﬁrmar que existe una solución eﬁciente cuando enfrentamos espacios búsqueda tan grandes como el problema del viajero travelling salesman problem tsp y que además los algoritmos más eﬁcientes que existen para resolver el problema requieren tiempo nencial resulta obvio que la técnicas clásicas búsqueda y optimización son insuﬁcientes e entonces cuando recurrimos la heurísticas deﬁnition heurística la palabra heurística se deriva del griego heuriskein que signiﬁca encontrar odescubrir el signiﬁcado del término ha variado históricamente algunos han usado el término como antónimo algorítmico se denomina heurística proceso que puede resolver cierto problema pero que ofrece ninguna garantía lograrlo la heurísticas fueron área predominante en los orígenes la inteligencia artiﬁcial actualmente el término suele usarse como adjetivo reﬁriéndose cualquier técnica que mejore el desempeño en promedio la solución problema aunque mejore necesariamente el desempeño en el peor caso unadeﬁniciónmásprecisayadecuadaeslaproporcionadapor una heurística e una técnica que busca soluciones buenas e decir casi óptimas costo computacional razonable aunque sin optimizacion y heurísticas factibilidad u optimalidad la mismas en algunos casos ni siquiera puede determinar qué tan cerca del óptimo se encuentra una solución factible en deﬁnition metaheurística una metaheurística e método que se aplica para resolver problemas genéricos combina funciones objetivo o heurísticasdeunaformaeﬁcienteyabstractaqueusualmentenodependen la estructura del problema algunos ejemplos técnicas heurísticas y metaheurísticas aplicadas al blema optimización son la siguientes búsqueda tabú la búsqueda tabú tabu search en realidad e una porque e procedimiento que debe acoplarse otra ca ya que funciona por sí sola la búsqueda tabú usa una memoria para guiar la búsqueda tal forma que algunas soluciones examinadas temente son memorizadas y tomadas como tabú prohibidas la hora tomar decisiones acerca del siguiente punto búsqueda la búsqueda tabú e determinista aunque se le pueden agregar elementos probabilísticos simulated annealing está basado en el enfriamiento los cristales el ritmorequieredeunatemperaturainicial unaﬁnalyunafuncióndevariación la temperatura dicha función variación e crucial para el buen peño del algoritmo y su deﬁnición e por tanto sumamente importante éste e algoritmo probabilístico búsqueda local su principio está basado en el uso del algoritmo metropolis que aplicando simulación monte carlo calcula el cambio energía que ocurre durante el enfriamiento sistema físico deﬁnition algoritmo metrópolis se genus una ción y se calcula el cambio energía si ésta decrece el nuevo estado e aceptado caso contrario la aceptación estará sujeta sorteo la probabilidad la ecuación p kt el algoritmo representa el proceso simulated annealing algorithm algoritmo simulated annealing f entrada f la función objetivo minimizar dato kmax número máximo iteraciones dato emax energía máxima dato xnewel nuevo elemento creado dato mejor elemento conocido salida xel mejor elemento encontrado x kmaxye emaxencontrar vecino x xnew p e enew t u t ebest hill climbing el algoritmo escalando la colina o hill climbing e una técnica simple búsqueda local y optimización aplicado para una función fde único objetivo en espacio problema haciendo iteraciones algoritmos evolutivos partir punto inicial que usualmente e la mejor solución cida para el problema se obtiene nuevo descendiente xnewen la vecindad dex si el individuo nuevo xnewes mejor que el predecesor x lo reemplaza y así sucesivamente este algoritmo tiene retroceso ni lleva ningún tipo registro histórico aunque estos y otros aditamentos son susceptibles ser incorporados e importante resaltar que hill climbing busca maximizar o minimizar la función f x donde x discretizado o sea se puede decir que hill climbing e una forma simple búsqueda la dirección gradiente por esto fácilmente puede quedar atrapado en óptimos locale el algoritmo representa al hill climbing algorithm algoritmo hill climbing f f la función objetivo minimizar n número iteraciones dato xnewel nuevo elemento creado dato mejor elemento conocido salida xel mejor elemento encontrado x encontrar x evaluar xnewf xnew f x conceptos básicos algoritmo evolutivo algoritmos evolutivos deﬁnition algoritmos evolutivos ea son algoritmos rísticos basados en una población individuos que emplean mecanismos biológicamente inspirados como la mutación recombinación selección tural y supervivencia los más aptos para ir iterativamente ajustando o reﬁnando conjunto soluciones una ventaja los algoritmos evolutivos respecto otros métodos optimización e su característica black box e decir tener poco y pocas suposiciones sobre la función objetivo optimizar inclusive la deﬁnición la función objetivo exige menos conocimiento la estructura del espacio problema que el modelamiento una heurística factible para el problema adicionalmente los algoritmos evolutivos tienen una calidad respuesta consistente para muchas clases problemas así cuando se trata computación evolutiva o algoritmos evolutivos ponen toda ellas inspiración biológica en la evolución conceptos usados en computación evolutiva raíz la deﬁnicion son varios los conceptos que deben ser bien entendidos ya que son comúnmente empleados en computación evolutiva que se describen continuación deﬁnition individuo e una solución propuestas en la población sin ninguna alteración denotado en este texto como x deﬁnition cromosoma se reﬁere una estructura datos que contiene una cadena parámetros diseño o gene esta estructura se puede almacenar computacionalmente diversas formas cadena conceptos básicos algoritmo evolutivo arrayde números enteros o números real en este texto cromosoma se denota como deﬁnition geneque e una subsección cromosoma que mente codiﬁca el valor uno los parámetros del problema el gene que codiﬁca parámetro e denotado por gi deﬁnition población que e el conjunto cromosomas que serán tratados en el proceso evolutivo una población e denotada como deﬁnition generación e una iteración que consiste en calcular la medida aptitud todos los individuos una población xexistente para después obtener una siguiente población partir proceso selección y operaciones reproducción genética para una generación t su población e xt deﬁnition genotipo e la codiﬁcación utilizada en el cromosoma para los parámetros del problema solucionarse por ejemplo tenemos números binarios ternarios enteros real el conjunto posibles valores del genotipo conforma el espacio búsqueda deﬁnition fenotipo e el resultado decodiﬁcar cromosoma e decir los valores obtenidos pasan la representación genética fenotipo al espacio problema deﬁnition función evaluación que e una medida que indica la calidad del individuo en el ambiente por ejemplo siendo f x la función evaluación y x entonces la evaluación del individuo e f deﬁnition aptitud e una transformación gaplicada la función evaluación f x para medir la oportunidad que individuo tiene para reproducirse cuando se aplica la selección en muchos casos la función aptitud coincide la función evaluación e decir que g f x x cabe destacar que la evaluación individuo f xk depende la evaluación los demás individuos la población f xj x pero la aptitud gde individuo ksí está deﬁnida respecto los demás miembros la población deﬁnition aleloque e cada valor posible que gene puede gdeﬁnidoparaelgenotipo y dependiendo la codiﬁcación utilizada si se usa codiﬁcación binaria entonces el espacio búsqueda alelos deﬁnition operador reproducción e todo aquel mecanismo queinﬂuencialaformacomolainformacióngenéticasetransﬁeredepadres hijos estos operadores tienen do categorías conocidas operadores cruce sexuales mutación asexuales adicionalmente en algunos modelos más genéricos se emplean otros tipos operadores algoritmos evolutivos operadorespanmíticos unpadrequesereproduceconvariasparejas que emplean o más padre deﬁnition elitismo e mecanismo adicional en los algoritmos evolutivos que permite garantizar que el cromosoma más apto se transﬁera la siguiente generación sin depender la selección ni la reproducción el elitismo garantiza que la mejor aptitud una población individuo nunca será peor una generación ta la siguiente e una condición suﬁciente para encontrar el óptimo global pero sí está demostradoqueesunacondiciónnecesariaparagarantizarlaconvergencia al óptimo algoritmo genético principio basado en la naturaleza algoritmo evolutivo e una abstracción los procesos y principios blecidos por el darwinismo y junto al principio conducido por los objetivos también se puede aﬁrmar que el espacio búsqueda ge una abstracción del conjunto posibles cadenas adn la naturaleza jugando cada elemento papel los genotipos naturales así se puede ver al espacio gcomo genomay los elementos los genotipos la misma manera que cualquier ser vivo que siendo una instancia su genotipo formado durante la embriogénesis una solución candidata o fenotipo el espacio problema xtambién e una instancia su genotipo que fue obtenida mediante una función mapeamiento γ también conocida como codiﬁcación y su aptitud e calculada acuerdo la funciones objetivo la cuales está sujeta la optimización y dirigen la evolución hacia objetivo especíﬁco goal driven ciclo básico algoritmo evolutivo proceso evolutivo en general se puede simular computacionalmente los siguientes mecanismos una forma codiﬁcar la soluciones xen estructuras gque se cirán conformando una población generada aleatoriamente una función asignación aptitud h que depende los individuos xy su evaluación f x mecanismo selección basado en la aptitud operaciones que actuen sobre los individuos codiﬁcados reproducirlos estos mecanismos siguen orden ejecución como muestra la ﬁgura paradigmas la computación evolutiva aunque e muy fácil distinguir la diferencias entre los distintos tipos algoritmos evolutivos en la actualidad se puede diferenciar tres principales paradigmas la computación evolutiva conceptos básicos algoritmo evolutivo figura el ciclo básico algoritmo evolutivo evolutivas genéticos adicionalmente se encuentran do paradigmas más learning classiﬁer temsy programación genética que son bastante próximos algoritmos néticos y programación evolutiva respectivamente cada uno estos digmas se originó manera independiente y motivaciones muy distintas la ﬁgura ilustra una clasiﬁcación los principales paradigmas que forman la familia los algoritmos evolutivos figura familia algoritmos evolutivos continuación se revisarán rápidamente los principales paradigmas y más adelante se dará todo el detalle algoritmos genéticos algoritmos evolutivos programación evolutiva e una concepción inicial la evolución simulada orientada solucionar problemas en especial el predicción la técnica denominada programación evolutiva consistía básicamente en hacer cionar autómatas estados ﬁnitos los cuales eran expuestos una serie símbolos entrada el ambiente esperando que en algún momento sean capaces predecir la secuencias futuras símbolos que recibirían fogel utilizó una función recompensa que indicaba qué tan bueno era cierto autómata para predecir símbolo y usó operador mutación para efectuar cambios en la transiciones y en los estados los autómatas que tenderían hacerlos más aptos para predecir secuencias símbolos esta técnica consideraba el uso operador recombinación sexual porque pretendía modelar el proceso evolutivo nivel especies y nivel individuos la programación evolutiva se aplicó originalmente problemas predicción control automático identiﬁcación sistemas y teoría juegos entre otros probablemente la programación evolutiva fue la primera técnica basada en la evolución en aplicarse problemas predicción además ser la ra en usar codiﬁcaciones longitud variable el número estados los autómatas podía variar tras efectuarse una mutación además constituir uno los primeros intentos por simular la en la programación evolutiva la inteligencia e vista como miento adaptativo donde se le da más importancia los nexos comportamiento entre padre e hijos más que los operadores especíﬁcos el algoritmo básico la programación evolutiva e el siguiente algorithm algoritmo básico la programación evolutiva una población inicial xtcfin xtevaluar xt seleccionar elementos así la programación evolutiva e una abstracción la evolución nivel especies donde cada individuo e una especie y por esto e rio usar operadores recombinación pues diferentes especies se pueden cruzar entre sí la selección que usa e probabilística por ejemplo torneo estocástico estrategias evolutivas la estrategias evolutivas fueron desarrolladas en como una heurística optimización basada en la idea adaptación y evolución la intención inicial resolver problemas hidrodinámicos alto grado viento para optimizar la forma tubo curvo minimizar el arrastre tre una placa unión y optimizar la estructura una boquilla intermitente do fas la descripción analítica estos problemas era imposible y claro su ción usando métodos tradicionales como el gradiente lo era también esto impulsó ingo rechenberg desarrollar método ajustes discretos torios inspirados en el mecanismo mutación que existe en la naturaleza los resultados primeros estos experimentos se presentaron en el instituto hidrodinámica su universidad conceptos básicos algoritmo evolutivo en los do primeros casos el tubo y la placa rechenberg procedió efectuar cambios aleatorios en ciertas posiciones la junta y en el tercer problema procedió intercambiar agregar o quitar segmentos boquilla sabiendo que en la naturaleza la mutaciones pequeñas ocurren mayor frecuencia que la grandes rechenberg decidió efectuar estos cambios en base una distribución binomial una varianza preﬁjada el mecanismo básico estos primeros experimentos era crear una mutación ajustar la junta o los segmentos boquilla acuerdo ella llevar cabo el análisis diente y determinar qué tan buena era la solución si ésta era mejor que su predecesora entonces pasaba ser utilizada como base para el siguiente experimento tal forma se requería información sobre la cantidad mejoras o deterioros que se efectuaban esta técnica tan simple dio lugar resultados inesperadamente buenos para los tres problemas en cuestión características la estrategias evolutivas tienen la siguientes características los candidatos solución son vectores xn los que se le aplican ninguna codiﬁcación e decir que así el espacio soluciones queda deﬁnido como esto quiere decir que tanto el espacio búsqueda como el espacio problema se expresan computacionalmente variable números real punto ﬂotante la mutación y selección son los operadores principales siendo menos usual el cruce la mutación consiste en recorrer los elementos xidel vector xe ir plazándolos por número obtenido partir una distribución normal n xi e decir que el elemento se muta usando una distribución normal multivariada n x σ existeuncriterioparaactualizarelvalorde daptación algoritmo la versión original usaba apenas padre y hijo el hijo competía el padre y el mejor permanecía en la generación este tipo estrategia selección e determinística y característica extintiva ya que los peores individuos tienen probabilidad selección cero y simplemente desaparecen la mutación en el modelo para la generación tse obtiene cando la siguiente ecuación σ donde n σ e una variable aleatoria que siguen una distribución gaussiana tivariada medium matriz covarianzas σes la matriz covarianzas elementos e decir que la matriz covarianzas e diagonal lo que signiﬁca que se usan ciones normales independientes para la mutación cada componente xi dex el algoritmo ilustra la estrategia el propio rechemberg extendió la estrategia inicial al introducir el algoritmos evolutivos algorithm algoritmo k mt xn aleatoriamente evaluaf xt mutar σt evaluar xt población en la estrategia denominada en la que existen µ antecesores y se genus unico descendiente que puede reemplazar al peor los antecesores la población selección extintiva estrategias µ λ más adelante schwefel propuso tener múltiples descendientes estableciéndose la estrategias y µ λ cuya diferencia e la metodología selección se juntan los conjuntos µantecesores y λdescencientes en conjunto tamaño losµmejores individuos sobreviven µ λ sólo los µmejores descendientes sobreviven esto obliga que se cumpla que convergencia la estrategias evolutivas rechemberg formuló una regla para ajustar el valor desviación estándar σ durante el proceso evolutivo tal forma que el procedimiento mantenga la convergencia hacia el óptimo esta regla e conocida como la regla del éxito se como la razón entre mutaciones exitosas que hagan mejorar la solución y el total mutaciones debe ser si e mayor entonces se incrementa la desviación estándar si e menor entonces debe decrementarse una forma más elegante donde ne la dimensión del problema te la generación en curso ps la frecuencia relativa mutaciones exitosas contada para nado intervalo generaciones y barridas mutación ejemplo y ce una constante actualización cuyo valor más típico e mecanismo autoadaptación en la estrategias evolutivas además evolucionar la variable del ma también evolucionan los parámetros la técnica en este caso la la desviaciones estándar σi los antecesores seleccionados para operar se le aplica la siguientes operaciones o algoritmo genético clásico constantes que están en función cabe destacar que la estrategias evolutivas simulan el proceso evolutivo individuo permitiendo operadores recombinación cuya tidad antecesores recombinarse está parametrizada por ρ además eso la recombinación puede ser toriamente e decir que se selecciona individuo xkﬁjo y otros so individuos xl el individuo xkse recombina cada uno los vectores xlpara obtener cada componente ldel vector diente por otro lado el proceso selección usado e determinístico algoritmo genético clásico introducción los algoritmos genéticos denominados originalmente plane reproductivos genéticos fueron desarrollados por john holland principios la cada quien interesado en estudiar los procesos lógicos que se daban en la adaptación e inspirado por los estudios realizados en esa época autómatas celulares y redes nales se percató que el uso reglas simple podía conllevar comportamientos ﬂexibles visualizando así la posibilidad estudiar la evolución en sistemas complejos holland se percató que para estudiar la adaptación era necesario considerar los siguientes principios la adaptación ocurre en ambiente b la adaptación e proceso poblacional c los comportamientos individuales se pueden representar como ma d se pueden generar comportamientos futuros haciendo variaciones rias en los programas e la salida los programas tienen relación entre ellas si sus respectivas estructuras también tienen relación entre sí así holland logró ver el proceso adaptación como mecanismo en el que los programas una población interactúan y van mejorando acuerdo ambiente que determina su calidad la combinación variaciones aleatorias proceso selección basado en la calidad los programas para el ambiente debía conducir sistema adaptativo general e este sistema lo que holland denominó plan reproductivo genético aunque los algoritmos genéticos fueron concebidos en el contexto tación parte machine learning actualmente son masivamente utilizados como herramienta optimización deﬁnición algoritmos genéticos los algoritmos genéticos como técnicas la inteligencia artiﬁcial son algoritmos estocásticos que implementan métodos búsqueda partir modelo algunos fenómenos la naturaleza que son la herencia genética y el principio darwiniano la supervivencia los más algoritmos evolutivos la metáfora que está por detrás los algoritmos genéticos e la evolución natural en la evolución nivel especies el problema que cada especie frenta consiste en buscar adaptaciones que le sean benéﬁcas para el ambiente que e complicado y cambiante este conocimiento que cada especie adquiere está incorporado en la estructura los cromosomas sus miembros el algoritmo genético trabaja sobre una población soluciones y enfatiza la importancia la cruza sexual operador principal sobre el la mutación operador secundario y usa selección probabilística basada en la aptitudde la soluciones diferencia otros paradigmas evolutivos como la mación evolutiva y la estrategias evolutivas componentes algoritmo genético aﬁrma que para poder aplicar el algoritmo genético se requiere los siguientes componentes básicos una representación la soluciones potenciales del problema raleza genotípica denominada cromosoma una manera crear una población inicial posibles soluciones minadainicialización que por lo general se basa en proceso rio una función objetivo que hace el papel del ambiente caliﬁcando la luciones acuerdo su aptitud denominada función evaluación genéticos que alteren la composición los genomas leccionados produciendo descendientes para la siguientes generaciones e decir valores para los diferentes parámetros que utiliza el algoritmo genético tamaño la población probabilidad aplicarcrossover mutación número máximo generaciones algoritmo genético canónico también denominado algoritmo genético tradicional fue introducido por y se usan individuos compuestos por cadenas números binarios longitud ﬁja lque codiﬁcan toda la variable del problema en este modelo algoritmo genético se nota claramente el cepto genotipo que e cada una la cadenas binarias bique codiﬁcan una respectiva solución o fenotipo xi aunque una codiﬁcación fenotipo está limitada la representación binaria en esta codiﬁcación e la más parecida los cromosomas biológicos que e la que ideó e implementó en la figura se muestra modelo típico individuo usado en el ritmo canónico holland que consta una cadena binaria bi bk bjbi figura cadena binaria bicon longitud l la cadena binaria bse le denomina cromosoma cada posición la cadenabjse le denomina geney al valor dentro esta posición que puede ser valor se le llama algoritmo genético clásico procedimiento elemental el pseudocódigo para algoritmo básico e el siguiente algorithm procedimiento algoritmo genético poblacióndegenotipos gtdecodiﬁcar yevaluar lasestructuras formando gtevaluar gt donde gtes la población cromosomas en la generación te el iterador generaciones gtes el conjunto individuos selecionados para reproducir que sufrirán cruce o mutación cﬁnes una condicion ﬁnalización del algoritmo para realizar la evaluación genotipo necesario decodiﬁcarlo su fenotipo γi así poder aplicar la función evaluación f xi al cumplirse la condición ﬁnalización el algoritmo debe dejar iterar y el individuo mejor aptitud xbestencontrado hasta ese momento será considerado la solución obtenida por el algoritmo genético este criterio ﬁnalización suele ser número máximo generaciones itmaxo el miento una prueba convergencia aplicada la población xt la ﬁgura ilustra este ciclo población inicial que incluye la selección reproduccion cruce y mutación y la evaluación f reproducci nueva poblaci descendientesevaluaci la descendencia evoluci progenitores cruce mutaci genotipo ﬁtness figura ciclo principal algoritmo genético representación binaria como ya fue mencionado algoritmo genético canónico usa cadenas merosbinariosdeunalongitud lcomocromosomasquecodiﬁcanlasvariables decisión ilustradas en la ﬁgura algoritmos evolutivos deﬁnition cadenas binarias una cadena binaria se deﬁne usando el alfabeto binario y una cadena binaria longitud locupa espacio dada una función f x optimizar donde xn cada una sus variable xipuede ser codiﬁcada en una cadena binaria una longitud lideﬁnida por el usuario la ﬁcación toda la variable e obtenida concatenando la ncadenas longitudlipara formar una sola gran cadena longitud ln e sabido que una cadena binaria longitud lpuede codiﬁcar total búsqueda eso signiﬁca que la longitud lipara una blexidependerá la precisión deseada para esta variable la ecuación ilustra una codiﬁcación típica nvariables xn en una cadena binaria li ln donde la variable xi xn e codiﬁcada mediante una nación cadenas binarias longitud este tipo codiﬁcación permite que algoritmo genético pueda ser cado en una gran variedad problemas puesto que el mecanismo genético actuará evolucionando la cadenas binarias según el valor aptitud la función evaluación f x sin preocuparse en la naturaleza la variable cabe destacar que la cantidad verdadera posibles valores la variable y sus dominios son tratados por la codiﬁcación esta opción se hace posible que mismo esquema algoritmo genético se aplique en diversos problemas sin necesidad muchas alteraciones la decodiﬁcación usada para extraer los valores la variable partir una cadena binaria comenzará realizando lo siguiente dada la cadena binaria bl extrae la subcadena blicorrespondiende la variable xi se aplica la decodiﬁcación γ xestá deﬁnido acuerdo la naturaleza la variable del problema codiﬁcación variable real en binario dada una función f x donde ser optimizada se requiere codiﬁcarla cadenas binarias cumpliendo la siguientes propiedades vector xn ser codiﬁcado mediante una ca palabra binaria longitud esto signiﬁca que se debe deﬁnir una función codiﬁcación que variable xitiene su propio domínio tal que se cumpla que n se debe deﬁniruna función codiﬁcación ipara la variable xicomo se limita la precisión cada variable xi apidígitos decimales el espacio blideberá ser capaz codiﬁcar al menos valores para la variable xi como muestra la ﬁgura algoritmo genético clásico precisi left idominio dexi diferentes soluciones figura número posibles valores para xi estas exigencias precisión ya e posible encontrar el valor longitudlidebitsque la satisfaga para la variable xi este valor liqueda deﬁnido por la ecuación que representa una cantidad bit que quedará deﬁnido por el valor natural inmediatamente mayor que el valor calculado como esta regla e aplicada porque la condición precisión indica que al menos se satisfaga la precisión en dígitos decimales especiﬁcada encontrar el tamaño len caracteres binarios del cromosoma que codiﬁque toda la variable xn sólo queda sumar todos losliencontrados ili cumple que para dado valor left en rio la cadena binaria representa el valor left iy la cadena binaria representa el valor righti decodiﬁcación binario real γipara una variable xi e deﬁnida como γi y consiste en convertir la cadena binaria bia decimal y escalarla al intervalo dominio acuerdo la ecuación xi real obsérvesequeparaestacodiﬁcación seasumequelagranularidaddelespacio búsqueda para la variable xy uniforme e igual si esta suposición se cumple e decir que la granularidad e uniforme como ocurre en los números punto ﬂotante la función decodiﬁcación puede ajustarse adecuadamente usando una transformación sin embargo para problemas real búsqueda y optimización pueden existir patrones deﬁnidos granularidad haciendo más complicadas tanto la función codiﬁcación como la algoritmos evolutivos decimal binario gray cuadro cadenas binarias y cadenas código gray hay casos en que algunas variable toman valores negativos y positivos si el dominio estas variable e simétrico o sea emplearse una codiﬁcación basada en la representación números enteros mento donde el bitmás signiﬁcativo está relacionado el signo ventajas y desventajas la representación binaria e simple y fácil manipular no da buenos tados y facilita la acción los operadores genéticos pudiéndose decodiﬁcar real o entero pero siempre e la más adecuada ya que presenta do problemas riesgo por distancia hamming se deﬁne la distancia hamming como la cantidad bit diferentes entre do palabras binarias cuando se emplea codiﬁcación binaria basada en lsb y msb en muchos casos ocurre que la distancia en bitsentre do valores binarios tiene correspondencia la distancia entre los valores numéricos codiﬁcados en binario esto se puede observar en la tabla en los valores y una opción que puede mitigar este problema e el empleo codiﬁcación gray que se continuación elcódigo gray se usa para obtener palabras binarias usando una metodología diferente para codiﬁcar y decodiﬁcar que se en la siguientes fas dada una cadena convencional bl se convierte digo gray al una codiﬁcación gray expresada en la ecuación bi otro caso el operador suma módulo la principal ventaja esta codiﬁcación e precisamente que para enteros adyacentes la distancia hamming la cadenas binarias resultantes e ladecodiﬁcacióndeunacadenabinariaencódigogray al blpara convertirla en cadena binaria convencional consiste en aplicar la expresión l algoritmo genético clásico entonces ya e posible aplicar la decodiﬁcación γi sea cesaria la codiﬁcación completa tiene la siguiente secuencia gray γ bl incremento la dimensionalidad del problema este efecto ocurre porque la longitud lde la cadena binaria resultante e mucho mayor que la dimension nde los valores real originales para una precisión en kbitsespeciﬁcada el ejemplo siguiente no ilustra este efecto para una codiﬁcación sea la función f espacio problema ﬁnido por los dominios e claro que la dimensión original este problema e desea encontrar la codiﬁcación γ los dominios del blema y considerando una precisión decimales la metodología la sección se obtienen cadenas y la cadena binaria total será longitud bit binarios lo tanto la codiﬁcación resultante e inicialización la población xi m población compuesta por mindividuos dimensión n esto e nvariables xn la inicialización la ción inicial realiza para cada individuo mconforme la ecuación colocando valores aleatorios en cada una la variable xn queda claro que esta inicialización debe respetar los dominios cada variable xj n leftj u t donde u t e valor aleatório distribución uniforme obsérvese que si la realización u t el valor inicializado coincide left j y si la realización u t el valor inicializado coincide rightj inicialización para codiﬁcación γ si se está empleando mapeamiento cada variable xiestará codiﬁcada por cadenas valores la inicialización puede hacerse directamente generando bitsaleatorios ó y colocándolos en cada en cada uno los alelos bide la cadena bsiendo inicializada sin parse por los dominios puesto que la precisión ya fue determinada al aplicar la ecuación y los dominios están deﬁnidos y garantizados tanto en la codiﬁcación en la decodiﬁcación γ ya fue visto en la ecuación sea aplicada do variable que e una función típica llena máximos y mínimos locale lo que la convierte en difícil para encontrar el óptimo global e bien conocido y algoritmos evolutivos global figura visualización la función enf la ecuación representa la función esta ecuación tiene variable tiene restricciones priori para los valores para este ejemplo se enmarca los siguientes dominios en la ﬁgura se visualiza parte esta función para los intervalos donde se observan los múltiples máximos y mínimos que son característicos la función nótese el punto y el valor f e el máximo global como se señala en la ﬁgura deﬁniendo el cromosoma supóngase que se desea codiﬁcar el individuo usando cadenas binarias esto no obliga pensar en una codiﬁcación del tipo donde bles el espacio cadenas binarias longitud lque representan individuos enteros si se deﬁne una precisión cifras decimales para cada variable xi al aplicar la ecuación se calcula el número para algoritmo genético clásico xide la siguiente manera tenemos que lipodría asumir los valores los cuales se por lo tanto el cromosoma binario que codiﬁca tendrá una longitud total lainicializacióndelapoblacióninicialconsistirásimplementeenelllenadode valores aleatorios para todos y cada uno los cromosomas codiﬁcados función evaluación lafuncióndeevaluacióneselenlaceentreelalgoritmogenéticoyelproblema en cuestión se puede deﬁnir como el resultado aplicar en el problema ser optimizado los valores xn propuestos en individuo dado el individuo xi su función evaluación se denota como f xi aptitud partir la función evaluación se deﬁne la aptitud acomo el valor numérico que se le asigna cada individuo fenotipo xiindicando qué tan bueno e respecto los demás individuos la población xpara la solución del problema como en la ecuación f xi x xi cabe destacar que para muchos casos la aptitud e la propia función evaluacion esto quiere decir que f xi x xi lo que suele crear fusiones entre ambo conceptos por esto debe quedar claro que la función evaluación depende sólo del individuo xiy del problema optimización mientras que la aptitud del mismo individuo puede depender él y del resto individuos la población xcon respecto al problema en optimización suponiendo el uso una binario enteroγ cadenas binarias longitud fenotipo y una función aptitud igual la evaluación f tenemos que f existe limitación en la complejidad la función evaluación puede ser tan simple como la ecuación polinómica del ejemplo o ser tan compleja que requiera la ejecución varios módulos simulación para evaluar los valores la variable especiﬁcadas en el individuo la ﬁgura ilustra cómo seria el proceso evaluación para el problema el objetivo esta etapa e obtener partir una población xten la generación t vector aptitude atque será empleado en la siguiente etapa del proceso evolutivo la selección estrategias selección una vez creada una población inicial mindividuos xi m culada la aptitud cada uno sus individuos xialmacenada en el algoritmos evolutivos fenotipo funci evaluaci f x f figura cromosoma y función evaluación aptitudesat se seleccionan los individuos que serán reproducidos ta selección suele basarse en la aptitud cada individuo f xi xt que en este momento representa una probabilidad selección cada individuo xicon respecto los demás individuos la población la selección suele involucrar sorteo usando la propabilidad lo que la caracteriza como proceso probabilístico la técnicas selección usadas en algoritmos genéticos se pueden clasiﬁcar en grupos proporcional por torneo selección proporcional que son algunas estrategias selección originalmente propuestas por lland cuya característica e que los individuos se seleccionan acuerdo su contribución aptitud respecto al total aptitud la población dentro este grupo se tiene la siguientes estrategias por ruleta roulette selection estocástico determinístico estocástico adicionalmente existen otras técnicas que siendo proporcionales tan los siguientes aditamentos σ jerarquías boltzmann selección por ruleta entre toda la estrategias selección la más utilizada por su simplicidad y facilidad entendimiento e la selección por ruleta o roulette selection su principio trabajo se basa en formar vector aptitude acumuladas donde cada individuo aporta su peso en aptitud luego se realiza teo generando una posición entre y el valor total acumulado y se selecciona el individuo que aportó la parte donde se encuentra el punto sorteado algoritmo genético clásico individuo ifenotipo total cuadro ejemplo aptitude para aplicación la ruleta esta forma individuo que aporte más aptitud tendrá más posibilidad ser seleccionado el procedimieto la ruleta se en el algoritmo algorithm selección por ruleta bm xj donde ate el vector aptitude xt btcon componentes bm e el vector aptitude acumuladas xt que se calcula la siguiente manera bmes el valor total aptitud acumulada u e generador números aleatorios entre dado individuo xiy su aptitud xi xt su probabilidad selección pxi para el modelo selección por ruleta será xi xt en la tabla se muestra conjunto valores ejemplo para algoritmo genético cromosomas binarios cuya ruleta resultante para aplicar el algoritmo selección e ilustrada por la ﬁgura x x x x x figura ejemplo ruleta para la población y aptitude la tabla algoritmos evolutivos individuo ifenotipo et et total cuadro ejemplo aplicación del sobrante estocástico análisis la selección por ruleta la ruleta tiene algunas deﬁciencias que se describen seguir complejidad computacional e o el algoritmo se hace ineﬁciente cuando crece el tamaño mde la población sujeta al error muestreo e decir que el valor esperado e xi selección que depende la aptitud relativa o probabilidad ción individuo siempre se cumplirá pudiendo haber diferencias ser escogido varias veces posible utilizar búsqueda binaria en vez búsqueda secuencial lo que requiere memoria adicional y una primera barrida complejidad o n esto la complejidad total la ruleta pasa ser o nlogn sobrante estocástico e una alternativa que busca obtener una mejor aproximación los valores esperados selección e los individuos e xi deﬁnidos por la ecuación e xi f xi xt bm donde e la aptitud del individuo xi bmes la aptitud acumulada la población mla cantidad elementos en la población lo que se hace e asignar en forma determinística el conteo los valores esperados e decir la parte enteron para después usando esquema probabilístico y proporcional completar los duo sobrantes por el redondeo usando la parte decimal restante el esquema completación individuos faltantes tiene do variantes reemplazo donde cada sobrante se usa para sesgar sorteo que determina si individuo se selecciona o reemplazo donde se usan los sobrantes para dimensionar una leta y se usa esta técnica para la selección la tabla ilustra ejemplo del uso del sobrante estocástico esta metodología permite disminur los problemas muestreo la ruleta aunque se puede causar convergencia prematura debido la mayor presión selectiva selección por torneo laselecciónportorneoo tournament selection quefuepropuestaen tiene como idea básica seleccionar individuos comparando directamente algoritmo genético clásico aptitude como el algoritmo algorithm selección por torneo xtatdesordenar xtescogerkindividuos comparar loskindividuos por su aptituda seleccionar el individuo mejor aptitud dondeksuele tener el valor la selección por torneo e bastante simple y e determinista ya que los dividuos menos aptos nunca serán seleccionados característica extintiva para compensar este efecto existe una versión torneo probabilística cuya principal diferencia surge al momento escoger el ganador en vez leccionar al individuo más apto se hace sorteo u t p donde u t e generador números aleatorios entre si el resultado se cumple se selecciona al elemento más apto caso contrario se selecciona el menos apto el valor pse mantiene ﬁjo durante todo el proceso evolutivo esta variante probabilística reduce la presión selectiva eliminando la terística extintiva ya que en algunas ocasiones los elementos menos aptos podrían ganar el torneo y ser seleccionados análisis del torneo versión determinística garantiza que el mejor individuo sea nado competencia requiere la selección aleatoria kindividuos que e valor constante por lo que se puede decir que su complejidad e o requieren mcompetencias para lograr seleccionar una nueva ción completa para una generación por lo tanto la complejidad este algoritmo e o m técnica e eﬁciente y fácil implementar se requiere escalar la función aptitud la comparaciones se hacen directamente la versión determinística se puede introducir una presión selectiva fuerte ya que los individuos menos aptos tienen opción sobrevivir presión selección se puede regular variando el tamaño kde los individuos que compiten laselecciónesequivalenteaunpaseoaleatorio sinpresión selectiva la selección e totalmente determinística siempre giendo al mejor elemento la población para se considera una selección blanda considera una selección dura operadores genéticos losoperadoressonaquellosmecanismosquemanipulanelgenotipo gytienen inﬂuencia en la forma como la información genética e transmitida padre ahijos los principales operadores recaen en la siguientes categorías cruzamientos o crossover que forman do nuevos individuos partir del intercambio partes o recombinación información los do individuos seleccionados para operar en sentido amplio el mero antecesores podría ser mayor que do en este tipo operador ocurre la transmisión características hereditarias los tipos algoritmos evolutivos más conocidos son el cruce punto cruce do puntos y cruce uniforme que forman nuevo individuo partir alteraciones en los gene único individuo seleccionado cruce punto en este operador partir una pareja genotipos seleccionados y seleccionando punto corte aleatorio se generan do descendientes parte su información como ilustra la ﬁgura punto corteantes del cruce despu del cruce figura cruce punto cruce do puntos en este caso se usan do puntos corte generados aleatoriamente se tiene segmento los cromosomas padre se intercambiará conforme ilustra la ﬁgura intervalo corteantes del cruce despu del cruce figura cruce do puntos cruce uniforme dado los cromosomas seleccionados este operador barre sus tivas estructuras utilizando sorteo u t ipara determinar cual gene lospadresaportará para formar los gene los descendientes como muestra la ecuación e ilustrado en la ﬁgura t t contrario mutación los operadores mutación seleccionan algún gen lo alteran por otro valor tratándose individuo genotipo binario gen sería bit y su alteración e valor valor o viceversa el operador mutación puede sufrir algunas variaciones para selecionar y alterar el bitcomo se algoritmo genético clásico del cruce despu del cruce u t u t t t u t t u t u t sorteos usando ui t figura crossover uniforme g gimutado figura mutación bit aplicar sorteo todos los gene del cromosoma bilidad mutación pmy para cada gen seleccionado colocar valor aleatorio aplicar sorteo y colocar el bitcomplementario al gene teado escoger aleatoriamente solo gen del cromosoma y cambiar su contenido por valor aleatorio el dilema exploiting exploring enlamayoriadesistemasdeaprendizajeexistelanecesidaddeaprovecharlos conocimientos existentes exploiting y también buscar nuevo conocimiento exploring que son características o comportamientos que prioriparecen ser contradictorios caracterizando dilema o una paradoja en general cualquier algoritmo evolutivo e ajeno esta situación en modelo evolutivo el exploiting se ve como el aprovechamiento la información que la población actual xtposee sobre el espacio del problema xy determinar los lugares más promisorios o interesantes para visitar o sea sacar el jugo la información que se tiene en la población actual por otro lado el exploring se visualiza en la necesidad dirigirse regiones en el espacio xnunca ante visitadas para ver si aparece alguna nueva mación prometedora o sea dar salto lo desconocido esta característica también dará la opción quedarse atrapados en óptimos locale en este sentido los operadores crossover proveen la característica tingy los operadores mutación proveen la característica exploring unaconsecuenciadeesteefectoeslanecesidaddeajustedelasprobabilidades cruce y mutación durante el ajuste algoritmo evolutivo buscando mejor rendimiento en la solución determinado problema búsqueda u algoritmos evolutivos ajustes la aptitud cuando se realiza el cálculo la aptitud podemos encontrarnos do problemas extremos presión selectiva que ocurre cuando la aptitude producto la evaluación los cromosomas tienen valores numéricos muy similares haciendo que cualquier algoritmo selección sea ineﬁciente en esta situación el proceso evolutivo toma comportamiento muy próximo al una selección aleatoria cuando existe uno o pocos individuos la población una aptitud muy alta respecto los demás individuos la población en este caso el proceso selección tenderá escoger sólo estos individuos para reproducirse en consecuencia estos invadirán la poblaciones sucesivas ocasionando disminución la diversidad genética y convergencia prematura para evitar estos do efectos indeseados se pueden realizar ajustes la aptitude la población como evaluación lineal que se describen continuación aptitud evaluación e el caso más simple en el que se ve necesidad realizar ajustes la función evaluación f xi para obtener la aptitud e decir que se aprecia problema súperindividuo ni competición próxima consiste en utilizar la deﬁnición aptitud la ecuación igualándola la propia evaluación del individuo xi xt xi windowing cuando ocurre el problema competición próxima debido que los dividuos tienen evaluaciones muy similares e necesario ajustar la aptitud usando la siguiente expresión f xi xt xi xt donde fmin xt e la evaluación mínima hallada en la población xt amin opcional e una aptitud mínima sobrevivencia para garantizar la reproducción los cromosomas menos aptos normalización lineal e el tipo ajuste más utilizado en algoritmos genéticos que busca gar el efecto del súperindividuo y los individuos competición próxima manteniendo equilibrio presión selectiva como se ción sea una población xtconmindividuos ordenada por la evaluaciones mediante la normalización lineal se ajustan la aptitude desde valor mínimovminhasta valor máximo vmaxcon pasos ﬁjos como se indica en el algoritmo algoritmo genético clásico algorithm normalización lineal xtftvmin vmaxordenar xtdecrecientemente según mcrear ai m xif xi ai ai cuadro ejemplo normalización lineal ftes el vector evaluaciones la población xt vmines el valor mínimo aptitud normalizada vmaxes el valor máximo aptitud normalizada aies la aptitud normalizada linealmente para el individuo xide la población xtordenada cabe resaltar que la presión selectiva está relacionada directamente el módulo la diferencia sea una población xi cuyas evaluaciones f xi son la especiﬁcadas en la segunda columna la tabla observando la tabla y la ﬁgura se nota que una evaluación f muy alta respecto los demás viduos también se debe notar que existe competición próxima entre los dividuos cuyos valores evaluación son muy próximos entre sí al aplicar normalización lineal los efectos indeseados estos do casos son atenuados y la presión selectiva se puede establecer por la diferencia entre vminyvmax aparte la normalización lineal pueden ser aplicados otros tipos malizacion la aptitud los individuos tale como ajuste geométrico ponencial logarítmico ajustes la selección una cuestión que se debe observar e la llamada brecha generacional que se reﬁere la transición elementos la población xthacia la población el algoritmo genético convencional considera que cuando se realiza la ción se obtiene una nueva población completa que posteriormente se operará crux y mutaciones esto caracteriza comportamiento extintivo que en algunos casos puede ser muy beneﬁcioso ya que eventualmente podrían perderse individuos valiosos para tratar esta situación se emplean do algoritmos evolutivos individuosa f x x evaluaci y aptitud normalizada lineal x figura ejemplo normalización lineal elitismo que consiste en almacenar una copia del mejor individuo la población colocarlo en la población haber realizado todo el proceso evolución selección reproducción evaluación esta estrategia reduce el efecto aleatorio del proceso evolutivo y también garantiza que través la generaciones el mejor individuo en sempre será igual o mejor que el mejor individuo los mejores individuos para continuar reproduciéndose en este caso hay reemplazo total los individuos la población xt al generar la población la metodología realización steady state e la que no muestra el algoritmo algorithm seleccionar k mindividuos xtoperar estoskindividuos crux tacion eliminar loskpeores elementos xtobtener los n individuos generados dondekes la fracción individuos reemplazarse k m la ﬁgura ilustra el funcionamiento del steady state adicionalmente se puede hacer el reemplazo parcial la población y excluir los individuos repetidos sin repetidos esta estrategia se obtienen la siguientes ventajas la repeticiones que son más frecuentes en poblaciones stateque son más estáticas eﬁciencia en el paralelismo búsqueda dado que se garantizan elementos diferentes diversidad en este caso cada individuo repetido e tratado la siguientes algoritmo genético clásico poblaci evaluaciones f xi knuevos individuosreemplazar los kpeorespoblaci evaluaciones f xi figura procedimiento reemplazado por nuevo individuo generado aleatoriamente cando que sea repetido ó operar el individuo cruce o mutación hasta que el resultado sea individuo diferente existeunmayorcostocomputacionaldebidoalaveriﬁcacióndelosindividuos repetidos medidas monitoreo una forma visualizar el comportamiento algoritmo evolutivo en general consisteenvercómosecomportalapoblación xdurantelaejecución del proceso evolutivo e decir durante la generaciones hasta que se dé la ﬁnalización la ejecución lo más común e obtener curvas desempeño la ejecuciones algoritmo se conocen los siguientes tipos curva curvaonline una curva onlinepermite visualizar la rápida obtención buenas ne y también la convergencia los individuos la población dado experimento que partió una población inicial punto la pondiente curva onlinepara la generación testá dado por von t xt algoritmos evolutivos donde xt e la medium la evaluaciones todos los individuos en la generación la ecuación se puede inferir que punto la curvaonlinees la medium todos los individuos que fueron evaluados hasta ﬁnalizar la generación una curva visualizar la obtención buenas soluciones sin importarse el tiempo tomado para encontrarlas dado experimento para la generación tel valor del punto en la curva dado por voﬀ t xbest t dondef xbest t e la evaluación del mejor elemento la generación la ecuación se puede inferir que la curva la medium los mejores elementos desde la generación hasta la generación e la curva más elemental toda en la cual el valor del punto en la generación te simplemente el valor xbest t sin calcular promedios como expresado en la ecuación vbest t xbest t dondef xbest t e la evaluación del mejor elemento la generación como algoritmo genético e eminentemente proceso estocástico búsqueda se hace necesario realizar muchos experimentos ejecuciones del mismo problema la misma parametrización para tener una visualización más real del comportamiento la población durante la generaciones tonces e común realizar muchas ejecuciones y por cada una ellas calcular la curvas online y la curva mejores elementos para luego mostrar sendas curvas la medias los puntos en la generaciones la ﬁgura no ilustra ejemplo curvas para una ejecución algoritmo evolutivo generaciones computación evolutiva en optimización numérica uso codiﬁcación binaria o real la representación binaria usada en algoritmos genéticos canónicos tiene la deﬁciencias alta dimensionalidad y distancia hamming que se cian principalmente en problemas optimizacion numérica funciones multidimensionales y alta precisión numérica exigida por ejemplo sea problema optimización ınf x la siguientes características x optimizar donde x mínima seis dígitos decimales al realizar la codiﬁcación para cada variable xise e decir que que la ﬁcación e esto generaría espacio búsqueda computación evolutiva en optimización numérica online curva curva localizaci y n pozos curvas monitoreo iteracionesvalor presente neto figura ejemplo curvas aproximadamente haciendo que para este problema la codiﬁcación binaria ofrecerá mal desempeño goldberg escribió el uso gene código real o punto ﬂotante e una larga y controversial historia en esquemas búsqueda evolutiva y genética artiﬁcial y su uso parece estar en aumento este creciente uso sorprende los investigadoresfamiliarizadosconlateoríaclásicadealgoritmosgenéticos esquemas baja cardinalidad lo que parece ser contraproducente la búsquedas empíricas que los algoritmos codiﬁcación real han mostrado en una serie problemas prácticos en se puede encontrar algunos ejemplos que comparan algoritmos genéticos codiﬁcación binaria y algoritmos genéticos ﬁcación real para problemas optimización numérica donde el desempeño los algoritmos genéticos codiﬁcación real siempre e más consistente obteniéndose resultados más precisos algoritmos evolutivos codiﬁcación real son algoritmos evolutivos cuya población xtestá compuesta por individuos xn donde cada n e decir gene que son números real pensando en una implementación computacional los soma serían listas arrayso vectores variable punto ﬂotante float double hecho los operadores genéticos deben tienen que adecuarse este tipo dato la arquitectura genérica del algoritmo genético se ne población evaluación selección reproducción ajustes en la selección y evaluación esta variante algoritmos genéticos tiene la siguientes algoritmos evolutivos se necesita codiﬁcación manteniendo la relación entre gene y bles por ejemplo dada la función objetivo f su representación en cromosoma será directamente una consecuencia esto e que mantiene la dimensionalidad original del problema precisión cada gene xidependerá la precisión la variable punto ﬂotante del lenguaje programación utilizado ﬂoat double extended para representar grandes dominios existe el problemas distancia hamming representación da la opción tratar restricciones triviales aunque también existen algunas desventajas sensu unalgoritmogenéticoconrepresentaciónrealnosigue la deﬁnición original algoritmo genético holland dado que al haber codiﬁcación existe genotipo se le considera algoritmo genético híbrido operadores genéticos especializados para tratar números real aplicación está limitada problemas optimización numérica espacio continuo y funciones real problemas restricciones en la literatura se encuentran muchos trabajos sobre algoritmos genéticos basados en números real siempre aplicados en problemas deﬁnidos en espacio búsqueda donde e decir que cada variable estaba restricta intervalo donde sin restricciones adicionales la dominio e importante colocar otras restricciones aparte éstas ya que e sabido que la mayoría problemas prácticos son hecho problemas restricciones en problema optimización numérica restricciones la forma trica del espacio búsqueda válido la característica más crítica la cual depende el grado diﬁcultad para encontrar una solución óptima al problema como fue mencionado en la sección si la forma geométrica del espacio búsqueda xesconvexa existe mucha teoría que garantiza la convergencia la solución óptima modelo genocop esta denominacion viene la letras iniciales genetic algorithm numericaloptimization constrained problem genocopesunmodelodealgoritmogenéticopresentadoen e implementado en lenguaje c adecuado para problemas optimización mérica la siguientes características funciones optimizar f x están deﬁnidas en espacio problema continuo conjunto restricciones lineales cl punto inicial válido o una población inicial válida los problemas optimización que genocop trata están deﬁnidos en dominio convexo que pueden ser formulados la siguiente manera optimizarf xq donde xq conjunto computación evolutiva en optimización numérica el dominio xestá deﬁnido por rangos variable q y conjunto restricciones dado que el conjunto x convexo demo aﬁrmar que para cada punto xq rango válido k right k la variable xk para el cual otras variable xi q permanecen ﬁjas en otras palabras para dado xk xq cumple que k right k y xq donde todos los xi q permanecen constantes bién se asume que cada intervalo k right k ser calculado cientemente si el conjunto restricciones entonces el espacio búsqueda convexo apenas limitado por la restricciones dominio left k right k esta propiedad e aprovechada en todos los operadores mutación y rantiza que los resultados sean siempre válidos si se muta la variable xk el rango mutación será conﬁnado al intervalo k right k otra propiedad los espacios convexos garantiza que dado do puntos lacombinaciónlineal estambiénun punto en x la propia deﬁnición convexidad esta propiedad permite deﬁnir operadores cruce el problema optimización la ecuación deﬁnido en espacio vexo que trata genocop e el siguiente optimizar una función f x donde xq sujeta los siguientes conjuntos restricciones restricciones dominio lq uq xq igualdades donde xq aij bp pe el número ecuaciones inecuaciones donde xq cij dm me el numero inecuaciones esta deﬁnición problema e genérica y utilizada por gran parte los ritmos optimización aplicados en investigación operativa restricciones lineales y cualquier función objetivo tratamiento restricciones por los operadores genocop genocop ofrece una forma generalizada manipular la restricciones e independiende del problema esto se logra combinando idea que son propias algoritmos genéticos y la teoría clásica problemas optimización numérica en contexto diferente así dado problema optimización numérica en genocop se hace lo siguiente eliminar la igualdades presentes en el conjunto restricciones esto signiﬁca eliminar pde variable del problema suponiendo que existan p restricciones igualdad g xq la dimensión del problema se reducirá la nuevas restricciones resultantes serán ciones lineales que mantienen la convexidad del espacio búsqueda el espacio búsqueda gresulta más simple que el espacio original del problema x obtener modelo cuidadoso los operadores genéticos tal que algoritmos evolutivos garantize la validez los individuos descendientes en el espacio queda gcon restricciones estetratamientofuncionaeﬁcientementecuandolasrestriccionessonlineales lo que e una condición suﬁciente para que el espacio problema xsea convexo en la técnicas programación lineal la restricciones igualdad son bienvenidas siempre que se asuma que sí existe el óptimo esté situado en la superﬁcie del conjunto convexo la inecuaciones se convierten en ecuaciones usando variable holgura y el método se ejecuta moviéndose vértice en vértice lo largo la superﬁcie en la metodología genocop la soluciones se generan aleatoriamente y la restricciones igualdad signiﬁcan problemas al ser eliminadas al inicio del proceso se reduce la dimensionalidad del problema en py por ende se reduce la dimensionalidad del espacio búsqueda en este cio búsqueda reducido se encuentra sólo restricciones desigualdad que mantienen la convexidad del mismo se asegura que cualquier combinación lineal soluciones generará soluciones válidas sin necesidad veriﬁcar la restricciones la inecuaciones se generan intervalos factibles para quier variable xi estos intervalos factibles son dinámicos y dependen los valores actuales la demás variable y pueden calcularse forma eﬁciente el siguiente ejemplo ilustra el mecanismo incorporado en el modelo genocop sea la función f x f x lnxj ser minimizada y sujeta al siguiente conjunto restricciones al observar la restricciones se ve que pueden eliminarse tres variable y dado que el nuevo problema acaba siendo mininizar f computación evolutiva en optimización numérica lnxj sujeto la siguientes restricciones luego hacer toda estas transformaciones el sistema ya puede crear su población inicial válida realizar el proceso evolución en sí inicializacion la población inicial unavezreducidaladimensionalidadaleliminar prestriccionesdeigualdad el algoritmo inicialización consiste en generar aleatoriamente los individuos cumplan la restricciones dominio usando k right k k u t n y veriﬁcando que cumplan la restricciones inecuaciones forma iterativa se genus valores xhasta encontrar elemento válido o hasta agotar el número máximo iteraciones una vez encontrado individuo válido e replicado en toda la población x en el caso que se logre ningún individuo se solicitará ingresar manualmente individuo válido operadores genéticos en genocop se deﬁnen operadores genéticos adecuados para tratar representación real los tres primeros son mutaciones unarias y los demás son crux que se describen y discuten continuación mutación uniforme este operador requiere único padre xy genus único descendiente la siguiente manera dado el vector xk xn seleccionar componente torioxk n generar el elemento nuevo k xn kes una generación valor aleatorio distribución uniforme u t dentro del intervalo k right k el operador mutación uniforme juega papel importante en fas ciales del proceso evolución al permitir que los individuos se muevan libremente en el espacio búsqueda este operador se hace más relevante dado que la población inicial está compuesta por réplicas punto válido enfasesmásﬁnalesdelaevolución esteoperadorpermiteescapardeóptimos locale dando la opción encontrar mejores algoritmos evolutivos mutación frontera este operador también requiere único padre xy genus unico diente en realidad se trata una variación la mutación uniforme pues el nuevo valor kserá cualquiera los valores dentro del intervalo válido k right k como se continuación dado el vector xk xn seleccionar componente torioxk q generar valor t generar el nuevo elemento k xn donde left k right k su importancia radica en problemas cuya solución óptima se encuentra muy cercadealgunadelasfronterasdelespaciodebúsqueda ma muchas restricciones sin embargo en problema sin restricciones y dominios amplios este operador e recomendable mutación uniforme la siguiente manera dado padre x se selecciona componente xk generar um valor t se obtiene el descendiente xk xn donde t right k t k en caso contrario la función t y devuelve valor en el intervalo y tal que la babilidad t y sea próxima vaya incrementándose acuerdo atque representa la generación en curso esa propiedad este rador se comporta como una mutación unifore al inicio tpequeño y medida que taumenta lá búsqueda se hace más local para esto se usa la siguiente función t y donderes número aleatorio distribución u t te el número máximo generaciones y be parámetro que determina el grado uniformidad cruce aritmético este operador e deﬁnido como la combinacion lineal do vectores sean do vectores para cruzarse los descendientes se obtienen como la combinación lineal conforme la ecuacion dondeαesunvaloraleatoriocondistribución u t deαy dado que espacio x convexo queda garantizada la clausura computación evolutiva en optimización numérica figura cruce aritmético descendientes medium aritmética los padre la ﬁgura ilustra este operador cruce simple se deﬁne este operador la siguiente manera dado vn cruzarse en la posición priori los descendientes serían uk vn vk que podrían estar fuera del espacio problema para evitar este inconveniente se aprovecha una propiedad los conjuntos convexos que aﬁrma tal que los elementos uk vk son válidos aún queda por encontrarse el mayor valor posible αtal que se haga el mayor intercambio información posible se usa método simple que consiste en comenzar veriﬁcar si al menos e ir decrementando los do descendientes tienden ser idénticos su padre y perteneciendo al dominio válido la figura no ilustra este procedimiento cruce heurístico e operador cruce único elemento por los siguientes motivos esteoperadorusaresultadosdelafunciónobjetivo f xi paradeterminar la dirección búsqueda genus único descendiente o puede generar descendientes el procedimiento e el siguiente dado do padre se obtiene único descendiente la siguiente regla algoritmos evolutivos v x figura cruce simple t y el individuo mejor o igual que o sea f si se trata una maximización y f si el problema e minimización e posible que el resultado en este caso se genus otro diente una nueva realización si después wtentativas se encuentra el operador ﬁnaliza sin producir descendientes en la ﬁgura se ilustra este operador e mejor soluci que f figura cruce heurístico este operador contribuye en la precisión la solución encontrada por el ajuste ﬁno y por dirigir la búsqueda en la dirección más promisoria restricciones lineales genocop iii esta nueva versión genocop incorpora el sistema genocop original ya descrito y lo extiende para tratar restricciones lineales aplicando el principio coevolución usando do poblaciones que se inﬂuyen mutuamente primera población sm se denomina puntos computación evolutiva en optimización numérica que sólo satisfacen la restricciones lineales forma similar al nocop original estos puntos pueden ser tratados los operadores especializados del genocop original manteniendo su validez para la restricciones lineales aunque puedan ser evaluados rn denominada puntos referencia cualquier punto risiempre e posible evaluar f ri habiendo diﬁcultad en encontrar punto referencia inicial se le pedirá al usuario que ingrese valor la ﬁgura ilustra ambas poblaciones los puntos referencia rial ser figura población búsqueda xsy población referencia xr válidos son evaluados directamente por la función objetivo f ri los puntos búsqueda sique pueden ser evaluados se reparan para convertirlos en puntos válidos como se continuación sea punto búsqueda e válido se selecciona punto referencia método lección rankingno lineal se generan varios valores nuevos se obtiene nuevos puntos búsqueda zicombinando linealmente sky rlusando los diversos αi rl si se encuentra ziválido se evalua y el valor obtenido se coloca como una sk sif zi rl entonces zireemplaza rlcomo nuevo punto cia eventualmente zireemplaza rlusando sorteo com probabilidad reemplazo pr la figura ilustra la reparación puntos búsqueda el modelo genocop iii supera muchas desventajas otros sistemas troduciendo sólo algunos parámetros adicionales tamaño la población puntos referencia xr probabilidad reemplazo pr y retornando pre una solución válida además el espacio búsqueda válido e algoritmos evolutivos figura reparación puntos búsqueda creando nuevos puntos referencia patrir los puntos búsqueda la cindad los mejores puntos referencia e explorada más frecuencia también algunos puntos referencia son colocados en la población xsde puntos búsqueda sometiéndose ser transformados por los operadores especializados genocop que preservan la restricciones lineales computación evolutiva en optimización combinatoria como fue visto en la secciones anteriores el objetivo problema optimización e maximizar o minimizar el valor una función real en espacio si se trata funciones del tipo f el espacio búsqueda e continuo y la optimización e numérica este tipo tratamiento se detalló en la sección anterior y su problema optimización consiste en encontrar axf x xn dondef x está sujeto la restricciones en cambio en problemas optimización combinatoria se busca optimizar una función f x xn donde φes espacio soluciones discreto y ﬁnito que puede ser formado la siguientes maneras como el producto cartesiano subconjunto xn n como el conjunto permutaciones φide conjunto xn n este último tipo problemas son tipo especial optimización natoria conocido como problemas computación evolutiva en optimización combinatoria figura ejemplos cromosomas que representan permutaciones φ algoritmos evolutivos discretos son algoritmos evolutivos cuyos cromosomas compuestos por gene valores discretos deﬁnition algoritmos evolutivos discretos sea una generación tcon una población xi m cada cromosoma compuesto por conjunto gene xn donde cada elemento xjpuede tomar alguno los valores del conjunto n e decir que el espacio problema xestá formado por el producto en caso más genérico dado cromosoma x cada gene puede asumir valores del conjunto ni que el espacio búsqueda sea igual al espacio del problema esté formado por el producto cartesiano algoritmo genético binario bajo la deﬁnición explicada el algoritmo genético binario e caso cular algoritmo evolutivo discreto la siguientes propiedades n conforme ya fue tratado en algoritmos evolutivos orden son algoritmos evolutivos cuya poblacion xtestá compuesta por individuos que son permutaciones φdel subconjunto ﬁnito xn mañon deﬁnition algoritmo evolutivo orden para una generación t sea φtuna población tamaño m φi m cromosoma compuesto por conjunto gene φi φi n donde elemento φi j e el elemento trados en la posición la permutación φi e claro que para do cromosomas φpyφq se cumplirá necesariamente que φp j j algoritmo evolutivo orden tiene la misma estructura que el algoritmo genético tradicional o el algoritmo codiﬁcación real ya que se nen los componentes básicos población selección evaluación reproducción la diferencia principal radica en los siguientes puntos la representación soluciones cuyos cromosomas son permutaciones φ losnelementos del conjunto como ejemplo suponiendo mutaciones elementos y conjunto tendríamos algunos cromosomas como ilustra la ﬁgura la permutaciones por sí solas representan soluciones existe la algoritmos evolutivos figura ejemplo mutación desorden sidad constructor soluciones que partir la ne y aplicando reglas y restricciones del problema codiﬁca la soluciones real que siempre serán válidas y posibles ser evaluadas los operadores cruce y mutación son especializados para tratar los cromosomas φi garantizando que sus descendientes sean siempre válidos mutación desorden dado único progenitor φ n se selecciona al azar una ϕdel cromosoma se desordenan los elementos en esta la ﬁgura ilustra este tipo operador mutación basada en orden dado progenitor φ n se seleccionan do componentes aleatorios b b el descendiente forma anteponiendo b ejemplo ilustrativo este operador se muestra en la ﬁgura φ b φ b φ figura ejemplo mutación orden mutación basada en posición dado progenitor φ n se seleccionan do componentes aleatorios b se forma el descendiente los valores b la ﬁgura no da ejemplo ilustrativo este operador φ b φ b φ figura ejemplo mutación basada en computación evolutiva en optimización combinatoria cruce uniforme orden dado los cromosomas se obtiene descendiente la siguiente forma obtener una máscara mkdenbitsbinarios rellenar los gene la posiciones tando sus posiciones originales crear una sublista ϕcon los elementos reordenar la sublista ϕpara que sus valores se vean en el mismo orden completar los espacios faltantes en la lista ϕreordenada el otro descendiente compondra aplicando el mismo procedimiento para una máscara negada mky aplicando el orden encontrado en la sublistaϕ la ﬁgura ilustra este tipo operador ordenados por gene ordenados por figura cruce uniforme orden cruce sublista bastante similar al cruce uniforme orden dado los cromosomas se obtiene descendiente la siguiente forma separar una sublista ϕdel cromosoma crear el descendiente los espacios dejados por la sublista ϕcon sus mismos valores respetando el orden en el que se encuentran en el cromosoma el otro descendiente compondra aplicando el mismo procedimiento en los individuos pertenecen la posiciones la sublista recolocándolos en el orden encontrado en el cromosoma problemas optimización combinatoria el problema la mochila conocido como knapsack problem consiste en cursionista que tiene nobjetos para llevar en su mochila pero debe decidir cuáles colocará cada objeto tiene valor vjy pesowj la mochila porta peso máximo el problema ilustrado en la ﬁgura consiste en seleccionar entre los nobjetos los que colocará tal que den el máximo beneﬁcio sin sobrepasar el peso máximo soportado por la algoritmos evolutivos figura knapsack problem formulación clásica el problema la mochila se puede formular la siguiente manera sea xn vector cuyos elementos están cionados cada objeto ia colocarse en la mochila acuerdo la siguiente deﬁnición colocado entonces el problema consiste en maximizar el valor total cargado e decir sujeto la restricción esta forma modelar que siendo típica modelo programación tera e fácilmente llevada una forma evolutiva si se deﬁne el individuo xn que pertenece espacio búsqueda bn así se pueden aplicar los métodos inicialización selección operadores cruce y ción que ya fueron estudiados en los algoritmos evolutivos codiﬁcación binaria cabe resaltar que en esta modelación el principal problema e el manejo la restricción la ecuación formulación como problema orden el problema la mochila puede verse la siguiente manera φi φi n cromosoma permutación que representa ordenide los objetos colocar en la mochila se construye una solución iasociada la permutación φicolocando los objetos en el orden dado por φi φi φi k donde el elemento computación evolutiva en optimización combinatoria figura ejemplo grafo conectado e el último colocar sin rebasar el peso máximo permitido los mentos restantes φi φi φi n restantes se consideran en la solución la evaluación será precisamente la suma los peso los objetos efectivamente colocados en la mochila la cantidad objetos efectivamente colocados en la mochila e interesante destacar que esta codiﬁcación del problema y el uso constructor solucions cualquier cromosoma generará una solución válida problema grafos ejemplo aplicación algoritmo genético orden e el problema coloreo grafos que se continuación sea grafo dirigido g v e como el la ﬁgura cuyos vértices vi g son ponderados peso pi existe una función f relaciona vértices y peso la cual consiste en los coloreos válidos hasta kcolores donde se puede usar mismo color entre nodos adyacentes el valor fpuede ser la suma los peso los nodos coloreados una optimización realizar e colorear nodos o vértices este grafo forma tal que se maximice f o sea la suma total los peso este tipo problemas e que puede reducirse tiempo nomial para grafos perfectos o grafos sin vértices grado este tipo problemas sirven como base para los problemas asignación recursos que son muy aplicados en el mundo real aún más si los vértices del grafo son ponderados se trata recursos cuandiﬁcables donde recurso e mejor que algoritmos evolutivos algoritmo greedy el algoritmo greedyes simple para el problema colorear grafos y e el que ilustra el algoritmo algorithm algoritmo greedy lista colores cj ncordenar losnnodosv g del grafo mayor menor por su peso p nveriﬁcar si se puede colorear concjel nodovi g colorearvi g si la veriﬁcación e válida este algoritmo se caracteriza por su simplicidad y facilidad ción esperándose llegar la solución óptima global aunque dada su visión local ver la mejor decisión inmediata siempre conducirá la solución óptima global aplicando al grafo la ﬁgura la lista nodos en orden decreciente peso será si la aplicamos para tenemos la siguiente solución cuyo gráﬁco se ilustra en la ﬁgura figura grafo coloreado por el algoritmo goloso para si son considerados colores la solución encontrada será cuyo gráﬁco se ilustra en la ﬁgura en el grafogde la ﬁgura el algoritmo greedyya será la mejor opción se inicia y se detiene en el nodo modelo algoritmo evolutivo orden para tratar el problema grafos se aprovecha parte del miento usado en la estrategia greedysumado la técnicas la computación evolutiva como se en la tabla en cierto modo se está modelando algoritmo evolutivo computación evolutiva en optimización combinatoria figura grafo coloreado por el algoritmo goloso para figura grafo que e adecuado para el algoritmo goloso traveling salesman problem tsp esteproblemaubhasidounodelosmásestudiadoseneláreadeinvestigación operativa por lo que merece una atención especial cuando la teoría la complejidad algorítmica se desarrolló el tsp fue uno los primeros problemas en estudiarse probando karp en que pertenece la clase los problemas desde los métodos ramiﬁcación y acotación hasta los basados en la binatoria poliédrica pasando por los procedimientos metaheurísticos todos han sido inicialmente probados en el tsp convirtiéndose en una prueba obligada para técnica resolución problemas enteros o combinatorios el problema del viajante puede enunciarse del siguiente modo viajante comercio ha visitar n ciudades comenzando y ﬁnalizando en su cuadro algoritmo evolutivo versus estrategia greedy estrategia greedy algoritmo evolutivo crearunalistadenodosenorden decreciente pesocrear una lista nodos en el den dado por el cromosoma ambo construyen la solución barriendo la lista y colocando colores algoritmos evolutivos figura ejemplo ciclo hamiltoniano pia ciudad conociendo el coste ir cada ciudad otra determinar el recorrido coste mínimo el problema se enuncia formalmente la siguiente manera sea grafo v c dondeves el conjunto vértices aes el arista y cij e la matriz costos donde cijes el costo o distancia la arista j o cadena e una sucesión arista ek en el vértice ﬁnal cada arista coincide el inicial la siguiente también puede representarse por la sucesión vértices utilizados camino e simpleo elemental si utiliza el mismo vértice más una vez camino ek en el que el vértice ﬁnal ek coincide el inicial ciclo e simplesi lo e el camino que lo deﬁne e ciclo simple que pasa por todos los vértices del grafo ciclo hamiltoniano e ciclo simple que pasa por todos los vértices del grafo así el problema del viajante consiste en determinar tour costo mínimo e decir encontrar el ciclo hamiltoniano menor costo como el mostrado para el caso vértices en la ﬁgura se puede considerar sin pérdida generalidad que el grafo e completo e decir que para cada par vértices existe una arista que los une notar que ser así siempre se puede añadir una arista ﬁcticia entre do vértices el costo del camino más corto que los une entre la aplicaciones más importantes del tsp se puede destacar circuitos integrados vehículos robotizada material en almacenes componentes en ordenadores en otras aplicaciones la ﬁgura ilustra la aplicación del problema tsp para encontrar computación evolutiva en optimización combinatoria figura ejemplo caminos más cortos tsp mejor ruta entre algunas ciudades francia representación e inicialización el objetivo traveling salesman problem cuando existen restricciones se resume encontrar el ciclo hamiltoniano menor costo en grafo completo que se caracteriza como problema orden n el conjunto la nciudades ser visitadas entonces se deﬁne cromosoma tipo permutación φ φ n que representa orden visita la ciudades propuesto función evaluación la evaluación consiste en encontrar la distancia total recorrida por el ro entonces e necesario tener la información distancias entre toda la ciudades visitar dada por una matriz distancias dij dondedijes la distancia entre la ciudades iyj dado determinado orden visitas φ φ n el cálculo la distancia total sería efectuado como en la ecuación φ n φ dondedφ φ e la distancia entre do ciudades subsecuentes y dφ n φ e la distancia entre la última ciudad visitada y la primera ciudad si se excluye la ruta retorno la última la primera ciudad la evaluación sería φ operadores genéticos para este problema se pueden aplicar los operadores genéticos orden como uniforme basado en orden desorden basada en orden basada en algoritmos evolutivos otros algoritmos búsqueda eda scatter search los algoritmos genéticos gas que inicialmente fueron llamados plane productivos holland son actualmente el representante más popular la computación evolutiva este algoritmo deﬁnido por john koza como unalgoritmomatemáticoaltamenteparalelo quetransformaunconjuntode objetos matemáticos individuales cada uno valor aptitud en poblaciones nuevas utilizando operaciones modeladas bajo el principio darwiniano la reproducción y supervivencia los más aptos mente después la ocurrencia los operadores genéticos koza ha mostrado ser gran utilidad en la solución problemas prácticos real la siguiente ﬁgura muestra la versión más simple del algoritmo genético conocida como algoritmo genético simple sga por sus siglas en inglés en ella se muestra que para implementar algoritmo genético en la solución problema e necesario contar mecanismo que permita zar o generar una población p t individuos que corresponden posibles soluciones del problema esto implica que debemos modelar la posibles soluciones al problema que estamos abordando alguna manera que sea factible generarlas mediante algún mecanismo automático posteriormente e necesario contar una herramienta que sea capaz evaluar la dad cada uno los individuos que constituyen la población actual la evaluación individuos debe ser capaz discernir entre aquellos que sentan buenas soluciones al problema aquellos que lo son premiando los que son mejores continuación e necesario encontrar la forma generar nuevas soluciones al problema partir la que ya se tienen y que por su calidad son soluciones prometedoras la soluciones individuos que se usarán para generar la siguiente generación p deben ser da cuidadosamente debido que la nuevas soluciones deben producirse partir la que ya se tienen e necesario establecer mecanismos mación la soluciones seleccionadas estos mecanismos transformación son los operadores genéticos cruzamiento y mutación el proceso descrito debe ser repetido hasta que se alcance algún criterio paro previamente establecido algoritmo genético simple sea el contador generaciones inicializa p t evalúa p t mientras se cumpla criterio paro hacer para hacer selecciona padre p t ii aplica cruzamiento los do padre probabilidad p c iii muta la descendencia probabilidad p m iv introduce los do nuevos individuos en p finpara b p t c evalúa p t d finmientras pesar la simplicidad del algoritmo genético se ha demostrado otros algoritmos búsqueda eda scatter search cadenas markov que cuando los algoritmos evolutivos emplean elitismo convergerán al óptimo global ciertas funciones cuyo dominio puede ser espacio arbitrario günter rudolph en generalizó los desarrollos previos en teoría la convergencia para espacios búsqueda binarios y euclidianos espacios búsqueda generales rudolph como consecuencia del enorme éxito que mostraron tener los algoritmos néticos desde que goldberg los popularizó su publicación berg y teniendo en cuenta que la calibración todos sus parámetros probabilidad cruce probabilidad mutación tamaño la población aparecióhacealgunosañosunanuevaramadelacomputaciónevolutiva conocida como algoritmos estimación la distribución edas por sus siglas en inglés estos algoritmos representan una alternativa los métodos heurísticos estocásticos existentes que necesitan el ajuste número alto parámetros y que además no permiten explorar la interrelaciones entre la variable usadas en la representación soluciones los edas tienen funcionamiento muy parecido al su predecesor ritmo genético en el sentido que partir una población soluciones problema y grupo alteraciones sobre éstas se construye una nueva población evolucionada sin embargo en lugar hacer uso los operadores genéticos clásicos cruzamiento y mutación se utiliza la estimación la distribución adyacente subconjunto la población para te utilizar esta estimación en la generación una nueva población en base su muestreo otra diferencia importante entre los edas y los ag e que en éstos últimos la interrelaciones entre la variable se manejan manera implícita mientras que en los edas se expresan explícitamente mediante la distribución probabilidad asociada los individuos seleccionados cada población continuación se presenta el pseudocódigo general esta estrategia pseudocódigo eda el algoritmo clásico eda puede ser descrito mediante los te pasos generación aleatoria m individuos población inicial repetir los pasos para la generación hasta que se alcance criterio parada seleccionar n individuos desde acuerdo método selección estimar la distribución probabilidad pl x del conjunto individuos seleccionados muestrear m individuos población nueva desde pl x donde e el tamaño la población hace referencia la algoritmos evolutivos x representa la distribución probabilidad la población ﬁn trabajar acuerdo al pseudocódigo anterior el primer paso e la generación una población posibles soluciones al problema que demo resolver el mecanismo clásico generación la población inicial en eda e aleatorio sin embargo también e factible que se implemente una generación conducida la soluciones la que iniciará la búsqueda el algoritmo este primer paso del eda reﬂeja que para que el proceso lutivo tenga lugar se debe partir grupo inicial posibles soluciones al problema que se plantea al igual que en el algoritmo genético en el eda la soluciones deben haber sido codiﬁcadas manera que sea factible generarlas manera automática los siguientes pasos del algoritmo se deben repetir tantas veces como el número generaciones que se vaya manipular o hasta que se haya zado criterio paro especíﬁco ejemplo criterio paro común para estos algoritmos e cuando la mejor solución obtenida mediante el ceso evolutivo presenta error menor cierta tolerancia para los casos en los que se conoce la solución deseada o cuando la diferencias entre la mejor solución una población y la siguiente se encuentran por debajo valor previamente establecido los pasos al son los que comprenden el proceso evolución la poblaciones mediante la estimación la distribución cada generación en primer término se debe establecer método selección para obtener subconjunto la población tamaño n donde n en cada paso del proceso evolutivo los métodos selección pueden ser do tipos acuerdo al mecanismo que la conduce estocásticos y determinísticos la selección estocástica e aquella en la que la probabilidad que viduo sea escogido depende una heurística algunos ejemplos ésta son la selección por la regla la ruleta y la selección por torneo por otro lado la selección determinística e aquella que deja lado al azar y cuya pal motivación e homogeneizar la características la población para que prevalezcan solamente la los en esta categoría se han explorado esquemas en los que por ejemplo los individuos más aptos se cruzan los menos aptos la población pavez una vez que se ha seleccionado el conjunto individuos la ción se realiza la estimación su distribución probabilidad acuerdo al nivel interacción entre la variable que el modelo probabilístico toma en consideración los edas se clasiﬁcan en tres tipos aquellos en los que se asume independencia entre la variable que forman el modelo do aquellos en los que se asume que la interacciones se dan entre pares variable bivariados y aquellos en los que la distribución probabilidad modela la interacciones entre más do variable multivariados otros algoritmos búsqueda eda scatter search otra clasiﬁcación los edas los agrupa en función al tipo bles que involucran en continuo discretos y mixtos una vez que se ha realizado la estimación la distribución del grupo dividuos la generación se procede la construcción una nueva población obtenida mediante el muestreo la función probabilidad obtenida pl x el primer eda desarrollado y el más utilizado hasta el momento e el que supone una distribución marginal univariada conocido por sus siglas en glés como umda univariate marginal distribution algorithm mhlenbein paa el pseudocódigo este algoritmo suponiendo una codiﬁcación binaria la soluciones se muestra continuación pseudocódigo del algoritmo umda generación aleatoria m individuos población inicial hastaquesealcance criterio parada seleccionar n individuos desde acuerdo método selección la probabilidad que el elemento una solución tenga el valor pi xi n dondeδj el elemento del individuo seleccionado e xi y en caso contrario generar m individuos población nueva tal que para cada elemento la probabilidad que tome valor xy pl xi ejemplo del uso del umda en el problema del máximo número unos la forma más simple entender el funcionamiento estos algoritmos e mediante ejemplo manera que continuación se el uso del umda en la solución problema optimización académico conocido como onemax problem o problema del máximo número unos supongamos que no interesa maximizar el número unos una ción que se representa como cadenas binarias longitud e decir no interesa maximizar f x el primer paso del algoritmo consiste en generar una población m posibles soluciones este problema debido que cada posible solución se ta como una cadena caracteres en la que cada elemento puede tomar los valores o exclusivamente una forma generar automáticamente estas soluciones puede ser mediante la distribución probabilidad siguiente x xi donde la probabilidad que cada elemento xi sea igual e xi algoritmos evolutivos ﬁn que el ejemplo sea breve no limitaremos trabajar ciones individuos o posibles soluciones al problema consideremos que inicialmente se supone que para cada variable la probabilidad que sea se generará número aleatorio r comprendido entre y si el número generado e menor que la variable la solución xiserá si el número generado fuera mayor o igual que el valor la variable deberá ser mediante el uso este mecanismo se genus la población viduos que se muestra en la tabla tabla población inicial f x como se muestra en la tabla anterior una vez que se ha generado la ción la que se trabajará e necesario que cada uno sus individuos sea evaluado para continuar el proceso selección enseguida deberemos seleccionar la población inicial grupo individuos n acuerdo criterio selección para el ejemplo usaremos individuos los individuos seleccionados para nuestro plo serán aquellos una evaluación más alta individuos y este grupo elementos sel será el insumo para estimar los parámetros la distribución probabilidad que conducirá la generación la nueva ción individuos la tabla muestra el grupo individuos seleccionados y la probabilidad que el xi sea en nuestro ejemplo se esta asumiendo que la variable son independientes por lo que necesitamos parámetro para cada una ellas los parámetros son calculados en base su frecuencia tabla individuos seleccionados mediante el muestreo la distribución probabilidad obtenida en el paso anterior x ver ecuación se procede la generación la siguiente población x otros algoritmos búsqueda eda scatter search f x p x la tabla muestra la población obtenida partir x tabla población f x partir esta nueva población se deberá seleccionar nuevamente los mejores individuos ver tabla para recalcular el vector babilidad cada variable x tabla individuos seleccionados f x p x ese nuevo vector p x deberemos repetir el muestreo la siguiente blación y seguir repitiendo el proceso hasta que se cumpla algún criterio paro como se aprecia entre la poblaciones d d la soluciones cada blación comienzan ser cada vez mejores en nuestro ejemplo ya aparece la solución óptima f x en la población d se espera que al seguir iterando nuestro vector probabilidad vaya incrementando sus valores hasta llegar al probabilidad que cada variable tenga valor algoritmos evolutivos otros algoritmos estimación la distribución como se mencionó anteriormente los diferentes algoritmos propuestos en el campo los edas pueden ser agrupados acuerdo la complejidad del modelo empleado el umda corresponde al modelo más simple debido que supone que existe interacción entre la variable la desventaja este modelo e que en la práctica e frecuente que la variable que describen fenómeno posean dependencias unas otras otro algoritmo univariado que supone la ausencia dependencia entre la variable muy popular e el conocido como pbil por sus siglas en inglés incremental learning baluja el mecanismo funcionamiento este algoritmo consiste en el reﬁnamiento del modelo en cada generación del proceso evolutivo en lugar la estimación nuevo modelo por cada generación como se hace en el umda e decir que en el pbil para cada paso reﬁnamiento del modelo se consideran todos los pasos anteriores en la medida que el modelo empleado para la estimación la distribución se vacomplicando jor forma lo que ha llevado los investigadores proponer algoritmos como el mimic por sus siglas en inglés mutual information maximizing input clustering algorithm bonet et al otro algoritmo que supone dependencias entre pares variable y que diferencia del mimic utiliza árboles en lugar cadenas e el comit siglas en inglés combining optimizers mutual information tree baluja dabies el comit e algoritmo que utiliza el algoritmo maximum weight ning tree mwst propuesto por chow y liu chow y liu este algoritmo realiza la estimación la distribución probabilidad en cada generación mediante una red bayesiana estructura árbol otro representante los algoritmos que consideran que la dependencias tre variable se presentan por pares e el algoritmo bmda en el que pelikan y mühlenbein proponen una factorización la distribución probabilidad conjunta que sólo necesita estadísticos segundo orden este algoritmo está basado en la construcción grafo dependencias dirigido acíclico que necesariamente e conexo pelikan mühlenbein finalmente se encuentran los algoritmos que suponen modelo dencias múltiples entre variable estos algoritmos proponen la construcción modelo gráﬁco probabilístico en el que hay restricción en el número depadresquepuedetenercadavariable demaneraquelaestructuraadquiere una complejidad mucho mayor que los modelos anteriores como ejemplo algoritmos esta categoría se encuentran el ecga extended compact genetic algorithm presentado por harik harik et el algoritmo fda o algoritmo distribución factorizada factorized distribution rithm propuesto por mühlenbein y sus colaboradores mühlenbein et y entre otros el ebna estimation bayesian network algorithm o algoritmo estimación redes bayesianas presentado por etxeberria y larrañaga etxeberria y larrañaga actividades aprendizaje muchos los algoritmos mencionados tienen una versión para entornos continuo además otro grupo algoritmos creados especialmente para trabajar problemas naturaleza continuum que como en el caso tornos discretos siguen la misma clasiﬁcación en la actualidad la búsqueda mejoras este tipo algoritmos así como su aplicación problemas real e materia investigación actividades aprendizaje responda los siguientes cuestionamientos e el signiﬁcado la siglas eda explique el signiﬁcado la siglas umda explique la principales diferencias entre el algoritmo genético y el ritmo estimación la distribución mencione el nombre do algoritmos estimación la distribución que trabajan bajo el supuesto que la variable del modelo son pendientes mencione el nombre algoritmo que lecturas adicionales larrañaga lozano j estimation distribution algorithm new tool evolutionary computation genetic algorithm evolutionary computation kluwer academic publisher este e libro rencia sobre los algoritmos estimación la distribución pues comprende una colección artículos detallados y explicados ampliamente sobre el ma santana larrañaga y lozano research topic discrete timation distribution algorithm based factorization memetic puting este trabajo muestra una recopilación del trabajo realizado la intención mejorar el campo los edas referencias baluja incremental learning method ting genetic search based function optimization competitive ning technical report tr carnegie mellon university baluja davy combining multiple optimization run timal dependency tree technical report tr carnegie mellon university chow c liu aproximating discrete probability distribution dependence tree ieee transaction information theory vol pp bonet isbell viola mimic finding optimum algoritmos evolutivos estimating probability density proceeding neural information cessing system pp etxeberria y larrañaga global optimization bayesian network enspecialsessionondistributionsandevolutionaryoptimization la habana cuba ii symposium artiﬁcial intelligence goldberg genetic algorithm search optimization machine learning harik lobo y golberg compact genetic gorithm en proceeding ieee conference evolutionary tation pp piscataway nj holland j adaptation natural artiﬁcial system university michigan press ann arbor mi mit press cambridge ma koza genetic programming programming computer mean natural selection mit press cambridge massachussetts lozano larrañaga inza bengoetxea new nary computation advance estimation distribution algorithm berlin heidelberg new larrañaga lozano y mühlenbein algoritmos estimación distribuciones en problemas optimización combinatoria revista mericana inteligencia artiﬁcial asociación española para la inteligencia artiﬁcial num mhlenbein paa recombination gene estimation distribution binary parameter et lecture note computer science parallel problem solving ture ppsn iv pp mühlenbein y mahning fda scalable evolutionary rithm optimization additively decomposed function evolutionary computation pavez soto urrutia y curilem selección determinística y cruce anular en algoritmos genéticos aplicación la planiﬁcación unidades térmicas generación ingeniare revista chilena ingeniería en línea vol disponible en internet url http visitado en enero pelikan mühlenbein bivariate marginal distribution rithm advance soft design manufacturing pp referencias rudolph convergence evolutionary algorithm general search space proceeding ieee conference evolutionary computation talbi metaheuristics design implementation editorial wiley son publication fogel michalewicz editor handbook evolutionary computation iop publishing bristol uk uk edition bellman dynamic programming princeton press princeton nj deb k advanced algorithm operator page eiben smith introduction puting berlin heidelberg berlin fogel editor evolutionary computation fossil record selected reading history evolutionary algorithm institute electrical electronic engineer new york fogel j artiﬁcial intelligence simulated john wiley new york fogel owen walsh j artiﬁcial ce simulation evolution maxﬁeld callahan fogel editor biophysics cybernetic system proceeding second cybernetic science symposium page spartan book shington glover laguna tabu search kluwer academic norwell massachusetts goldberg genetic algorithm search reading goldberg genetic algorithm virtual alphabet blocking university illinois report haykin neural network comprehensive foundation tice hall ptr upper saddle river nj usa second edition holland concerning eﬃcie nt adaptive system yovits jacobi goldstein editor algoritmos evolutivos page spartan book washington holland outline logical theory adaptive system journal association computing machinery holland adaptation natural artiﬁcial system versity michigan press ann arbor michigan ﬁrst edi tion kirkpatrick gelatt vecchi optimization simulated annealing science kuhn tucker nonlinear man editor proceeding berkeley symposium page berkeley ca berkeley university calif ornia press mathews b partition number london mathematical society volume xxviii page michalewicz z genetic algorithm data structure evolution program new york edition neumaier global optimization constraint ceedings cicolac workshop search project global integratingconvexity optimization algebraic geometry pauling nature chemical bond cornell univ press mineola ny rao engineering optimization theory practice john ley son edition rechenberg evolutionsstrategie optimierung nach prinzipien der biologischen evolution holzboog gart alemania reef b modern heuristic technique blems john wiley son great britain rudolph convergence analysis canonical genetic algorithm ieee transaction neural network russell norvig artiﬁcial modern proach prentice hall upper saddle river new jersey second edition schiﬀ cellular automaton discrete view world interscience schwefel numerische optimierung von referencias mittels der evolutionsstrategie birkhauser basel alemania spencer principle biology volume london burgh williams norgate ﬁrst edition van der hauw j evaluating improving steady state evolutionary algorithm constraint satisfaction problem master s computer science department leiden university leiden francisco javier ornelas zapata julio cesar ponce gallegos universidad autonoma aguascalientes mexico introducción la invención la computadora dotó los seres humanos una ta poderosa para auxiliarle en la resolución problemas sin embargo los algoritmos tradicionales siempre han servido o han sido óptimos para la resolución cierto tipo problemas donde el espacio búsqueda o el número soluciones e único por tal razón se comenzaron abstraer fenómenos naturales y modelarse primero forma matemática y después computacionalmente en intento dar respuesta problemas que otra forma e muy difícil resolver este tipo técnicas para la solución problemas se le dio el nombre técnicas bioinspiradas debido que intentaban copiar modelos nómenos naturales el primer trabajo data la década cuando el cientíﬁco frank semblatt desarrolla en la universidad cornell modelo la mente humana través una red neuronal y produce primer resultado al cual llama perceptrón este trabajo constituye la base la redes neuronales hoy en día la redes neuronales son paradigma aprendizaje y procesamiento automático inspirado en la forma en que funciona el cerebro para realizar la tareas pensar y tomar decisiones sistema nervioso el cerebro se trata sistema interconexión neuronas en una red que colabora para producir estímulo salida por otro lado tenemos los algoritmos genéticos los cuales se basan en la evolución biológica y su base esta técnica tuvo sus inicios en el cientíﬁco john holland estos algoritmos hacen evolucionar una población individuos sometiéndola acciones aleatorias semejantes la que actúan en la evolución biológica mutaciones y recombinaciones genéticas así como también una selección acuerdo algún criterio en función del cual se decide cuáles son los individuos más adaptados algoritmos bioinspirados sobreviven y cuáles los menos que son descartados ya que se basan en la teoría la evolución la especies propuesta por charles darwin sistema inmune artiﬁcial los sistemas inmunes artiﬁciales son sistemas computacionales adaptativos cuya inspiración está basada en los diferentes mecanismos del sistema inmune biológico especialmente los mamíferos la ﬁnalidad solucionar problemas ingeniería complejos en los que los investigadores del área han mostrado resultados exitosos cruz cortés existen también los algoritmos clasiﬁcados como swarm intelligence que son técnicas metaheurísticas bioinspiradas que en especial modelan el portamiento agentes que trabajan colaborativamente para resolver ciones que se presentan en la naturaleza inteligencia colectiva basados en los modelos naturales comportamiento animales que viven en colonias parvadas enjambres o bancos como colonias hormigas termitas abejas patos peces entre otros en este capítulo trataremos poco más fondo algunos estos ritmos como son la colonias hormigas y los algoritmos optimización cúmulo partículas pso particle swarm optimization que se basan en el comportamiento la parvadas pájaros swarm intelligence swarm intelligence o inteligencia colectiva puede ser visualizado como una metáfora la naturaleza que permite resolver problemas distribuidamente basándose en la vida social cierto tipo animales y avispas en la construcción del nido en la construcción del panal en la búsqueda y obtención alimento pájaros en sus movimientos en bandada peces en caza swarm intelligence son técnicas metaheurísticas bioinspiradas que en cial modelan el comportamiento la inteligencia colectiva algunas la técnicas que se clasiﬁcan dentro este tipo algoritmos son algoritmos cúmulos partículas particle swarm optimization pso algoritmos colonias hormigas ant colony optimization aco algoritmos basados en la polinización abejas artiﬁciales artiﬁcial bee colony abc algoritmodecúmulosbasadoenespaciosgeométricos geometricpso gpso swarm intelligence swarm intelligence se desarrolló para intentar resolver problemas donde el espacio búsqueda e muy grande y además pueden existir varias ne al problema planteado generalmente se aplica problemas conocidos como en este tipo problemas generalmente se busca obtener una la mejores soluciones toda la posibles soluciones que puedan existir se busca una optimización través la maximización o minimización objetivo conocido como función objetivo el cual puede ser modelado desde una simple ecuación hasta complejo sistema reglas dependiendo del dominio aplicación en nuestros días la técnicas inteligencia colectiva swarm intelligence tienen una variedad aplicaciones en distintas áreas y problemas co como por ejemplo minería datos abraham grosan ramos parpinelli lope freitas enrutamiento vehículos ventanas tiempo bardella taillard agazzi problema del agente viajero dorigo gambardella enrutamiento en redes comunicación dis mark arabshahi gray entrenamiento redes neuronales para identiﬁcar impedancia peng venayagamoorthy ne control robot para la eliminación aceite contaminante en el mar fritsch wegener schraft entre otros optimización colonias hormigas ant colony optimization aco los algoritmos colonias hormigas son una metaheurística bioinspirada en el comportamiento estructurado la colonias hormigas naturales donde individuos muy simple una colonia como aprecia en la ﬁgura se comunican entre sí por medio una sustancia química denominada romona estableciendo el camino más adecuado entre el hormiguero y una fuente alimentación lo que e comportamiento e muy interesante rigo maniezzo colorni los algoritmos optimización colonias hormigas se han también como algoritmos constructivos por la forma en que trabaja por dentro el algoritmo ya que cada hormiga construye una solución al ma recorriendo grafo construcción al ir estado otro dentro del espacio estados el espacio estados puede ser representado por grafo en el que vértice representa estado y cada arista del grafo representa los posibles pasos o acciones que la hormiga puede realizar normalmente cada arista tiene asociada información acerca del problema que guía el vimiento la hormiga la información asociada e el rastro feromonas y la visibilidad la distancia en estos algoritmos la hormigas escogen donde ir una manera probabilística dorigo maniezzo colorni en la ﬁguras y se muestra como e diferente la concentración algoritmos bioinspirados entre los do caminos figura comportamiento la hormigas para generar caminos entre su nido y la fuente alimento el algoritmo colonia hormigas ha sido aplicado el paso del tiempo para resolver diferentes problemas obteniendo cada vez mejores resultados debido los cambios en el poder computacional algunos los problemas solucionados aco sus desarrolladores así como sus principales rísticas son el que fue el primer algoritmo colonia hormigas desarrollado por marco dorigo el algoritmo gambardella dorigo e sistema híbrido del algoritmo modelo aprendizaje por refuerzo muy conocido bullnheimer hartl strauss e una variación del en el cual la actualización la feromonas se realiza depositando una tidad feromona entre ciudades por cada hormiga y se suma la cantidad esta los caminos por los que pasaron la n mejores hormigas además se realiza incremento adicional si la mejor hormiga viajó por esa ruta ant colony ac dorigo gambardella e algoritmo que e una extensión del ant stützle hoos este algoritmo se riza por solo actualizar los rastros feromona la mejor hormiga cada ciclo y se establecen valores máximos y mínimos como límites en la lación feromona asga white pagurek oppacher e algoritmo híbrido tre y ga en el cual se utiliza el ag para adaptar los parámetros del tal forma que la búsqueda se va adaptando en base los resultados pilat white e algoritmo el cual incorpora una hibridación entre algoritmo genético y el algoritmo swarm intelligence figura algoritmo para la implementación del método búsqueda colonia hormigas algoritmo general procedimiento och mientras criterio terminacion este satisfecho para cada hormiga fin para si para cada arco visitado algoritmos bioinspirados fin mientras fin procedimiento procedimiento inicialización la feromonas procedimiento para cada arco del grafo existente colocar concentracon inicial c feromona fin procedimiento procedimiento donde se colocan la hormigas en su posición inicial procedimiento repetir desde hasta m crear hormiga y colocar en su nodo inicial actualizar lista tabu fin repetir fin procedimiento procedimiento para generar una solución procedimiento mientras el criterio para obtener una solucion este satisfecho fin mientras fin procedimiento procedimiento para mover una hormiga lugar otro procedimiento para todo el vecindario factible la formula fin para si swarm intelligence fin procedimiento la probabilidad que una hormiga seleccione uno los posibles caminos está dada por la siguiente formula una vez que cada hormiga ha generado una solución esta se evalúa y puede depositar una cantidad feromona que e función la calidad su ción y está dada por la fórmula tabla visibilidad la visibilidad está dada por información especíﬁca del problema y e sentada por la letra n en el caso especíﬁco del problema del agente viajero al ser problema minimización está dado por el inverso la distancia n la visibilidad e representada través una matriz tabla feromonas la feromona e la representación la concentración depositada por la migas través del tiempo algunas pueden ir disminuyendo debido la poración ejemplo simple en este ejemplo solo se hará una pequeña demostración cómo se realiza el procedimiento para dar solución problema por medio el mo colonia hormigas se realizara el ejemplo completo por lo que el ﬁn esto e mostrar los pasos necesarios para que el alumno sepa manejarlo se cuenta el siguiente grafo primero se obtiene la instancia del problema matriz distancia se inicializan la feromonas matriz feromonas algoritmos bioinspirados figura muestra el grafo que se genus basado en el problema abcdef abcdef se obtiene la matriz visibilidad distancia se colocan la hormigas aleatoriamente lista tabú paso se toma la hormiga k que en este caso sería la hormiga en el nodo ahora se obtienen los nodos permitidos los cuales se puede desplazar paso se obtienen la probabilidades utilizando la siguiente swarm intelligence abcdef hormiga b hormiga d hormiga figura muestra la inicialización del recorrido posicionando una hormiga en el nodo al azar figura muestra los nodos validos partir del nodo actual dónde k número hormigas nodos origen j nodo desplazarse importancia la feromona importancia la algoritmos bioinspirados valor tomado la matriz feromonas valor tomado la matriz visibilidad paso se escoge el siguiente nodo aleatoriamente tomando en cuenta la probabilidades la cuales se calcularon en el paso anterior para esto mo numero aleatorio entre numero aleatorio nodo nodo c nodo d nodo e no ﬁjamos en cual rango encaja el número aleatorio y ese será nuestro nodo seleccionado en este caso el nodo al que no desplazaremos e al nodo paso una vez se ha seleccionado el nodo al cual desplazarse este se agrega la lista tabú y se traza el recorrido la hormiga para ver si aún hay nodos candidatos disponibles hormiga bd hormiga d hormiga así e como quedaría el recorrido después agregar nodo la lista tabú paso checar si aún hay nodos candidatos disponibles si los hay se petirá el nuevamente todo este proceso desde el paso swarm intelligence figura muestra el movimiento la hormiga basado en el proceso evaluación al ver el grafo podemos apreciar que aún hay nodos candidatos los cuales podemos ir en este caso serían nodo nodo e y nodo recordemos que podemos regresar nodo que que ya ha sido recorrido por lo que el nodo b se toma en cuenta figura muestra los nodos validos en base la nueva posición la hormiga como aún hay nodos candidatos disponibles los cuales podemos ir menzaremos nuevamente calcularemos la probabilidades para desplazarse uno los nodos y así seguir el proceso hasta que ya haya más nodos candidatos los cuales poder ir cuando se llega ese resultado podemos concluir el proceso y tomar la lista tabú como nuestro mejor recorrido optimización por cumulo partículas particle swarm optimization pso la optimización por cumulo partículas e algoritmo optimización que fue introducido en por kennedy y eberhart este algoritmo está bioinspiradoenelcomportamientodelasparvadasdeavesalbuscaralimento la parvadas normalmente conocen priori el lugar donde se encuentra el alimento más si la distancia aproximada este por lo que como estrategia siguen al ave que se encuentra más cercana la fuente algoritmos bioinspirados pso simula dicho comportamiento para resolver problemas optimización generando posibles soluciones donde cada una ellas simula ave trodelespaciodebúsqueda y velocidad la que cada partícula se mueve e ajustada basándose en la mejor posición que ha obtenido ella misma y la mejor solución global o local acuerdo al vecindario deﬁnido por el usuario encontrada hasta el momento por la parvada lo que conduce que se encuentre una buena ción para resolver el problema chen garcía figura muestra el comportamiento la partículas en diferentes etapas del pso pso puede utilizar do tipos representaciones la binaria y la real león el pseudocódigo pso representación binaria e hacer para hasta numero particulas si f xi f pi entonces se evalua la para hasta dimensiones pid xid pid e la mejor posicion obtenida por la particula id siguiente swarm intelligence fin si g para j hasta index los vecinos si f pj f pg entonces g j g e el indice la mejor particula del siguiente j para d hasta dimensiones vid t vid t vid vmax siρid s vid t entonces xid t sino xid t fin si siguiente d siguiente hasta criterio parada dónde xid t e el estado actual del bit la partícula vid t e la velocidad la particula se inicializa o pid e el estado actual del bit la partícula en la mejor posición experimentada pg e la mejor particula del vecindario φes número aleatorio positivo distribución uniforme y límite superior predeﬁnido ρid e número aleatorio vector números aleatorios valor entre y vmax e una constante deﬁnida al inicio del algoritmo y que limita los valores vid s vid t representa la evaluación vid t en la función sigmoide esto e s vid la función sigmoide reduce su entrada valores o y sus propiedades la hacen adecuada para ser usada como umbral probabilidad algoritmos bioinspirados shi kennedy figura muestra el comportamiento la partículas en el pso figura comportamiento del pso pso números real trabaja modo similar la versión binaria y su pseudocódigo e el siguiente hacer para hasta numero swarm intelligence si f xi f pi entonces se evalua la para hasta dimensiones pid xid pid e la mejor posicion obtenida por la particula id siguiente d fin si g para j hasta index los vecinos si f pj f pg entonces g j g e el indice la mejor particula del siguiente j para d hasta dimensiones vid t vid t pid vid vmax xid t xid t vid t siguiente d siguiente hasta criterio parada en el pso valores real la posiciones la partículas representan mo tal una posible solución al problema planteado por lo que cada subíndice d representa el valor vector números real diferencia pso versión binaria la actualización la posición la partícula se lleva cabo directamente sin utilizar la función sigmoide en la actualidad existen múltiples variantes pso pero los go mostrados son la versiones algoritmos bioinspirados conclusión como se puede apreciar los algoritmos que se encuentran clasiﬁcados dentro swarm intelligence permiten obtener resultados muy buena calidad en problemas optimización aun cuando pso trabaja poblaciones este algoritmo utiliza los cesos evolutivos sino guía la partículas hacia espacios más prominentes pero realizando proceso exploratorio del camino entre cada partícula y la mejor la población aco utiliza proceso constructivo que se va formando en base cada movimiento que hace la hormiga utilizando los rastros feromona dejados por otras hormigas sin perder cierto grado aleatoriedad que le permite escapar óptimos locale existen muchas otras técnicas dentro esta clasiﬁcación que pueden ayudar dependiendo del problema obtener mejores resultados y en tiempos mucho mejores cuestionario colonias hormigas e algoritmo colonia hormiga heurística inspirada en la hormigas comportamiento la hormigas función búsqueda e una algoritmo búsqueda heurística prueba y error pero orientada la computadoras algoritmo para la resolución problemas fue aplicado por primera vez el algoritmo colonia hormiga el problema la mochila el problema tsp el problema clique máximo fue el creador del ant sistema hormigas burattari holland dorigo tablas que se manejan para la resolución problemas visibilidad y tabla feromonas búsqueda y tabla objetos recorrido y tabla nodos e el principal objetivo los acg el tiempo cálculos el proceso solución el menor costo computacional bibliografía visibilidad está dada por distancia entre los nodos del problema especíﬁca del problema número hormigas del problema e la representación la concentración depositada por la hormigas través del tiempo distancias recorrido feromonas e la principal ventaja algoritmo colonia hormiga e el algoritmo más rápido y eﬁciente garantiza encontrar el óptimo local el cualquier problema encuentra la solución exacta los problemas e una lista tabú donde se almacena el recorrido la hormigas donde se almacenan la distancias donde se guardan los óptimos cada iteración bibliografía abraham grosan ramos swarm intelligence data mining berlin heidelberg springer verlag bullnheimer hartl strauss improved ant algorithm vehicle routing problem annals operation research chen second generation particle swarm optimization tionary computation cec cruz cortés thesis phd science computer science option sistema inmune artiﬁcial para solucionar problemas optimización dorigo gambardella ant colony cooperative learning approach traveling salesman problem evolutionary tation ieee transaction volume issue dorigo maniezzo colorni ant mization colony cooperating agent ieee transaction system man eberhart shi kennedy j swarm intelligence elsevier fritsch wegener schraft control robotic swarm elimination marine oil pollution swarm intelligence symposium si ieee gambardella dorigo reinforcement learning approach traveling salesman problem twelfth international rence machine learning prieditis russell ed algoritmos bioinspirados gambardella taillard agazzi tiple colony vehicle routing problem time window new idea optimization garcía j algoritmos basados en cúmulo partículas para la solución problemas complejos tesis licenciatura malaga españa kassabalidis mark arabshahi gray swarm intelligence routing communication network global telecommunication conference globecom ieee león diseño e implementación en hardware algoritmo inspirado méxico parpinelli lope freitas data mining ant colony optimization algorithm evolutionary computation ieee tions volumen issue peng venayagamoorthy corzine combined training recurrent neural network particle swarm optimization pagation algorithm impedance identiﬁcation swarm intelligence posium si ieee pilat white using genetic algorithm optimize tsp ant algorithm lecture note computer science volume stützle hoos improvement ducing ant artiﬁcial neural net genetic rithms white pagurek oppacher asga improving ant integration genetic algorithm genetic gpus josé alberto hernández crizpín zavala nodari vakhnia oswaldo pedreño universidad autónoma del estado morelos méxico objetivo el presente capítulo tiene como objetivo el describir una metodología ra paralelizar algoritmos bioinspirados en unidades procesamiento gráﬁco graphic processing unit por sus siglas en inglés empleando el guaje programación cuda c uniﬁed device architecture para este propósito en primer lugar se discute brevemente el funcionamiento la gpu posteriormente los diferentes tipos paralelismo haciendo énfasis en el paralelismo orientado datos en el que se busca paralelizar ciclos anidados para posteriormente analizar implementaciones secuenciales goritmos bioinspirados como el algoritmo colonia hormigas aco y la paralelización algunas sus funciones en núcleos procesamiento ralelo o kernel los fundamentos teóricos del paralelismo orientado datos son puestos en práctica través caso estudio así como ejercicios propuestos resumen del capítulo uno los mayores beneﬁcios que usuario puede obtener ambiente simulación e el poder experimentar y analizar modelo en lugar del sistema real menor costo tiempo y riesgo el desarrollo te modelado y simulación e reconocido como una tarea difícil debido la falta técnicas que permitan registrar la experiencias exitosas del diseño la abstracciones del software que requieren este tipo ne el presente trabajo propone una metodología para paralelizar algoritmos secuenciales que contienen ciclos aninados que realizan cálculos dientes para ser ejecutadas en unidades procesamiento gráﬁco hasta hace unos pocos años los equipos que permitían el procesamiento en paralelo resultaban costosos y eran compartidos por grupos cientíﬁcos e investigadores manera que se tenía que hacer cola para hacer uso algoritmos en paralelo mediante uso gpus mismos afortunadamente mediados los s se abrió la posibilidad este tipo procesamiento mediante la unidades procesamiento gráﬁco primeramente para el renderizado vectores vídeo juegos y algunos años más tarde para la realización operaciones punto ﬂotante así el rrer del tiempo y evolución la tecnologías la tendencias indican que cada centro investigación o facultad buscan su propio equipo procesamiento en paralelo mediante el uso tecnologías heterogéneas que implican procesadores acompañados cientos o mile núcleos procesamiento incorporados en gpus en el presente trabajo se propone la implementación algoritmos en paralelo empleando la unidades procesamiento gráﬁco gpus y el lenguaje programación cuda ambo elementos temas le discusión por la comunidad cientíﬁca y académica gracias su gran potencia procesamiento bajo consumo energía y costo y su dad para ser utilizado en diferentes aplicaciones conocimientos previos para una mejor comprensión los contenidos este capítulo se recomienda al estudiante contar nivel básico experiencia en la programación estructurada y programación en lenguaje c conocimientos heurísticas y sus algoritmos así como principios básicos programación en paralelo introducción la gpus y cuda la gpu graphical process unit o unidades procesamiento gráﬁco son una tecnología muy potente en comparación la una cpu o unidad procesamiento central ya que supera la frecuencia reloj que maneja la cpu más este mejor rendimiento se debe que la gpu están optimizadas para el desarrollo cálculo coma ﬂotante además la memoria propia la que cuenta la gpu permite el acceso mucho más rápido respecto al una cpu esto beneﬁcia para que los resultados sean leídos guardados manera más rápida una gpu posee muchas funciones entre la que sobresale el datos manera como si fuera gráﬁco en el que se toman en cuenta tanto los vértices como los pixeles la memoria la gpu e muy diferente la la cpu esto se puede ver por el número núcleos que cuenta una gpu continuación se expone una ﬁgura en donde se comparan los núcleos entre una cpu y una gpu como se puede observar en la ﬁgura reﬃg el cpu solo contiene núcleos diferencia la gpu que puede tener cientos o mile introducción la gpus y cuda figura comparación núcleos entre cpu y gpu nvidia lo que la hace más rápida antecedentes históricos la gpu s durante los años s en los que aconteció la aparición la primera tadora personal una velocidad aproximada procesamiento se había logrado dar gran paso para el campo la computación riormente durante los s la evolución fue aún más signiﬁcativa debido la creciente popularidad microsoft window debido principalmente que da dimensión para sus pantallas en sus sistemas operativos sander kandrot posteriormente en la empresa silicon graphic liberó la librería opengl la que permitía la programación aplicaciones en estos elementos lograron una considerable popularidad y ron utilizarse primariamente para perfeccionar la aceleración gráﬁca como e el caso videojuegos fue así como en el año surgió la empresa nvidia fundada por jen hsun hung chris malachowski y curtis priem nvidia company history nvidia esta compañía en lanza la primera tarjeta gráﬁca la nvidia geforce esta fue diseñada la ción especíﬁca aceleramiento gráﬁco jamás se pensó que mediante estas se lograría incremento en velocidad procesamiento datos desde ﬁnales los s la gpu s eran más fáciles para programar gracias que varias empresas se dieron la tarea crear lenguaje programación para gpu s ya que los usuarios ﬁnales aun conociendo jesdeprogramacióncomoopengllesresultabamuydifícilsuprogramación ya que tenían que manipular el código como si se tratara triángulos y lígonos la universidad stanford la gpu como procesador ﬂujos nvidia en esencia durante la primera década este siglo la gpu s fueron da para producir color para cada píxel al analizar esto los programadores e investigadores vieron que era posible cambiar la unidades píxeles lore por datos facilitando el trabajo programarlas sander kandrot en se creó el primer modelo programación para la gpu s llamado brook algoritmos en paralelo mediante uso gpus ﬂujos datos kernel y los operadores reducción todo esto estableció la gpu como procesador ﬁnes generales tomando en cuenta lenguaje alto nivel este modelo programación fue aceptado gracias que era siete veces más rápido que los lenguajes programación existentes en ese momento nvidia respecto la programación la empresa que más avances ha e nvidia cuyos fabricantes sabían que el hardware tan amplio que contaban la gpu s podían elaborar lenguaje programación propio nvidia contacto lan buck para crear lenguaje programación nando c en una perfección para manipular la gpu s así la empresa nvidia en lanzó al mercado cuda compute uniﬁed device architecture que fue tomado como la mejor solución para la programación en gpu s en ese momento nvidia fundamentos teoricos el procesamiento paralelo ha evolucionado desde que la computadoras nían núcleos y que se empezó utilizar supercomputadoras para el samiento información en cantidades exorbitantes cuda nvidia reduce el tiempo procesamiento aprovechando la gran cantidad núcleos que tiene una gpu esto quiere decir que el código ejecutado en gpu s e en paralelo ya que puede realizar n cantidad operaciones al mismo tiempo asignando uno sus núcleos procesamiento para cada una ellas esto e muy útil hoy en día ya que muchas la aplicaciones existentes conllevan alto grado paralelismo aquí cabe señalar que el código secuencial guirá siendo secuencial mientras que aquello que requiera una gran cantidad cálculos matemáticos puede ser paralelizado e decir que se puede aprovechar la fuerza bruta que tienen la gpu s en cuanto procesamiento y tratar llevar algoritmos la paralelización ya que esto se reducirán los tiempos y se optimizarán los cálculos ciones coma ﬂotante los modelos actuales gpu s no ofrecen trabajar que si se compara los la cpu podemos llegar la conclusión que e mejor trabajar una combinación entre gpu s y cpu s esto no favorece en tanto que aunque se cuenta en la actualidad cluster s cpu e mejor trabajar gpu s ya que en costo se hace una diferencia realmente grande y en cuanto al procesamiento se puede jorar hasta veces más el tiempo en terminar proceso computacional la paralelización e una división trabajo entre los procesadores una cpu y una gpu esto quiere decir que los procesos cálculo intensivo datos se llevarán cabo en la parte la gpu y la parte diseño la interface usuarios se ejecutarán en la parte los procesadores la cpu dejando entonces el trabajo más pesado en tanto procesamiento datos se habla la gpu que puede realizarlo una manera mucho más rápida gracias sus grandes cantidades núcleo procesamiento sander kandrot cuda compute uniﬁed device architecture en noviembre del nvidia sacó al mercado su arquitectura mación cuda esta arquitectura fue diseñada para el cálculo paralelo en donde se puede aprovechar la gran potencia en procesamiento que ofrecen la gpu s esto ayuda incrementar extraordinariamente el rendimiento la plataforma en seguida se muestra una tabla toda la familias tarjetas su mejor modelo cada uno su capacidad computacional y la cantidad cleos procesamiento nvidia tabla tarjetas nvidia que soportan cuda familia modelo yor capacidadcapacidad computacionalnúcleos para procesamiento tesla tesla quadro quadro nv quadro nv geforce geforce gtx titan cuda compute uniﬁed device architecture acuerdo sander kandrot cuda e lenguaje ción que e utilizado para la paralelización propósito general introducido por la empresa nvidia este lenguaje incluye conjunto instrucciones que trabajan sobre la arquitectura la gpu s el cual e muy utilizado por la facilidad que le da los programadores ya que el código generado e muy parecido al del lenguaje cuda tiene una gran cantidad áreas aplicación ya que día día se encuentran más aplicaciones prácticas para esta nueva tecnología algunas la áreas aplicación donde podemos observar el uso cuda son logía química computacional procesamiento video entre otras muchas áreas más ya que cuda combinado gpu s puede ser utilizada para propósitos generales cuda c los programadores se preocupan más por la tarea paralelización que por el manejo la aplicación además cuda c apoya al cómputo heterogéneo e decir que la parte del código secuencial la aplicación se ejecutará en el cpu y la partes del código paralelo se llevan cabo en la gpu para este propósito cuda trata como dispositivos independientes tanto la cpu como la gpu aunque trabajan como uno solo esto hace que la cpu y la gpu entren en petencia por recursos memoria si que cada uno use sus propios recursos manera algoritmos en paralelo mediante uso gpus cuando una gpu trabaja cuda cuenta cientos núcleos esto quiere decir que podemos ejecutar mile thread hilo programación simultáneamente cada núcleo cuenta recursos compartidos esto no ayuda que se realice manera más eﬁciente la paralelización en la actualidad la programación se está enfocando más hacia el miento entre una cpu y una gpu llamada también programación paralela dejando atrás la forma tradicional realizar todos los procesos forma centralizada llamada programación secuencial ya que la programación ralela se realiza manera más rápida gracias los múltiples núcleos que no ofrecen la gpu s todo esto ha llevado que cuda sea aceptado por la comunidad cientíﬁca ya que facilita el descubrimiento nuevas aplicaciones que requieren ser aceleradas utilizando tanto el coprocesamiento como la computación paralela que no ofrece cuda los nuevos sistemas operativos contemplan la computación gpu s ya que cada vez se está utilizando mayor frecuencia esta tecnología nvidia para entender cuda se debe conocer los conceptos principales que hacen la diferencia la arquitectura programación en lenguaje los conceptos principales que analizaremos cuda son nvidia hilo memoria heterogénea kernel ellenguaje deprogramación cudac tieneﬂexibilidad parautilizar funciones que se utilizan en el lenguaje programación estas funciones pueden llamarse desde cualquier parte del código y ejecutarse n veces en ralelo ya que estas la pone en thread hilo programación para crear kernel e necesario utilizar una declaración especíﬁca además poner el número identiﬁcador esa función el cual se puede ver en el siguiente ejemplo en donde e la declaración la función y e el identiﬁcador o mejor llamado threadid así e como podemos hacer el uso varias llamadas al kernel en el cual se encontrarán toda la funciones para después poder ser utilizado en cualquier parte y la veces que sea cesario en código paralelo jerarquía hilo los hilo se identiﬁcan por el threadidx el cual hace bloque estos mo para esta manera sea más fácil invocarlos en código cuda compute uniﬁed device architecture cada bloque contiene n cantidad thread hilo programación tro estos bloques se puede identiﬁcar los diferentes thread gracias su id el cual e conformado por coordenadas dx y dy en bloque nal hay límite hilo que puede contener bloque esto por la cantidad recursos en la memoria actualmente la gpu s dan la facilidad que cada bloque contenga hasta thread al conjunto bloques se le conoce como una grid en esta los bloques bién son identiﬁcados por id llamado blockidx do coordenadas dx y dy figura arquitectura cuda nvidia en la ﬁgura reﬃg se muestra cómo se hace referencia los nentes que incluye la programación en cuda paralelismo basado en datos existen distintos tipos programación en paralelo entre los que podemos encontrar paralelismo basado en datos paralelismo híbrido simple algoritmos en paralelo mediante uso gpus gram multiple data programa simple múltiples datos y multiple program multipledata múltipleprogramamúltiplesdatos basado en datos también conocido como modelo espacio direcciones globales particionadas o por su nombre en inglés partitioned global dress space pgas según pedemonte alba luna y blaise la mayoría los programas en paralelo buscan realizar operaciones desde alguna estructura datos llámese vector matriz cubo esto se lleva cabo mediante estructuras control sin embargo necesariamente se trabajan manera ordenada ya que como e sabido la estructuras memoria compartida como son la gpu s permiten el acceso estas turas mediante punteros y memoria global véase la ﬁgura reﬃg figura representación del modelo paralelismo basado en datos fuente blaise en la ﬁgura anterior se logra apreciar cómo funciona este tipo ción en paralelo cada uno los cuadros representa una tarea en especíﬁco y cada uno ellas trabaja en distintos tipos segmento arreglo necesariamente en el mismo orden pero si alguna relación entre ellos el presente trabajo propone paralelizar algoritmos secuenciales utilizando el esquema paralelismo basado en datos ver ﬁgura reﬃg cuda lo anterior signiﬁca que lo que sea secuencial del algoritmo seguirá siendo secuencial mientras que aquello que requiera cálculos intensivos dientes contralados mediante ciclos aninados serán ejecutados en kernel dentro la gpus cuando estos cálculos estén terminados los resultados serán enviados regreso la cpu para continuar la ejecución del algoritmo en la ﬁgura anterior se como interactúa el cpu y la gpu metodología figura secuencial gpu paralelo pospichal jaros schwarz rante la ejecución programa en cuda esto se realiza mediante el compilador cuda llamado nvcc el cual se encarga separar el código del host cpu del código del gpu device cada uno estos códigos e tratado por compilador para el caso del host se utiliza compilador propósito general este puede variar dependiendo la plataforma en la que se esté trabajando para esta investigación que se realizó sobre window el compilador recomendado por cuda e el microsoft visual studio cl por otra parte el código cuda e ejecutado por el nvcc en el device el host reserva y traslada el código al device una vez que el device termina el tratamiento los datos procede regresar los datos al host metodología basados en methodología propuesta en hernandez et al propuesta metodológica para explotar la capacidades procesamiento en paralelo sistemas heterogéneos nuestra propuesta considera los siguientes pasos inicio identiﬁcar el problema resolver e problema que pretendemos resolver y solo no referimos jorar la capacidad cómputo instalada ma bien en este punto debemos plantear que procesos deseamos paralelizar susceptible ser paralelizado una vez que hemos identiﬁcado el problema se debe analizar puede paralelizar si la respuesta e sí continuamos el paso do en caso contrario continuamos en el punto fin conﬁguración del equipo se debe identiﬁcar el tipo tarjeta gráﬁca gpu la que cuenta algoritmos en paralelo mediante uso gpus equipo nvidia amd u otra así como el número procesadores hecho lo anterior se deberán descargar los driver para la gpu dependiendo su fabricante y del número bit que procesen los microprocesadores o bit y del sistema operativo que se use así mismo se deberá descargar opencl y python en linux se utiliza el comando lspci para listar todos los dispositivos conectados en la ranuras pci la computadora o estación trabajo prueba del equipo si el sistema fue conﬁgurado exitosamente y ya se tiene correctamente talado python y la librerías requeridas por el mismo numpy para operaciones matrix se podrá correr sin problema cualquiera los programas demostración disponibles en pyopencl si el programa corre o el sistema indica la falta alguna librería se deberá regresar al paso se recomienda ejecutar el programa para dicho ﬁn para correr el programa desde la línea comandos o terminal se deberá usar la instrucción siguiente usuario python para ejecutar el programa desde el idle python se deberán seguir la siguientes instrucciones entrar al idle ir al menú archivo ir la opción abrir archivo buscar la ruta del archivo abrir el archivo y ejecutarlo te o bien ir al menú ejecutar run y posteriormente seleccionar la opción ejecutar módulo run module implementar el algoritmo la implementación del algoritmo en particular puede ser una tarea más o menos consumidora tiempo pero lo estamos seguros e que gracias la bondades opencl esto tomará mucho tiempo en este punto se recomienda consultar la documentación pyopencl evaluar los resultados se veriﬁcan los resultados obtenidos y si son correctos pasamos al punto si regresamos al punto anterior fin se recomienda consultar la literatura para identiﬁcar la funciones bles ser paralelizadas y posteriormente buscar alguna solución secuencial para resilver el problema en cuestión para identiﬁcar funciones o segmentos código que contengan ciclos anidados para identiﬁcar funciones didatas ser paralelizadas hecho esto se procede implementarlas usando cuda se validan los resultados estas funciones y se realiza una caso práctico paración del tiempo procesamiento la implementación secuencial respecto al tiempo procesamiento la implementación paralelizada caso práctico el ﬁn aplicar la metodología propuesta en la sección anterior tinuación presenta el análisis y diseño programa en cuda cuyo pósito e resolver el problema del agente viajero tsp utilizando colonia hormigas ant colony aco este programa está basado en la solución propuesta por jones y permite al usuario analizar distintas instancias del tsplib análisis requerimientos la parte externa del ambiente ambiente simulación señales está presentada por la interfaz gráﬁca la cual está conformada por el conjunto interactores y el evento los cuales responde cada uno ellos ver tabla el problema del agente viajero el problema del agente viajero tsp e problema combinatorio mente estudiado lo largo del tiempo y por esta razón podemos hallar más algoritmo para su resolución para tener una idea sobre este problema tenemos que entender que en este vendedor el cual tiene que recorrer n cantidad ciudades nodos sin volver pasar una ciudad ya ante visitada y terminar dicho tour en la ciudad inicial nodo inicial véase la ﬁgura el vendedor naturalmente quiere realizar la ruta más corta y en el menor tiempo posible este problema puede considerarse sencillo ya que al ser problema combinatorio solo se debe analizar toda la ruta posibles para cubrir todos los nodos y elegir cual ella e la menor esto se puede zar una manera sencilla si consideramos pocos nodos como por ejemplo pero al hablar más nodos la combinaciones la ruta son demasiadas para llevar cabo análisis una por una y elegir esta manera la mejor cook el problema del agente viajero tsp e problema clásico y ampliamente estudiado puesto que e fácil entendimiento pero e difícil tación lo podemos observar al momento pasar la formula cualquier lenguaje programación como se ha visto en la historia la cantidad nodos ha ido aumentando como por ejemplo en la instancia más grande la cual se tenía una solución óptima era ciudades en se reportó la solución óptima la instancia más grande que se ha registrado la instancia dades o nodos estos datos no sirven para observar el gran progreso que algoritmos en paralelo mediante uso gpus ha obtenido el paso del tiempo e raro que en futuro se hallen soluciones óptimas para instancias mayor tamaño gonzález una la soluciones que se ocupa para el tsp son los algoritmos zación en muchos casos se utiliza el algoritmo colonia hormigas esto se realiza por varias razones como por ejemplo stützle dorigo los algoritmos son fácil aplicación para solucionar el tsp b el tsp e considerado problema c el tsp te da la facilidad encontrar diferentes tipos soluciones y obtenerencadacorridaunresultadodiferente debidoalaprobabilidad d eltspesfácildecomprender yaquenoesnecesarioconocertecnicismos para comprender el funcionamiento este problema una manera más formal describir el tsp según stützle dorigo e que se debe entender que en grafo g cualquier tamaño donde se ubican n cantidad nodos n en donde cada nodo debe estar nectado todos los demás nodos para calcular la distancia total se debe sumar la distancias parciales que se obtenga del recorrido todos los nodos donde el nodo inicial al nodo más cercano este j tiene una distancia parcial d en la cual se debe cumplir que entre los nodos y j la distancia tiene que ser igual cumpliéndose esto al pasar al nodo más cercano este se convertirá en nodo y se buscará el nodo más cercano este convirtiéndose en el nodo j y así sucesivamente hasta volver al nodo donde se inició el tour sin que falte ni nodo visitar y repetir algún nodo ya visitado áreas aplicación el problema del agente viajero tsp e aplicado en diferentes áreas la principales son en el área manufacturera y el área logística en el área manufacturera el ejemplo en donde se puede implementar ser al tener una sola máquina que realice varias tareas pero solo puede realizar una tarea la vez y donde cada tarea tiene características distintas entonces en este ejemplo el tsp puede aplicarse si observamos cada tarea como nodo y el tiempo en que tardan en cambiar la características para la nueva tarea se considera la distancia lo anterior tenemos que idear plan en donde la características la tareas sean la más similares para que al momento del cambio se pierda mucho tiempo en esta transacción y esta manera ser más productivos otra área aplicación e la logística donde comúnmente e aplicado en la empresa que vende productos perecedero en una ciudad una cantidad n clientes la dudas que surgen serán cuántas unidades se debe contar para repartir dichos análisis requerimientos todos los clientes b cuánto tiempo se recorre la ruta total visitando todos los clientes estas do dudas se relacionan entre sí por qué una sola unidad se puede repartir los productos todos nuestros clientes pero el tiempo para cubrir toda la ruta será muy elevado pero en caso contrario se puede contar una unidad para cada cliente ya que el costo esto sería muy alto ce se deben considerar los factores principales del tsp el tiempo y la distancia y llegar promedio aceptable este ejemplo puede ser muy fácil solucionar si solo se cuanta clientes ya que se puede realizar análisis toda la ruta posibles y obtener el mejor resultado pero si se tienen clientes o más el análisis se podría llevaría años para obtener toda la ruta posibles ya que para este problema el número ruta crece exponencialmente gonzález y ríos ant colony los algoritmos colonia hormigas o ant son conjunto algoritmos los cuales tienen aplicación para resolver problemas optimización combinatoria este trabajo fue llado como parte tesis doctorado marco dorigo el cual toma como base la observación la hormigas real la cuales su objetivo e el encontrar la ruta más corta entre su nido nodo inicial y su comida nodo ﬁnal baran y almirón según ponce los antecedentes que se tienen en estas ne son muy amplios ya que son fáciles entender pero veces difícil aplicación y muchos investigadores y cientíﬁcos han realizado trabajos ellos ponce muestra una tabla donde se pueden ver diferentes problemas sueltos colonias hormigas así como los autores y el año publicación su trabajo llega hasta el año en seguida se describirá la evolución que han tenido estos tipos algoritmos incluyendo sus autores y el año publicación los mismos ant el ant fue el primer algoritmo colonia hormigas este goritmo fue creado por marco dorigo y publicado en su tesis doctorado en el año algoritmo el gambardella dorigo e sistema híbrido ya que bina el ant aprendizaje también conocido como siendo modelo muy conocido aprendizaje algoritmos en paralelo mediante uso gpus este algoritmo e una modiﬁcación del ant ya que toma en ta la cantidad feromona depositada en la ruta entre nodos sumándola e incrementando el valor si otra hormiga utiliza esa ruta bullnheimer et ant colony este algoritmo nace como adicional mejorado del dorigo bardella ant este algoritmo se caracteriza porque actualiza el valor para calcular la dad feromona depositada en el tour además establecer valor mínimo ymáximocomolímitesdeacumulacióndelaferomona estos trabajos son la base lo que hoy se conoce en los famosos y algoritmos aco desde el año hasta la fecha han venido evolucionando y tomando pel muy importante en la solución problemas entre otros más el problema en donde e más utilizado por su naturaleza e el problema del agente viajero tsp ya ante analizado en esta investigación análisis del algoritmo colonia hormigas ante empezar análisis del algoritmo colonia hormigas aco podemos mencionar la importancia los sistemas híbridos ya que este goritmo está basado en este concepto jones ejemplo e que para el ser humano e muy fácil hacer cálculos matemáticos y también tenemos memoria asociativa lo que signiﬁca que comparación la hormigas ta pueden recordar la ruta para llegar su comida en cambio el hombre puede asociar momento recordar imágenes y conceptos basados en hechos incompletos ya contemplado lo anterior podemos adentrarnos el análisis del aco optimización colonia hormigas o aco e algoritmo útil para resolver problemas en espacio físico determinado o grafo aco trabaja hormigas simuladas o virtuales diferencia la hormigas naturales la cuales como ya se ha explicado anterioridad pueden llegar asociar el camino seguir entre su colonia y su comida la hormigas naturales son ciegas y al poder ver utilizan la feromona la feromona e una sustancia la cual van dejando la hormigas como rastro para saber el camino hacia su comida esto lo hacen para optimizar el tiempo y la distancia que tengan que recorrer ya que al inicio este ciclo se mandan varias hormigas inspeccionar lugar en busca comida la hormiga que encuentre esta ruta dejará rastro feromona más fuerte para que análisis requerimientos hormigaslasiganyasílogrartenerelcaminomáscortoentiempoydistancia el concepto uso aco e que determinado espacio físico o grafo se consideran varias hormigas considerando la colonia como el nodo o nodo inicio y la comida como nodo j o nodo ﬁnal la hormigas recorrerán todo el espacio del grafo y depositarán niveles feromonas cuanto más fuerte sea este nivel más cerca se estará encontrar la ruta óptima el pseudocódigo para aco se basa en una serie sencillos pasos para su ejecución los cuales se explicarán detalle y están basa en jones más adelante distribución la hormigas en el grafo selección ruta intensiﬁcación la feromona evaporación la feromona nuevo tour se repite del paso en adelante hasta llegar encontrar el tour óptimo para este algoritmo implementación del algoritmo colonia hormigas sobre gpu s según cecilia et el algoritmo colonia hormigas aco se basa en la población siendo intrínsecamente paralelo por lo tanto se puede llevar al paralelismo para solucionar problemas el algoritmo se divide en funciones principales la construcción del tour o inicialización la poblaciones y el nivel feromona estos pasos se adaptan del todo la arquitectura la gpu s ya que proporcionan resultados alternativos basado en el paralelismo datos para mejorar dichos resultados se deben evitar instrucciones atómicas funciones vista por el programa como visibles en la ejecución dicho programa el uso aco en gpu s todavía está en una etapa inicial esperándose en futuro la mayor compatibilidad entre ellos en otro trabajo cecilia et al indica que la clave para poder plementar el paralelismo e utilizar la operaciones coma ﬂotante y que algunos operadores aritméticos suelen ocasionar problemas la tación paralela además que el algoritmo colonia hormigas aco encaja bien la arquitectura cuda por el paralelismo datos estos experimentos se realizaron en una gpu do tarjetas gráﬁcas una tesla y los resultados indican que aco puede ser utilizado en problemas tsutsui utilizó aco y la tecnología la gpu s para resolver otro problema np el qap problema asignación cuadrática esto se observar que aco solo se utiliza para resolver el tsp si otros varios al utilizar la gpus se resolvió más rápido el problema utilizando do modelos trabajo en la gpu s el modelo isla y el modelo en este caso en particular se obtuvieron los resultados algoritmos en paralelo mediante uso gpus manera más rápida utilizando el modelo isla pero al utilizar los modelos se aceleró más el algoritmo instancias gran tamaño teniendo como conclusión su investigación que si se requiere acelerar el algoritmo instancias tamaño pequeño en el problema qap e mejor utilizar el modelo isla pero si se trabaja instancias gran tamaño e mejor utilizar el modelo en su investigación aco encontró una característica para der paralelizar el algoritmo la ubicación la ciudades como la ubicación la hormigas se calculan por medio operaciones probabilística el vimiento la hormigas dentro del grafo se hace manera individual por cada hormiga siendo la única comunicación que tienen entre ellas el rastro feromona la actualización y evaporación la feromona se realiza después que la hormiga termina el tour en cuda e posible manejar do tipos operaciones para aco el primero e el la inicialización y el segundo para controlar los niveles feromona teniendo entendido que cada thread e tour completo dentro ciclo así cuando cada hormiga termina tour se vuelve comenzar tour nuevo la clave para obtener los mejores resultados e el cuidado en la asignación la memoria en la gpu siendo la distribución la siguiente manera para los datos acceso frecuente para solo una hormiga se recomienda que se guarden la coordenadas cada cuidad en la memoria tida para el llenado la lista tabú se recomienda que se guarde el proceso en la memoria global para acceso más rápido para los niveles y distancias totales los tour se recomienda que se guarden en la memoria cache ya que se tiene menor latencia que si se guardaran en la memoria global en el trabajo o neil se puede observar que el tsp manera paralela solo se soluciona aco el muestra otra alternativa lución el algoritmo ihc algoritmo para acelerar intercomunicaciones los resultados obtenidos solo dan soluciones alta calidad sino que también se ejecutan muy rápidamente tomando en cuenta que la velocidad paración procesador bit una cpu y una gpu muestra una mejora veces más rápido aun teniendo cpu núcleos cada una llegando la conclusión que al ejecutar el algoritmo manera paralela en una gpu la respuesta será más rápida y sólo el algoritmo ihc sino que también se puede probar el algoritmo aco e posible resolver el tsp identiﬁcación procesos paralelizables en aco ante empezar explicar este apartado tomando en cuenta la bibliografía actual todo el código e factible paralelizar pero si aquel que contenga do ciclos anidados como se muestra en el siguiente análisis requerimientos el segmento código secuencial que se pasó paralelo fue el la ción véase código siguiente el cual contiene cálculos susceptibles ser paralelizados por encontrarse do ciclos anidados void precomputedistancesfunction void para precalcular la distancias int float dx dy la distancias entre la ciudades dx ab dy ab float sqrt pheromone pheromone return función secuencial que incluye la inicialización romone los arreglos y pheromone fueron utilizados como base para crear kernel s o núcleos paralelos siendo el primero el kernel nado el cual no ayudará calcular la distancia entre los nodos véase la siguiente función void kernelprecomputedistances float float float int n paralelizada para precalcular la distancias entra la ciudades float dx dy resultado int threadidx int j threadidx int j dx ab j se reformateo dy ab j se reformateo resultado sqrt float dx algoritmos en paralelo mediante uso gpus index resultado kernel paralelo la función estekernelrecibeunvectorﬂotantedelacoordenadadex te la coordenada y y vector ﬂotante denominado el cual contendrá el resultado del cálculo y el número ciudades en una variable enteron los valores y j son identiﬁcadores para hilo dentro bloque su respectivas coordenadas en x e y el cálculo se lleva acabo teniendo do valores ﬂotantes denominados dx y dy los cuales contienen valor absoluto del punto inicial y el punto ﬁnal dichas coordenadas estos valores se elevan al cuadrado se suman y se saca la raíz cuadrada la cual representa la distancia que hay entre los do puntos guardando este valor en la variable resultado el valor index e donde se van posicionar el vector en la memoria la gpu siendo este el que recorrerá todos los espacios del vector eliminando los ciclos anidados ya que estas operaciones se ejecutan manera lela resolviéndolas más rápido el segundo kernel kernelpheromone queda la siguiente manera void kernelpheromone double int n paralelizada para el calculo la cantidad la feromona int threadidx int j threadidx int j pheromone index kernel paralelo la función pheromone este kernel recibe vector doble denominado pheromone y el número ciudades en una variable enteron los valores y j son identiﬁcadores para hilo dentro bloque su respectivas coordenadas en x e y el valor index indica donde se van posicionar el vector denominado pheromone en la memoria la gpu siendo éste el que recorrerá todos los espacio del vector eliminando los ciclos anidados ya que estas operaciones se ejecutan manera paralela resolviéndose más especificación la interfaz en términos patrones interacción el resultado dicho cálculo se guarda en el vector estos do kernel s se utilizan para simpliﬁcar el cálculo la matrix mensionales convirtiéndolas en matrix unidimensionales o vectores especificación la interfaz en términos trones interacción partir la información obtenida en el análisis anterior y la ciones patrones interacción van welie welie trætteberg y muñoz muñoz et al se identiﬁcaron patrones interacción donde se aplican prácticas exitosa en el diseño la interfaz usuario del simulador señales especificación la interfaz en términos trones software partir la información obtenida en la etapa análisis sección y la clasiﬁcación patrones diseño propuesto por gama et se identiﬁcaron tres patrones para aplicar la buenas prácticas para el diseño del estado la vista y los servicios que ofrece en momento la interacción el ambiente simulación señales ejercicios resueltos por favor describa trabajos relacionados al tema incluir el otro kernel pesar que el paradigma patrones e reciente en la literatura del seño am existe cierto número trabajos que preconizan su diseño en base cierto tipo patrones los tipos patrones más frecuentes tal como lo muestra la siguiente tabla son los patrones interacción y los patrones software tabla comparación trabajos ambientes modelado y simulación en base en el paradigma patrones diseño kreutzer blilie sanz et al ekström boyko et al rodriguez et al inoutspec interfaz software algoritmos en paralelo mediante uso gpus el trabajo aquí propuesto titulado outspec especiﬁcación la parte interna y externa una aplicación interactiva aparece en la tabla como el único que propone especiﬁcar la interfaz usuario y la funcionalidad am utilizando respectivamente los patrones interacción y los patrones diseño software ejercicios resolver la autoevaluación sobre la implementación algoritmos en paralelo usando gpus se presenta través diversos tipos ejercicios y pruebas saber implemente la otras funciones identiﬁcadas como susceptibles ser paralelizadas pueden realmente paralelizar toda la funciones b son los tiempos ejecución secuencial respecto los tiempos ejecución del algoritmo en paralelo pruebe varias instancias del tsplib busque la implementación del código secuencial para resolver el juego la torres hanói propuesto por jones y realice los siguientes ejercicios la solución propuesta e sólo para tres disco intente generalizar esta solución disco y n disco elementos e necesario modiﬁcar programa arroja soluciones válidas b b identiﬁque el código que e susceptible ser paralelizado y lelícelo empleando la metodología propuesta en este capítulo c c compare el tiempo ejecución secuencial contra el paralelo d d realice análisis sensibilidad comparando los resultados tenidosdelaimplementaciónsecuencialcontralaparalelacambiando el tamaño la población anímese e identiﬁque código secuencial ciclos anidados cuyos cálculos sean independientes y paralelice el código compare los resultados secuencial contra paralelo b cambie la condiciones terminación del ciclo y analice los tados obtenidos acuerdo sus resultados indique cuándo conviene paralelizar los goritmos secuenciales y cuando conclusiones el presente trabajo propone una metodología análisis y diseño para la reutilización y el fácil mantenimiento la parte interna y externa una ambiente modelado y simulación am nivel análisis establece una relación los requerimientos la interfaz gráﬁca y la funcionalidad am nivel diseño se propone una especiﬁcación más cerca al código en términos patrones diseño y especiﬁcación más cercana los requerimientos del usuario en términos patrones interacción uno los objetivos alcanzados los patrones e facilitar la ﬂuidez bibliografia comunicación entre la partes donde cada una tiene su propia experiencia y conocimientos los patrones diseño permiten especiﬁcar el código la funcionalidad una aplicación dando soluciones al diseñador para reutilizar y mantener fácilmente el código por su parte los patrones interacción miten especiﬁcar la experiencias exitosas en el diseño la interfaz graﬁca tomando en cuenta la necesidades del usuario y los componentes gráﬁcos el modelo aquí propuesto puede ser extendido aplicar los patrones software par la generación código am esto el ﬁn llevar cabo el prototipaje rápido y realizar así pruebas en conjunto el usuario bibliografia blilie computing science engineering pattern scientiﬁc introduction ekström design pattern simulation phd si uppsala university sweden gamma helm johnson vlissides booch design pattern element reusable software professional computing kreutzer wolfgang pattern building discrete event model simulator urbana usa muńoz reyes pérez designing direct tion user interface using interaction pattern wseas transaction computer rodriguez muńoz fernandez scientiﬁc software design scientiﬁc computing pattern iasted international conference modeling simulation optimization sanz zalewski control system engineering ieee control vol peter forbrig ed user interface desing pattern germany verlag welie van martijn trætteberg hallvard interaction pattern user interface pattern language program conference allerton park monticello illinois usa zavala vakhnia explotación la capacidades procesamiento en paralelo computadoras procesador y la unidades gráﬁcas procesamiento gpus algoritmos en paralelo mediante uso gpus pythonopencl en ambientes linux construcción soluciones ma administración operaciones e informática administrativa vol pp ca invop pp pospichal jaros schwarz j parallel genetic algorithm cuda bibliografia curriculum los autóres dra casali ana e doctora en tecnologías la información la versidad girona udg girona españa obtuvo el diploma estudios avanzados equivalente magister en tecnologías la información en la misma universidad española y licenciada en matemática por la universidad nacional rosario unr rosario argentina actualmente e ra del departamento ciencias la computación la facultad c exacta ingeniería y agrimensura profesora responsable la cátedras introducción la inteligencia artiﬁcial e ingeniería del miento la e investigadora del centro internacional franco argentino ciencias la información y sistema cifasis ha dictado numerosos cursos posgrado como investigadora ha dirigido y participado en proyectos nacionales e internacionales en el área agentes y sistemas inteligentes y aplicaciones la educación e autora libro y tiene merosas publicaciones en su línea investigación en los últimos años ha participado en comisiones ejecutivas y evaluadoras distintos congresos nacionales internacionales y revistas ha dictado diferentes conferencias sobre temas vinculados su área investigación además ha sido miembro jurados tesis doctorado hernandez jose alberto obtuvo el doctorado directo en ingeniería y ciencias aplicadas especialidad en ingeniería eléctrica por la dad autónoma del estado morelos uaem ciicap en el año e profesor tiempo completo en la uaem en materias licenciatura tría en la áreas programación matemáticas base datos miembro diversos comités diseño y rediseño curricular para programas educativos licenciaturas y posgrado responsable proyectos investigación la promep miembro titular del cuerpo académico en consolidación promep operaciones e informática áreas tigación en la que ha publicado inteligencia artiﬁcial minería datos ingeniería software uso la tic en la educación cuenta más publicaciones en congresos y revistas nacional e internacional pítulos libros publicados en editoriales e instituciones como intech nova publisher ornelas zapata francisco javier obtuvo el doctorado en ciencias la computación por parte la universidad autónoma aguascalientes uaa en el año e profesor medio tiempo interino en el tamento ciencias la computación en la uaa nivel licenciatura así como profesor nivel medio superior en áreas programación inteligencia artiﬁcial y fundamentos y teorías computacionales áreas investigación en la que ha publicado inteligencia artiﬁcial minería datos cuenta publicaciones en congresos y revistas nacional e internacionales y varios capítulos libros ponce gallegos julio cesar obtuvo el doctorado en ciencias la computación por parte la universidad autónoma aguascalientes uaa en el año e profesor tiempo completo en el algoritmos en paralelo mediante uso gpus ciencias la computación en la uaa en materias licenciatura maestría y doctorado en la áreas programación inteligencia artiﬁcial y fundamentos y teorías computacionales miembro diversos comités diseño curricular para programas educativos licenciaturas y posgrado responsable proyectos investigación la uaa y promep bro titular del cuerpo académico consolidado promep sistemas inteligentes áreas investigación en la que ha publicado inteligencia artiﬁcial minería datos ingeniería software uso la tic en la educación cuenta más publicaciones en congresos y revistas nacional e internacional capítulos libros y libros publicados en editoriales e instituciones como intech nova publisher textos universitarios uaa smia obtuvoeldoctoradoenciencias la computación por parte la universidad autónoma te uaa en el año e profesora asignatura en el departamento ciencias la computación en la uaa en materias licenciatura en la áreas programación inteligencia artiﬁcial y fundamentos y teorías inteligencia artiﬁcial minería datos ingeniería software cuenta ne en congresos y revistas nacional e internacionales capítulos libros y libro dra scheihing eliana doctora en estadística la universidad lica lovaina bélgica e ingeniero civil matemático la universidad chile actualmente académica del instituto informática la universidad australdechileydirectoraalternadelcentrodeinvestigación desarrolloe innovación kelluwen http profesora responsable la asignatura inteligencia artiﬁcial para la carrera ingeniería civil en mática la universidad austral chile autora diversas publicaciones en revistas y congresos en la áreas tic en educación minería datos educacionales y sistemas recomendadores directora del proyecto fondef kelluwen y actualmente proyecto ﬁnanciamiento regional sobre didáctica para el emprendizaje silva sprock antonio estudiante del doctorado en ciencias la computación la universidad central venezuela magister en niería del conocimiento por la universidad politécnica madrid docente investigador la escuela computación la universidad central nezuela investigador acreditado categoría del programa estímulo la investigación del oncti del mppcti trabaja en base datos sistemas información objetos aprendizaje y tecnologías educativas desde coordina regionalmente para venezuela el proyecto latin va para la creación libros abiertos en latinoamérica alfa auspiciado por la unión europea coordina el proyecto desarrollo una ta para crear recursos educativos abiertos para la enseñanza en lenguas indígenas peii auspiciado por el fonacit participa en el proyecto neración herramientas tecnológicas para la producción distribución y macenamiento oaca para persona discapacidad visual auditiva bibliografia cognitiva peii auspiciado por el fonacit e autor múltiples trabajos publicados en revistas nacionales e internacionales dra torres soto aurora obtuvo el doctorado en ciencias la tación por parte la universidad autónoma aguascalientes uaa en el la computación en la uaa donde imparte materias pregrado y posgrado en la áreas programación inteligencia artiﬁcial y fundamentos y teorías computacionales actualmente e coordinadora la ingeniería en tación inteligente del centro ciencias básicas miembro titular del cuerpo académico consolidado promep sistemas inteligentes áreas investigación en la que ha publicado inteligencia artiﬁcial ca diseño automático circuitos analógicos cuenta publicaciones en congresos y revistas nivel nacional e internacional y varios capítulos libros en editoriales como global e intech dra maría dolores torres soto obtuvo el doctorado en ciencias la computación por parte la universidad autónoma aguascalientes uaa en el año e profesor tiempo completo en el departamento sistemas información en la uaa donde imparte materias pregrado y posgrado en la áreas programación base datos y sistemas y nologías la información actualmente e coordinadora la maestría en informática y tecnologías computacionales del centro ciencias básicas miembro titular del cuerpo académico consolidado promep ma inteligentes áreas investigación en la que ha publicado inteligencia artiﬁcial metaheurísticas ta publicaciones en congresos y revistas nivel nacional e internacional y varios capítulos libros en editoriales como global e intech túpac valdivia yván jesús profesional del área ingeniería trica doctorado en ingeniería eléctrica maestría en ingeniería eléctrica y pregrado en ingeniería electrónica unsa experiencia en ciencia la computación énfasis en soft computing inteligencia artiﬁcial redes neuronales algoritmos tivos lógica difusa aprendizaje por refuerzo procesamiento imágenes sistemas clasiﬁcadores su actuación principal e en proyectos ción y desarrollo en ingeniería petróleo energía eléctrica evaluación proyectos análisis riesgo control y automatización procesos temas redes comunicación computación distribuida sistemas trónicos y digitales análisis y procesamiento imágenes miembro del peru chapter vicechair spe society petroleum engineer spc sociedad peruana computación cv online en y http algoritmos en paralelo mediante uso gpus edición marzo este texto forma parte la iniciativa latinoamericana libros texto abiertos latin proyecto ﬁnanciado por la unión europea en el marco su programa alfa iii europeaid los textos este libro se distribuyen bajo una licencia compartirigual unported cc http