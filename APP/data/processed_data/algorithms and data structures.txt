algorithm data structure application graphic geometry book licensed creative common attribution license algorithm data structure application graphic geometry jurg nievergelt klaus hinrichs copyright jurg nievergelt jurg nievergelt associate editor marisa drexel ulrich editorial assistant jon durden tessa greenleaf kristyna mauch selph ernesto serrano question text email drexel global text project funded jacob foundation zurich switzerland book licensed creative common attribution license algorithm data structure global texttable content programming environment motion graphic geometry reducing task given primitive programming motion robot car capability task performed algorithm described informally algorithm specified language algorithm programmed robot language robot program optimized graphic primitive environment turtle graphic basic environment quickdraw graphic toolbox graphic frame program algorithm animation visualization characteristic technique gallery algorithm snapshot ii programming concept notation algorithm program literature substance form programming large versus programming small documentation versus literature meant read pascal dialect lingua franca computer science recursion algorithmic principle expressed diagram merge sort recursively defined tree recursive tree traversal recursion versus iteration tower hanoi flag alfanumerica algorithmic novel iteration recursion syntax syntax semantics grammar representation syntax diagram ebnf overly simple syntax simple expression notation arithmetic expression syntax analysis role syntax analysis syntax analysis expression counting analysis recursive descent turning syntax diagram parser iii object algorithm program truth value data type bit acrobatics bit boolean function swapping crossover versatile bit sum population count ordered set sequential search binary search permutation string recognizing pattern consisting single string recognizing set string interpreter matrix graph transitive closure book licensed creative common attribution license path graph boolean matrix multiplication warshall algorithm minimum spanning tree graph integer operation integer euclidean algorithm prime number sieve eratosthenes large integer modular number system poor man large integer random number real number danger horner method bisection newton method computing square root straight line circle intersection clipping drawing digitized line riddle braiding straight line digitized circle iv complexity problem algorithm computability complexity model computation ultimate risc computable halting problem undecidable computable unknown multiplication complex number complexity matrix multiplication mathematics algorithm analysis growth rate order magnitude asymptotics summation formula recurrence relation asymptotic performance algorithm permutation tree sorting complexity sorting difficult type sorting algorithm simple sorting algorithm work time θ lower bound ω n log n quicksort analysis case best typical worst possible sort linear time sorting network v data structure data structure data structure old new algorithm data structure global textthe range data structure studied performance criterion measure abstract data type concept stack queue priority queue dictionary implicit data structure implicit data structure array storage implementation fifo queue circular buffer implementation priority queue heap heapsort list structure list memory management pointer variable fifo queue implemented list tree traversal binary search tree tree address computation concept terminology special case small key domain special case perfect hashing table content known priori conventional hash table collision resolution choice hash function randomization performance analysis extendible hashing virtual radix tree extendible hashing metric data structure organizing embedding space versus organizing content radix tree try quadtrees octtrees spatial data structure objective constraint grid file simple geometric object parameter space region query arbitrary shape evaluating region query grid file interaction query processing data access vi interaction algorithm data structure case study geometric computation sample problem algorithm geometry geometric computation convex hull multitude algorithm us convexity basic operation polygon visibility plane simple algorithm analysis algorithm problem illustrated using line segment intersection line segment intersection test skeleton turning space dimension time dimension data structure book licensed creative common attribution license updating detecting intersection sweeping intersection degenerate configuration numerical error robustness closest pair problem applied closest pair problem implementation analysis sweeping dimension algorithm data structure global textpart programming environment motion graphic geometry text book discus programming environment design versus formal notation solution primitive operation programming activity independent language purpose artificial programming environment program designed barest tool paper pencil programmer head realm informal environment program design contain vague concept expressed informal notation execute program programmer need programming environment typically complex distinct component computer operating utility program library text program editor various programming language processor real programming environment force programmer express formal notation programming realization solution problem expressed term operation provided given programming environment programmer work environment provide powerful operation tool powerful programming environment simpler programming task expert achieved mastery environment experienced programmer need month master new programming environment novice frustration multitude concept detail understand writing simplest program simpler programming environment easier write run small program work write substantial useful program early day computing proliferation programming language programmer worked environment exceedingly simple modern standard acquaintance assembler loader small program library sufficed program wrote small compared professional programmer writes today simpler programming environment better suited learning program ala today simple environment hard home computer equipped complex software easily ignored bypassed sake education useful invent artificial programming environment purpose illustrate important concept simplest possible setting facilitate insight book introduces toy book licensed creative common attribution license programming environment suitable programming graphic motion illustrates gradually enriched approach simple useful graphic environment textbook computer graphic graphic screen powerful new medium communication visualization make possible present result computation intuitively appealing way convey insight easily gained manner exploit medium programmer master basic visualization technique refer reader interested systematic introduction computer graphic excellent textbook bg fdfh n rog wat wol algorithm data structure global textthis book licensed creative common attribution license reducing task given primitive programming motion learning objective specifying motion algorithm informal notation programming language verification optimization robot car capability task performed aspect programming learned computer inventing artificial programming environment purely mental exercise example vehicle move program control fictitious landscape microcosmos programming lore section introduce important concept reappear later elaborate setting environment consider square grid portion enclosed wall horizontal vertical line segment run halfway grid point exhibit robot car enclosed wall move grid computer control step time grid point adjacent grid point step robot state described location grid point direction north east south west exhibit robot crosshairs current location grid robot controlled program us following command left turn degree counterclockwise right turn degree clockwise forward step grid point goto send program control label touch goto touching wall send program control label algorithm data structure global text reducing task given primitive programming motion program robot sequence command distinct label label serve merely identify command need arranged consecutively increasing order execution begin command proceeds successive command order appear flow control redirected goto command example following program move robot forward bump wall touch goto command just label developing program robot feel free use language prefer embed robot command expressed program simpler statement touch forward translated robot language program robot car patrol wall city consists part wall problem just solved second wall forever maintaining condition lose touch wall time step spot wall monotonic progression mental image walking room eye closed left arm extended left hand touching wall time prove useful mirror solution start robot wall immediate left robot sensor left let turn left step sense wall bumper turn right resume position wall left algorithm described informally idea solution touch wall left hand forward turning left right required touching wall algorithm described english clockwise starting left look direction blocked wall step direction let test algorithm critical configuration robot inside unit square turn forever finding direction step exhibit exhibit robot negotiates spike step wall exhibit robot enters blind alley end alley turn clockwise twice exit route entered exhibit robot box spin heel book licensed creative common attribution license exhibit robot turn spike exhibit backing blind alley algorithm specified language idea presented informally section precise following elegant concise program wall loop wall left wall touch wall right wall endwhile wall forward wall forever wall program verification comment brace program invariant assertion state robot true time flow control reach place program written need type invariant verify program wall wall wall relationship robot position presence nearby wall hold assertion true illustrated exhibit shaded circle indicate point wall pas robot command transforms precondition assertion true command executed postcondition assertion true execution command predicate transformer suggested exhibit exhibit type invariant relate position robot wall algorithm data structure global text reducing task given primitive programming motion exhibit robot motion predicate transformer algorithm programmed robot language straightforward translation program robot language yield following program loop left touch touch goto right endwhile forward forever robot program optimized designing program best follow simple general idea decide detail straightforward manner regard alternative way available handling detail program proven correct run try improve efficiency measured time memory requirement process program transformation syntactically merely considering definition individual statement algorithm example derive version program transforming program step complementary primitive touch goto simplify flow program left shown right wall wall touch goto touch goto wall wall book licensed creative common attribution license optimization technique called loop rotation allows shorten program instruction change structure program significantly way label permuted assertion wall attached line serf invariant loop turning right ca advance wall touch goto programming project data structure suitable storing wall horizontal vertical line segment square grid bounded size write interactive program let user define modify instance wall algorithm animate execution tracking wall entered editor specifically robot position orientation change state algorithm data structure global textthis book licensed creative common attribution license graphic primitive environment learning objective graphic graphic toolbox program graphic polyline input turtle graphic basic environment seymour papert introduced term turtle graphic denote set primitive line drawing originally implemented programming language logo turtle graphic primitive available computer system language come different version essential point introduced example robot car pen turtle device state position direction driven incremental operation turn transform turtle new state depending current state s s unit step direction facing turn d turn counterclockwise d degree turtle initial state set following operation moveto x y position x y absolute coordinate turnto d face d degree east addition specify color trail drawn moving pen pencolor c c white black example following program fragment approximates circle tangential origin drawing sided polygon moveto position pen origin turnto face east step arbitrarily chosen step length time side step turn degree counterclockwise graphic programming likely use basic figure circle time different size position wish turn program fragment circle approximation reusable procedure algorithm data structure global graphic primitive environment procedure building block program built component different level complexity lowest level construct provided language use constant variable operator expression simple unstructured statement higher level procedure let refer program fragment arbitrary size complexity single entity build hierarchically nested structure modern programming language provide level packaging module package useful grouping related data procedure limit discussion use procedure programmer accumulate collection useful program fragment programming language provide concept procedure major tool turning fragment reusable building block procedure consists part distinct purpose heading specifies important procedure external behavior list formal parameter type data move procedure body implement action performed procedure processing input data generating output data program fragment embodies single coherent concept best written procedure particularly true expect use fragment different context question general want procedure deserves careful thought procedure specific rarely useful general unwieldy large slow just difficult understand generality procedure depends primarily choice formal parameter example long road procedure circle let illustrate issue discussing design consideration procedure draw circle screen program fragment drawing regular polygon easily turned procedure ngon n s integer n number side s step size var j integer begin j div n n s turn j end useful procedure draw circle requires additional argument let start following procedure circle x y r n integer centered x y r radius n number side var s integer angle step counter begin moveto x y r circle turnto east div n s r sin inscribed circumscribed polygon n s turn end procedure place burden choosing n programmer sophisticated adaptive version choose number side function radius circle drawn assume length measured term pixel picture element screen observe circle radius r book licensed creative common attribution license length approximate drawing segment pixel long needing line segment procedure circle x y r integer centered x y radius r var s integer angle step counter begin moveto x y r circle turnto east div r line segment s r sin inscribed circumscribed polygon r s turn end circle procedure suffers severe shortcoming discretize circle set pixel unnecessary detour step discretize circle polygon second discretize polygon pixel process source unnecessary work error approximation circle polygon computed vertex vertex lead rounding error accumulate polygon fail close particular using integer computation inherent large rounding error procedure attempt draw circle infinite screen computer screen finite attempted drawing screen boundary cause error circle ought clipped boundary arbitrarily specified rectangle writing good circle procedure demanding task professional started discussion desideratum difficulty simple library procedure reader appreciate thought effort building useful programming environment chapter return problem present possible goal long road procedure make huge jump artificially small environment discussed far today realistic programming environment graphic quickdraw graphic toolbox sake concreteness section program written specific programming environment macpascal using quickdraw library graphic routine app purpose duplicate manual convey flavor realistic graphic package explain quickdraw reader understand program follow treatment highly selective biased concerning circle attempted program quickdraw offer procedure drawing circle related figure procedure frameoval r rect procedure paintoval r rect procedure eraseoval r rect procedure invertoval r rect procedure filloval r rect pat pattern inscribes oval aligned rectangle r side parallel ax touch side r square oval circle quote app algorithm data structure global graphic primitive environment frameoval draw outline just inside oval fit inside specified rectangle using current grafport pen pattern mode size outline wide pen width tall pen height drawn pnpat according pattern transfer mode specified pnmode pen location changed procedure right away notice comparing quickdraw simple turtle graphic environment introduced earlier stroke frameoval appears able produce different picture exploit power learn grafports pen width pen height pen pattern pattern transfer mode draw perimeter oval paint interior paint oval current grafport background pattern complement pixel vice versa additional argument specifies pen pattern used painting interior need know order use procedure need know specify rectangle quickdraw predefined type somewhat ambiguously programmer choice following interpretation type rect record left right integer end type rect record topleft botright point end interpretation type type point record v h integer end exhibit illustrates provides information concept show plane coordinate v run second coordinate h run left right reason v running vice versa used math book compatibility text coordinate line naturally numbered domain v h integer point addressed screen shown intersection grid line line grid point infinitely extension pixel unit square pixel paired left grid point information let draw slightly fat point radius pixel grid point integer coordinate v h calling paintoval v h v h exhibit screen coordinate define location pixel understand procedure section reader understand detail key aspect interactive graphic synchronization device program execution screen picture controlled pixel level book licensed creative common attribution license synchronization interactive application wish specify grid point letting user point cursor spot screen getmouse v h return coordinate grid point cursor located moment executed track paint path mouse loop repeat getmouse v h paintoval v h v h stop doe user timing control want computer read coordinate mouse cursor clicking mouse button usual way tell computer predefined boolean function return mouse button depressed synchronize program execution user click programming busy waiting loop repeat button wait button pressed button wait button released following procedure wait click procedure waitforclick begin repeat button button end pixel acrobatics quickdraw pen parameter set draw line paint texture great visual variety pen location pen size rectangle given height width pen pattern drawing mode pixel affected motion pen shown exhibit exhibit footprint pen predefined value include set calling predefined penpat pat pattern gray default background drawing usually serf erasing result drawing depends critically transfer mode value include transfer mode boolean operation executed parallel pair pixel corresponding position screen pen pattern us pattern pixel overwrite screen pixel ignoring previous value default frequently used transfer mode paint black pixel screen pixel pattern pixel black progressively blackens screen algorithm data structure global text graphic primitive environment known odd parity set result black iff exactly screen pixel pattern pixel black white pixel pen leaf underlying screen pixel unchanged black pixel complement black pen inverts screen set calling predefined penmode mode integer patxor meaning remaining predefined procedure example use easily guessed terminate peep key detail powerful graphic package turn example use graphic frame program reusable software time saving concept practiced profitably small program contains useful procedure display sample result conduct minimal dialog user step execution frame program real purpose facilitate development testing new procedure embedding tested environment simple frame program like make easy novice write interactive graphic program particular frame program contains procedure input display point line circle screen idealized euclidean plane disregarding discretization raster screen procedure short asks introduced example convert integer mouse coordinate v h point p real coordinate enables refer point p mentioning coordinate explicitly bringing closer standard geometric notation make program readable procedure hand useful routine interactive input line segment us technique familiar user graphic editor user press mouse button fix endpoint line segment keep depressed moving mouse desired second endpoint time motion program keep displaying line segment look button released moment rubber band keep getting drawn erased move object screen user study key procedure prevents object erased modified collide rubber band temporarily set patxor encourage experiment modifying procedure way drawline black white turned procedure artful somewhat random painting brush patxor reestablishing default patcopy leave white followed second black naive routine alternate erasing draw drawing draw current rubber band doing modifies object share pixel rubber band example use versatile follow later book program frame provides mouse input drawing point line segment circle typepoint record x y real end linesegment record point endpoint end book licensed creative common attribution license varc p point r real radius circle l linesegment procedure waitforclick begin repeat button button end procedure getpoint var p point var v h integer begin getmouse v h v h convert integer real end procedure drawpoint p point pat pattern const t radius point begin penpat pat paintoval round t round t round t round t end procedure clickpoint var p point begin waitforclick getpoint p drawpoint p black end function dist p q point real begin dist sqrt sqr sqr end procedure drawline point pat pattern begin penpat pat moveto round round lineto round round end procedure dragline var l linesegment begin repeat button getpoint penmode patxor button begin drawline black replace artistic drawing tool getpoint drawline black end penmode patcopy end dragline procedure drawcircle c point r real pat pattern begin penpat pat frameoval round r round r round r round r end procedure dragcircle var c point var r real var p point begin repeat button getpoint c r penmode patxor button begin drawcircle c r black getpoint p algorithm data structure global graphic primitive environment r dist c p drawcircle c r black end penmode patcopy end dragcircle procedure title begin showtext make sure text window showdrawing graphic window screen writeln program writeln simple graphic interaction routine writeln proceed waitforclick end title procedure begin writeln point drawing window clickpoint p writeln mouse enter line segment dragline l writeln center circle drag radius dragcircle c r end procedure epilog begin writeln end begin frame title epilog end frame example graphic routine polyline input let illustrate use frame program developing new graphic procedure choose interactive polyline input example polyline chain directed starting point segment coincides endpoint previous useful tool interactive input drawing straight line user click starting point subsequent click extends polyline line segment double click terminates polyline developed starting frame program particular procedure modifying adding procedure worked simplified frame program bit example original frame program us real represent coordinate point geometric computation way polyline graphic screen need integer changed type integer coordinate moment code polyline input partly procedure procedure iteration probably combined single procedure subprocedures need frame program tossed served purpose development tool program polyline enter chain line segment compute total length stop double click typepoint record x y integer end varstop boolean length real book licensed creative common attribution license p q point function eqpoints p q point boolean begin eqpoints end function dist p q point real begin dist sqrt sqr sqr end procedure drawline p q point c pattern begin penpat c moveto lineto end procedure waitforclick begin repeat button button end procedure nextlinesegment var stp endp point begin endp stp repeat drawline stp endp black try generate artful picture getmouse drawline stp endp black button button end nextlinesegment procedure title begin showtext showdrawing writeln start polyline writeln end segment writeln click stop end title procedure begin waitforclick getmouse stop false length penmode patxor stop begin nextlinesegment p q stop eqpoints p q length length dist p q p q end end procedure epilog begin writeln polyline length writeln end begin polyline title epilog end polyline programming project simple package turtle graphic operation graphic environment available computer package implement test procedure meet requirement listed end section turtle graphic basic environment algorithm data structure global graphic primitive environment personal graphic frame program described graphic frame program effort pay time saved later using program entire course book licensed creative common attribution license algorithm animation hear forget remember understand picture worth thousand art presenting information visual form learning objective animation code program algorithm snapshot visualization characteristic technique graphic screen powerful new communication medium mass communication medium know mass communication printed recorded audio street suitable delivering monolog unique strength new medium interactive presentation information ideally viewer drive presentation just pushing start button turning channel selector control presentation step control flow command faster slower repeat skip play backwards important barrage question area triangle zero double load beam world population grows bit faster powerful new medium challenge use using medium ask doe poorly screen ideally suited rapid accurate display information deduced large amount data mean straightforward algorithm lengthy computation response variety user input long variety contained algorithmically tractable narrow domain discourse adept task require judgment experience insight comparison speaker blackboard slow inaccurate small amount data tiny computation hope make technical shortcoming good judgment teaching experience insight subject way comparison book film accurately rapidly present result based data computation lack ability react user input algorithm animation technique displaying state program execution ideally suited presentation graphic screen need type computation technique producing reason animating program execution fall major category label checking exploring checking understand algorithm useful understand distinct point view static point view correctness proof based formulate invariant data preserved program operation abstract approach appeal rational mind second equally important point view dynamic watch algorithm pace variety input data concrete approach appeal intuition static approach relies mainly thinking dynamic approach call doing perceiving prime candidate visual algorithm data structure global algorithm animation computer interaction use algorithm animation user checking understanding algorithm checking algorithm principle reason practice faster safer computer animation double check exploring growing number application computer visualization replaced technique case example exploratory data analysis scientist know priori looking way look mass data generate picture special issue scientific visualization nie time static picture simulation onset turbulent flow prefer animation time turning technique animation computer technology midst extremely rapid evolution interactive image generation powerful graphic workstation rn survey state art fortunately animating algorithm presented book adequately graphic tool available workstation algorithm operate discrete data configuration matrix tree graph use standard data structure array list limited class algorithm software package help produce animation based specification minimum extra programming required example algorithm animation environment balsa bro b recent example xyz geobench animates geometric algorithm nsdab experience bottleneck algorithm animation extra code required graphic design want display keeping mind limitation work key point consider data doe look like defined mapping data space visual space defining mapping range trivial practically impossible kind data geometric data space function real variable natural mapping learned school help greatly getting feel data data dimension displayed screen using number straight forward technique projection subspace using color gray level fourth dimension power perception diminishes rapidly increasing dimensionality discrete combinatorial data natural accepted visual representation example draw graph mapping node point edge line representation natural graph embedded euclidean space road network readily make sense map thousand city road link extend arbitrary graph placing node screen hand random crisscrossing line little intuitive value addition inherent problem visual representation practical difficulty varied type abound example screen awfully small data set awfully large display largest screen animation run narrow speed range fast fail follow screen flicker disturbingly slow lack time observe book licensed creative common attribution license conclusion hold difficult animate simple algorithm discussed interspersing drawing statement normal code independent algorithm animated collection display interaction procedure built frame program section graphic frame program designing adequate graphic representation hard requires creative effort spend bulk effort topic nvh example convex hull point plane following program illustrative example algorithm animation animates algorithm construct half convex hull say upper half set point presented incrementally accepts point time lie right preceding one immediately extends convex hull algorithm explained sample problem algorithm program convexhull n point dimension constnmax max number point r radius point plot varx y dx dy array nmax integer b array nmax integer backpointer n integer number point entered far px py integer new point procedure pointzero begin n x y point fixed location dx dy assume vertical tangent b point paintoval y r x r y r x r end function nextright boolean begin n nmax nextright false begin repeat button button getmouse px py px x n nextright false begin paintoval py r px r py r px r n n x n px y n py dx n x n x n dx dy n y n y n b n n moveto px py line n n nextright true end end end procedure computetangent var integer begin b n dy n dx dy dx n begin dy n n dy algorithm data structure global algorithm animation b dx n x n x dy n y n y moveto px py line n n b n end moveto px py pensize line n n pennormal end procedure title begin showtext showdrawing make sure window lie writeln convex hull writeln n point plane sorted writeln computed linear time write point right click left quit end begin convexhull title pointzero nextright computetangent write end gallery algorithm snapshot screen dump shown exhibit taken demonstration program use illustrate topic discussed class snapshot convey information impact animation reader idea try select standard algorithm animation topic sorting random number generation example showing effect cumulative rounding error exhibit initial configuration data book licensed creative common attribution license exhibit snapshot sorting algorithm visual test randomness visual amazingly powerful detecting pattern certain kind midst noise random number generator rngs intended simulate noise mean simple formula pattern appear visual representation supposedly random number chance rng fail rigorous statistical test eye pattern detection ability serf disqualify faulty rng certify adequate exhibit show simulation galton board theory resulting density diagram approximate bellshaped gaussian distribution obviously rng used fall short expectation exhibit look suffices unmask bad rng numerics chaos chaos numerical computation following example show effect rounding error precision linear recurrence relation step linear recurrence constant coefficient domain real complex number algorithm data structure global text algorithm animation frequent formula evaluated scientific technical computation solution differential equation proper choice constant c initial value z generate sequence zk plotted plane complex number form different figure example generate circle picture exhibit generated d condition determine curve easily described circle running perimeter circle run stationary circle performed computation package let pick precision p number bit mantissa resulting picture look bit chaotic behavior come associate mathematics generating completely different linear recurrence computed error look regular notice image generated formula single bit difference precision used whim difference precision change image entirely book licensed creative common attribution license algorithm data structure global algorithm animation exhibit effect rounding error linear recurrence relation programming project personal graphic frame program programming project graphic primitive environment implement animate convex hull algorithm example book licensed creative common attribution license graphic frame program implement animate behavior recurrence relation discussed section gallery algorithm snapshot graphic frame program set dialog control operation sufficient guide user various step animation recurrence relation particular option time enter new set parameter execute algorithm animate mode run predetermined speed stopped user mode display change user enters logical command clicking mouse hitting specific key algorithm data structure global textthis book licensed creative common attribution license ii programming concept notation thought role programming notation programming language main interface programmer physical machine novice programmer tend identify programming programming particular language learned realization programming notation principle transcend language big step forward programmer development ii aim help reader step forward present example best understood focusing abstract principle algorithm design later grope suitable notation turn principle algorithm expressed sufficient executable keeping predilection graphic communication informal expression algorithmic idea pictorial example representation incomplete turned program formal notation literature programming language book present principle programming programming language higher level abstraction principle highlighted differ author author ranging intuitive understanding complete formality following textbook provide excellent sample broad spectrum approach as asu ben ben ben dij df gri mey algorithm data structure global textthis book licensed creative common attribution license algorithm program literature substance form learning objective large versus programming small flat program versus small deep program literature picture snowflake hilbert curve definition fractal production rewrite rule programming notation programming large versus programming small studying discussing art programming useful distinguish large program small program type impose fundamentally different demand programmer programming large large program operating system database system compiler application package tax organizational ability important issue dealt include requirement analysis functional specification compatibility system break large program module manageable size documentation adaptability new system new requirement organize team programmer test software issue staple software engineering compared daunting managerial design challenge task actual coding relatively simple large program flat listing consists comment interface specification definition declaration initialization lot code executed rarely function single page source code trivial considered difficult understand entire program need lot information understand page relates classic book programming large bro programming small small program kind discussed book challenge technical inventiveness algorithmic issue dominate programmer thinking algorithm solve problem efficient given circumstance time space doe data structure use contrast large program small program usually deep consisting short compact code statement executed understanding small program difficult initially chain thought subtle understand thoroughly reproduce time effort required mastery interesting small program algorithm data structure global algorithm program literature substance form best way started computer science encourage reader work detail example present book concerned programming small decision determines choice topic presented style presentation notation use express program explanation proof heavily influence comment technique programming style presentation appeal reader intuition formal rigor aim highlighting key idea argument make belaboring detail liberty using free notation suit purpose specific argument wish make trusting reader understands small program translate programming language choice nut shell emphasize substance form purpose ii help engender fluency using different notation provide example unconventional notation match nature problem intended translate program difference programming language merely syntactic include chapter cover basic syntax syntax analysis topic important right present early hope help student difference notation merely syntactic sugar documentation versus literature meant read instructive distinguish type written material corresponding type writing task document literature document constrained requirement kind read specific need arises rarely pleasure quality judged criterion formality conformity standard completeness accuracy consistency literature form art free convention read education entertainment quality judged aesthetic criterion harder enumerate one touchstone question meant read answer necessary document literature implies documentation large program typical chore written software engineering documentation topic importance grows size complexity documented hold small program documented explained literature ought idea program literature widely held knu key idea algorithm program text melt text way paragraph formula picture doe formal notation system designed support style programming integrates text code form package readable human executable machine knu notation used literate programming phase program evolution idea specification algorithm program detail good program understood appreciated awareness grand design guided programmer detail usually expressed formal notation grand design reason renounce formality attempt convey idea notation suit purpose insightful explanation let illustrate philosophy example book licensed creative common attribution license snowflake fractal picture intuitively characterized requirement picture size sufficiently magnified look like picture piece information required define specific fractal picture primitive serf copy primitive scaled different size composed generate picture recursive rule defines relative position primitive different size picture primitive surely best defined drawing manner composing primitive space call pictorial representation augmented verbal explanation style define fractal following production rule read follows line segment shown replaced polyline chain shorter segment shown exhibit start initial configuration consisting single segment exhibit apply production rule just segment current generation obtain successively second generation shown exhibit generation quickly exhaust resolution graphic screen printed page stop drawing curve obtained limit process continued indefinitely fractal draw exactly study mathematical object prove theorem exhibit production replacing segment polyline exhibit simplest initial configuration exhibit generation production rule drawn essence fractal sequence picture lead initial configuration hand quite arbitrary started regular hexagon single line segment picture obtained really lived snowflake initial configuration generates curve unmistakable pattern snowflake reader encouraged verify having familiarized object described let turn attention method description raise question formality executability notation notation sufficiently formal serve program computer draw family generation snowflake certainly stated certain rule colloquial language left completely unsaid implying sample drawing example consider question algorithm data structure global text algorithm program literature substance form segment replaced plain mountain center segment peak point drawing suggest peak stick curve outside method description extended formalized serve programming language fractal course example production shown exhibit specifies peak point segment production state new peak grow original segment specifies side side new segment aspect description left unspecified placement screen notation readily designed specify complete rigor syntax syntax analysis introduce basic technique designing using formal notation exhibit refining description specify orientation formalize method description turn notation depends purpose plan use book present just example share common design goal reader understand example practice design artificial programming language avoid sidetracked pedantic insistence rigorous notation inevitable overhead introducing formalism needed define detail prefer stop given information attentive reader grasp main idea example hilbert curve curve object mathematical curiosity nineteenth century used prove cardinality interval considered set point equal cardinality square finite region term describes surprising fact curve visit point square mathematics curve constructed limit infinite sequence curve c converges discretized plane screen limiting process needed typically dozen curve sequence paint pixel term quickly seen appropriate let illustrate phenomenon using hilbert curve david hilbert approximation shown exhibit picture suggest hilbert curve recursively composition rule complicated snowflake propose production shown exhibit capture essence hilbert similar curve pictorial program requires explanation hope reader understood notation useful inventing fractal production read obtain instance instance thing listed equivalently task specified task listed hand book licensed creative common attribution license exhibit generation family hilbert curve exhibit production painting square term quadrant production stand task paint square given size assuming enter lower left corner facing direction indicated arrow leave upper left corner facing direction indicated arrow assume turtle graphic primitive state brush given position direction hatching indicates area painted lie right line connects entry exit corner read paint right hand hatching stroke second production similar paint square left hand hatching stroke entering exiting indicated arrow side production easily explained say order paint square paint quadrant order indicated explicit instruction enter exit algorithm data structure global text algorithm program literature substance form direction face painting right left hand make sure brush exit quadrant get correct state entering requires brush turn left right curved arrow picture indicate continuous plane imagine brush turn heel discrete grid move grid point adjacent quadrant production omit rule termination simulating limiting process true curve draw screen need add termination rule specify thing invoke termination rule fixed depth recursion paint square invokes termination rule paint black case snowflake fractal primitive picture important composition rule omit following program implement specific version pictorial production shown procedure implement curved arrow production brush turn take step length s turn parameter introduced effect cumulative small error recursive procedure cause brush make turn yield hilbert curve reader encouraged experiment value program paintandwalk constpi s step size walk varturtleheading real counterclockwise radian halfturn depth integer recursive depth painting procedure turtleturn angle real turn turtle angle degree counterclockwise begin angle converted radian adding turtleheading turtleheading angle pi end turtleturn procedure turtleline dist real draw straight line dist unit long begin line round dist co turtleheading round turtle heading end turtleline procedure walk halfturn integer begin turtleturn halfturn turtleline s turtleturn halfturn end procedure qpaint level integer halfturn integer begin level turtleturn halfturn begin qpaint level walk halfturn qpaint level halfturn walk qpaint level halfturn walk halfturn qpaint level end end qpaint begin paintandwalk book licensed creative common attribution license showtext showdrawing moveto turtleheading initialize turtle state writeln halfturn hilbert curve readln halfturn turtleturn init turtle turning angle write depth readln depth qpaint depth halfturn end paintandwalk summary discourse notation point fact executable program necessarily specify detail irrelevant point view human understanding book assumes reader learned basic step programming thinking detail able express formally programming language compare verbosity program clarity conciseness pictorial production state essential recursive construction manner human understand glance aim notation appeal human mind necessarily computer choose notation accordingly pascal dialect lingua franca computer science lingua franca common language consists italian mixed french spanish greek arabic spoken mediterranean port various language used common commercial tongue people diverse speech resembling common language webster collegiate dictionary pascal representative today programming language definition fit pascal mainstream development programming language couple decade pascal embodies simple design important language feature commonly accepted simplicity combined pascal preference language feature understood make pascal widely understood programming notation highlight development programming language explain pascal got lingua franca computer science fortran emerged programming language gain acceptance programming language early appearance generated great activity language design suddenly dozen programming language emerged algol cobol lisp milestone development programming language way cobol widely used language lisp innovative algol influential respect set new standard rigor definition description language pioneered hierarchical block structure major technique organizing large program major technical contribution family mainstream programming language includes algol pascal ada decade remained great ferment productivity field programming language algol ambitious project attempted integrate recent advance programming language technology theory captured lion share attention year pascal smaller algorithm data structure global algorithm program literature substance form project language designed niklaus wirth ended eclipsing major effort pascal took best algol streamlined form added just major extension novel type definition hoa lightweight edifice possible implement efficient pascal compiler microcomputer mushroomed mid ucsd pascal opened door university high school pascal programming language widely used introductory computer science education computer science student fluent pascal widely understood base programming notation adhere slavishly pascal year old key idea year old today insight programming language detail probably chosen differently dialect pascal typically extend standard defined wir different direction extension relevant publication language today hardware support large character set different font style greater variety symbol used make source readable following example introduce convention use syntactic sugar look programming notation pascal statement lack explicit terminator make frequent use bracket necessary following program fragment implement insertion sort algorithm chapter section simple sorting algorithm work time denotes constant key value n begin j j j begin t j j j j t j j end end aim brevity readability wish retain flavor pascal extent new notation introduce translated routinely standard pascal write statement follows n begin j comment appear italic j j j j j j brace serve bracket including denotes exchange operator end borrowing heavily standard mathematical notation use conventional mathematical sign denote operator pascal designation constrained small character set typical early day x respectively use sign direct counterpart pascal relation infinity used sentinel number larger number processed given book licensed creative common attribution license application used define interval uncertainty sum product ceiling real number x smallest integer x floor real number x largest integer x square root log logarithm base ln natural logarithm base e iff cavalier attitude notational difference readily use concise notation verbose try remind reader explicitly assumption question semantics example assume boolean operator conditional called expression containing operator evaluated left right evaluation stop soon result known expression x y example x evaluated x evaluates entire expression y evaluated convention make possible leave y undefined x x evaluates proceed evaluate analogous convention applies x program structure concise notation introduced denote operator translated single line standard pascal introduce extension affect program structure view change make program elegant easier understand borrowing modern language introduce statement exit procedure function return value computed function example function gcd u v integer integer computes greatest common divisor gcd u v begin v return u return gcd v u mod v end example merely replaces pascal assignment u gcd v u mod v particular illustrates avoids notational blemish pascal left second assignment denotes variable right function drastic consequence cause control exit surrounding procedure function soon executed entering controversy general advantage disadvantage flow control mechanism let present example typical search procedure greatly simplifies coding point search algorithm data structure global algorithm program literature substance form routine terminates different way successfully having item question unsuccessfully number reason item present index fall outside range table insert item table pop stack sake efficiency readability prefer exit routine soon case identified dealt following example address computation illustrates function x key addr var addr begin h x locate home address item x inserted t begin skipping cell occupied t x return x present return address mod m searching address end cell room x inserted n m n n t x msg return return address x inserted end code appreciated comparing alternative avoid use encourage reader try hand challenge notice different way procedure terminate need insert x x table impossible insert x table normal case x inserted standard pascal incorporates facility exception handling cover case occur rarely force outcome exit procedure textual end let just mention liberty pascal limit result function certain simple type let type particular structured type record array nesting statement order discriminate mutually exclusive case use flat legible control structure elsif elsif sn sample program return dynamically allocated storage explicitly rely memory management retrieves free storage garbage collection implementation pascal avoid garbage collection instead provide procedure programmer explicitly return unneeded cell work version pascal write program use significant amount memory insert call appropriate place program list intended exhaustive argue construct use necessarily superior commonly available reason extending notation pascal programming language chosen starting point following addressing human reader believe somewhat informal notation preferable straightjacket programming language necessary execute program incubation period book licensed creative common attribution license understanding slowly grows firm grasp idea supporting intuition important formality data structure algorithm help figure word program fit particular instance programming project graphic frame program graphic primitive environment implement editor simple graphic production used define snowflake line segment get replaced specified sequence line segment interpreter draw successive generation fractal defined production algorithm data structure global textthis book licensed creative common attribution license recursion learning objective algorithmic principle lead directly recursive procedure merge sort tree traversal recursion iteration friend liked claim cherokee challenge third mean maybe earth easy said jim parent algorithmic principle let d denote application algorithm set data d producing result important class algorithm type called process data distinct way according data small large set d small simple structure invoke simple algorithm application d yield set d large complex structure partition smaller subset d dk apply di yield result ri combine result r rk yield algorithmic principle lead naturally notion recursive procedure following example outline concept notation highlighting role parameter local variable procedure d data var r result var dk data rk result begin simple d thenr d dk partition d rk dk r combine rk end notice initial data set d spawn set s dk turn spawn child collection data set generated partitioning scheme tree root order recursive procedure d terminate case partitioning function meet following condition branch partitioning tree starting root d eventually terminates data set d satisfies predicate apply algorithm reduces problem data set d k instance problem new set d dk simpler original set simpler mean fewer element measure algorithm data structure global recursion simplicity monotonically head predicate algorithm finish job d simple mean d element case mean d exactly element just mark element having visited following section example algorithm actual workload distributed unequally different part algorithm sorting example step r rk requires work tower hanoi problem application algorithm take effort expressed diagram merge sort suppose wish sort sequence name alphabetically shown exhibit make use strategy partitioning large sequence d subsequence d sorting subsequence merging sorted order algorithm d d contains element identity algorithm d exhibit sorting sequence z s d using scheme procedure sort var d sequence var sequence function combine sequence sequence begin combine merge sorted sequence single sorted sequence d return d end combine begin sort split d sequence equal size sort sort d combine d trivially sorted end sort book licensed creative common attribution license chapter sorting complexity section merging merge sort turn scheme program recursively defined tree tree precisely rooted ordered tree data type used primarily model type hierarchical organization primitive part node leaf distinguished node called root violation nature typically drawn page tree growing downward node certain number child leaf node leaf child exact definition tree differ slightly respect detail terminology define binary tree example condition node exactly child pictorial grammar shown exhibit capture recursive definition tree fix detail left unspecified verbal description us alphabet symbol nonterminal symbol start symbol terminal symbol exhibit symbol alphabet tree grammar production rewriting rule exhibit derivation shown exhibit illustrates application production rule generate tree nonterminal start symbol exhibit rule generates leaf rule generates node new tree exhibit way derive tree right make production rule detailed explicitly naming coordinate associated symbol display device computer screen point typically cartesian coordinate origin corner increase increase right display let x y denote screen position associated particular symbol let d denote depth node tree root depth child node depth d depth different level tree separated constant distance separation sibling determined rapidly decreasing function t d take argument depth sibling depends drawing size symbol resolution screen detailed production shown exhibit algorithm data structure global text recursion exhibit adding coordinate information production order control graphic layout translation rule code plain procedure x y coordinate begin erasetreesymbol x y drawleafsymbol x y end procedure x y coordinate d level begin erasetreesymbol x y drawnodesymbol x y drawtreesymbol x s y t d drawtreesymbol x s y t d end choose t d c procedure produce display shown exhibit tree generated exhibit exhibit sample layout obtained halving horizontal displacement successive level technical remark detail defining binary tree grammar force node exactly child child node leaf let subsume frequently occurring class binary tree common definition binary tree identify leaf node making distinction replace square circle exhibit exhibit node new tree zero child smallest tree single node root arbitrary binary tree ignore leaf drop square exhibit exhibit branch leading square node new tree zero child smallest tree consisted single leaf node clarity sake following example use terminology node leaf introduced defining grammar instance point happens interpretation leaf dropped book licensed creative common attribution license recursive tree traversal recursion powerful tool programming algorithm straightforward manner particular data processed defined recursively recursive processing algorithm mirror structure data natural recursive tree traversal procedure illustrates point traversing tree general graph data structure mean visiting node leaf orderly sequence beginning ending root need node leaf concern traversal algorithm merely designate visit think inspecting content node leaf writing file recursive tree traversal use decompose tree subtrees node visited way subtrees l r left right node traversed natural way sequence node visit subtree traversal l r preorder prefix node r inorder infix r node postorder suffix following example translates traversal algorithm recursive procedure procedure traverse t tree preorder inorder postorder traversal tree t leaf begin leaf t thenvisitleaf t t composite root t traverse leftsubtree t root t traverse rightsubtree t root t end leaf ignored tree consisting single leaf considered procedure body slightly simpler t accomplish traversal scheme k k performs desired operation node visit visit print node obtain sequence node name called tree traversal shown exhibit traversal order composed traversal node visited following sequence algorithm data structure global recursion exhibit standard order merged triple tree traversal recursion versus iteration tower hanoi tower hanoi stack n disk different size held place tall peg exhibit task transfer tower source peg s target peg t intermediate peg disk time placing larger disk smaller case data set d tower n disk algorithm partition d asymmetrically small tower consisting single disk largest pile tower d usually larger conceivably consisting n topmost disk puzzle solved recursively step d intermediate peg largest disk target peg d largest disk target peg exhibit initial configuration tower hanoi step deserves explanation transfer n topmost disk peg notice constitute tower apply algorithm presented successively simpler problem solve transferring n topmost disk peg decreasing n finally n procedure hanoi n integer x y z peg transfer tower n disk peg x y z begin n hanoi n x z y x z hanoi n y x z end recursion advantage intuitive clarity elegant efficient solution complexity hidden bookkeeping implied recursion book licensed creative common attribution license following procedure equally elegant efficient iterative solution problem assumes peg cyclically ordered target peg disk come rest depends order parity n exhibit odd value n move tower peg value n peg exhibit cyclic order peg procedure iterativehanoi n integer var odd boolean odd represents parity begin odd true repeat case odd true transfer smallest disk cyclically peg false make legal leaving smallest place end odd odd entire tower target peg end exercise recursive iterative picture chapter presented beautiful example recursive picture hard program recursion simple recursive picture iteration just natural specify convenient set graphic primitive use write iterative procedure draw exhibit nesting depth given parameter exhibit interleaved circle equilateral triangle cause radius exactly halved step solution choice suitable primitive way program picture specifying equilateral triangle center radius circumscribed circle simplifies notation assume use procedure procedure circle x y r real coordinate center radius procedure equitr x y r real center radius circumscribed circle algorithm data structure global text recursion procedure citr x y r real d integer varvr real variable radius integer begin vr r d equitr x y vr vr circle x y vr radius consecutively nested circle get exactly halved step end flag alfanumerica algorithmic novel iteration recursion process automating flag industry united state alfanumerica announced competition elegant program print flag solution submitted prize committee fell class iterative recursive program proponent algorithm design principle agree winner selection process sparked civil war split nation iterative state alfanumerica isa recursive state alfanumerica rsa nation fly flag use entirely different production algorithm procedure isa k integer print isa flag using iterative algorithm course assume k power k half line length printer printer industry rsa innovative isa modern rsa printer include operation positioning writing head line line feed work forward backward precise operation rsa printer design using operation write recursive procedure rsa k integer print rsa flag unforeseen consequence drive automate flag industry alfanumerica isa rsa growing number flag seen fluttering breeze turned exercise algorithm usually attempt divide data equal half recursive tower hanoi procedure presented section versus iteration tower hanoi divide data asymmetric manner single disk versus n disk induction n iterative program anoi solves problem iteration k blank followed k starstwice blank followed star doubling halvingdown run length book licensed creative common attribution license syntax learning objective semantics diagram ebnf grammar nonterminal symbol ebnf tree avoid ambiguity prefix postfix notation arithmetic expression postfix notation need parenthesis syntax semantics computer science borrowed important concept study natural language notion syntax semantics syntax rule prescribe sentence language formed independently meaning semantics deal meaning sentence child draw horse horse draw child syntactically correct according accepted rule grammar sentence clearly make sense second sentence baffling senseless draw mean drawing picture meaningful draw mean pull semantic sentence meaningful difficult formalize decide syntactic issue analogy natural language programming language doe far choice english word phrase begin end goto lends programming language superficial similarity natural language possibility verbal encoding mathematical formula deliberately built cobol example compute velocity time time giving distance syntactic sugar distance velocity time important distinction natural language rigorously defined vocabulary syntax certainly semantics programming language defined according rigorous formalism programming language closer formal notation mathematics natural language programming notation accurate term lexical modern programming language alphabet set reserved word construction rule identifier equivalent vocabulary natural language syntax usually defined formally difference described precisely compiler determines syntactic correctness program respect certain computer operating semantics programming language defined formally rarely formal semantic definition extensive difficult read algorithm data structure global syntax syntax programming language important semantics good understanding syntax help understanding language practice guess semantics syntax syntax programming language frame support semantics grammar representation syntax diagram ebnf syntax modern programming language defined grammar type called grammar close variant thereof given different notation form bnf milestone development programming language introduced define syntax algol basis notation used today ebnf extended bnf graphical representation syntax diagram ebnf syntax diagram syntactic notation exactly grammar formal language theory recursion central theme notation syntactic correctness structure large program text reduced syntactic correctness structure textual component common notion include terminal symbol nonterminal symbol production rewriting rule nonterminal symbol generate string symbol set terminal symbol form alphabet language symbol sentence built ebnf terminal symbol enclosed single quotation mark syntax diagram terminal symbol represented writing oval nonterminal symbol represent syntactic entity statement declaration expression nonterminal symbol given consisting sequence letter digit character letter syntax diagram nonterminal symbol represented writing rectangular box construct consists catenation construct b expressed construct consists b denoted construct construct expressed construct consists catenation number including denoted ebnf parenthesis used group entity b book licensed creative common attribution license nonterminal symbol production describes syntactic entity formed terminal nonterminal symbol using composition construct following example production construct generate b c d denote terminal nonterminal symbol ebnf formal language finite alphabet symbol introduced built according rule explained great surprise ebnf used define use following name syntactic entity stmta syntactic equation expra list alternative term terma concatenation factor factora single syntactic entity parenthesized expression ntsnonterminal symbol denotes syntactic entity consists sequence letter digit character letter tsterminal symbol belongs defined language vocabulary vocabulary depends language defined production t ebnf defined following production stmt algorithm data structure global syntax expr term factor t expr expr expr letter digit example syntax simple expression following production nonterminals e xpression t erm f actor traced algol form core grammar arithmetic expression simplified grammar define class expression lack example unary minus operator convenient notation detail important purpose understanding grammar assigns correct structure expression simplified grammar constant variable replaced single terminal symbol exhibit t f e exhibit syntax diagram simple arithmetic expression nonterminal e derive different expression opposite direction start sequence terminal symbol check syntactic analysis parsing given sequence valid expression case grammar assigns expression unique tree structure parse tree exhibit book licensed creative common attribution license exhibit parse tree expression exercise syntax diagram palindrome palindrome string read read forward backward example palindrome differs reverse shortest palindrome syntax palindrome alphabet drawing syntax diagram solution shortest palindrome null string s s exhibit exhibit syntax diagram palindrome overly simple syntax simple expression doe grammar given previous section contain term factor expression e involves binary operator primitive operand abbreviated form e op e consider simpler grammar simple expression exhibit e e e algorithm data structure global text syntax exhibit syntax generates parse tree ambiguous structure expression derived e different way exhibit ambiguous grammar useless want derive semantic interpretation syntactic structure tree left contradicts conventional operator precedence exhibit incompatible structure expression explained simply possible albert einstein salvage idea grammar single nonterminal e enclosing expression form e op e parenthesis ensuring expression unique structure exhibit e e e exhibit parenthesis serve restore unique structure book licensed creative common attribution license doing change language complex grammar nonterminals e xpression t erm f actor let write expression partially parenthesized assigns unique structure compatible priority convention higher priority exercise ambiguity dangling problem dangling example syntax chosen simple task supposed handle syntax programming language pascal assigns nested statement ambiguous structure left semantics language disambiguate let e denote boolean expression s s statement pascal syntax allows type statement e s e s s syntax diagram express syntactic possibility possible syntactic structure statement small modification pascal language avoids syntactic ambiguity dangling modified pascal arbitrarily nested structure statement unique syntactic structure notation arithmetic expression usual infix notation arithmetic expression binary operator written operand operator precedence convention parenthesis required guarantee unique syntactic structure selective use parenthesis complicates syntax infix expression syntax analysis interpretative evaluation code generation complicated polish notation named polish logician jan lukasiewicz simpler notation arithmetic expression operator systematically written prefix notation postfix suffix notation operand apply restrict example binary operator operator different arity different number argument easily handled provided number argument used uniquely determined operator symbol introduce unary minus simply need different symbol binary minus postfix notation mirror sequence operation performed evaluation expression interpreted load operand load b second operand add syntax arithmetic expression postfix notation determined following grammar s s s algorithm data structure global syntax exhibit suffix expression unique structure use parenthesis exercise consider following syntax given ebnf s b b c b c d c d x determine set terminal nonterminal symbol b syntax diagram corresponding rule c following expression correct corresponding given syntax correct expression derived given rule x x x x x x x x x x x x x x grammar section include minus arithmetic operator turn expression negative different assumption unary minus denoted different character binary minus say b character used denote unary binary minus specific occurrence context determines operator designates form syntax diagram define language described using ebnf syntax diagram use following convention notation uppercase letter denote nonterminal symbol lowercase letter separator denote terminal stand null string notice blank character doe occur language use separate distinct sentence book licensed creative common attribution license l b zletter d digit s d sequence digit l d identifier real number constant pascal example b nonnested list identifier including list example year month day b c nested list identifier including list example addition example b list middle b d parenthesis expression problem c allow null string omit identifier comma allow multiple outermost pair parenthesis example syntax diagram ebnf define repeated statement elsif elsif s algorithm data structure global textthis book licensed creative common attribution license syntax analysis learning objective frame carry semantics language analysis tree parser analysis expression counting analysis recursive descent coroutines role syntax analysis syntax language skeleton carry semantics try work possible effect syntax analysis example compiling program translating language mainly semantic task good language compiler designed way syntax analysis determines start translation process process computer science sense syntax analysis important section derive algorithm syntax analysis directly syntax diagram algorithm reflect recursive nature underlying grammar program syntax analysis called parser composition sentence represented syntax tree parse tree root tree start symbol leaf represent sentence recognized tree describes syntactically correct sentence derived start symbol applying production underlying grammar exhibit exhibit unique parse tree parser begin start symbol goal analysis example search e production e tell obtain e sequence t separated look t structure tree expression grows way sequence goal root leaf satisfying goal nonterminal symbol parser read suitable symbol terminal symbol left right practical case parser need backtrack backtracking required current algorithm data structure global text á ffft syntax analysis input symbol nonterminal expanded determine uniquely production applied descent parser us set recursive procedure recognize input backtracking method build structure tree leaf root text reduced start symbol obtained syntax analysis expression counting syntax analysis simple arithmetic expression polish notation analyzed counting sake simplicity assume operand arithmetic expression denoted single character order decide given string c cn correct expression postfix notation form integer sequence t tn according following rule ti operand ti operator example correct expression example incorrect expression operator missing theorem string cn alphabet syntactically correct expression postfix notation associated integer sequence tn satisfies following condition ti n tn proof let cn correct arithmetic expression postfix notation prove induction length n string corresponding integer sequence satisfies condition base induction n correct postfix expression c sequence t desired property induction hypothesis theorem correct expression length induction step consider correct postfix expression s length m given alphabet let s si integer sequence associated s form s t u op operator t u correct postfix expression length j m length k m j k let t ti j u ui k integer sequence associated t apply induction hypothesis t sequence s composed t u follows book licensed creative common attribution license s sj sj sj sm tj uk t end add element u subsequence end u k finally operator decrease element s end s ti j ui k obtain s k s desired property proved direction theorem proof prove induction length n string c cn correct arithmetic expression postfix notation associated integer sequence satisfies condition stated theorem base induction n sequence t follows definition sequence correct arithmetic expression postfix notation induction hypothesis theorem correct expression length induction step let s si integer sequence associated string s c length m given alphabet satisfies condition stated theorem let j m largest index sj index j exists consider substring t c cj u cj cm integer sequence si j si j m associated t u satisfy condition stated theorem apply induction hypothesis obtain t u correct postfix expression definition integer sequence obtain c operand t u correct postfix expression s t u o p correct postfix expression theorem proved similar proof show syntactic structure postfix expression unique integer sequence associated postfix expression practical importance sequence describes depth stack evaluation expression largest number sequence maximum number storage cell needed analysis recursive descent return syntax simple arithmetic expression chapter section example syntax simple expression exhibit using expression example syntax diagram used analyze expression mean technique called parsing progress analysis depends current state symbol read lookahead exactly symbol suffices avoid backtracking exhibit step right symbol recognized vertically step recursion algorithm data structure global syntax analysis exhibit standard syntax simple arithmetic expression graphic doe match exhibit trace syntax analysis algorithm parsing expression turning syntax diagram parser programming language allows recursion syntax diagram simple arithmetic expression translated directly procedure nonterminal symbol corresponds procedure loop diagram generates loop selection translated statement procedure want delegate goal call cyclic order e call t call f call e procedure implementing recursive control structure called recursive coroutines book licensed creative common attribution license procedure follow embedded program provides variable procedure assume procedure print error message terminates program sophisticated implementation return message calling procedure error message returned ladder recursive procedure call active moment procedure character read furthermore assume correct expression terminated period read ch expression ch error exercise recursive algorithm translate simple arithmetic expression chapter section example syntax simple expression corresponding prefix postfix expression defined chapter section notation arithmetic expression inverse translation syntax diagram ebnf define language nested parenthesis expression bit freedom defining exactly correctly nested obviously definition include expression exclude string parsing algorithm class correctly nested parenthesis expression work counting recursive descent algorithm data structure global textthis book licensed creative common attribution license iii object algorithm program computing number object introduction computer decade ago meaning word computation kept expanding computation traditionally implied number today routinely compute picture text type object classified according type object processed type computer application stand prominently respect influence development computer science generation involved numerical computing applied mainly scientific technical problem data processed consisted exclusively number set number simple structure vector matrix program characterized long execution time small set input output data algorithm important data structure new numerical algorithm invented lasting achievement phase computer application include systematic study numerical algorithm error analysis concept program library programming language fortran algol second generation hatched need commercial data processing lead development new data structure business application thrive record keeping updating text form processing report generation computation numeric sense word lot reading storing moving printing data word application data intensive computation intensive focusing attention problem efficient management large dynamically varying data collection phase created core discipline computer science data structure corresponding algorithm managing data searching sorting generation computer application dominated computing geometric pictorial object change emphasis triggered advent computer bitmap graphic turn lead widespread use sophisticated user interface depend graphic rapid increase application design cad image processing pattern recognition medicine cartography robot control young discipline computational geometry emerged response growing importance processing geometric pictorial object created novel data structure algorithm presented part v vi selection algorithm iii reflects breadth application history just sketched choose simplest type object different domain computation concise elegant algorithm designed process study typical small program essential programming large computer science consists knowledge typical problem solved best way gain knowledge study main idea make standard program work algorithm data structure global syntax analysis algorithm program theoretical computer science treat algorithm formal concept rigorously defined number way turing machine lambda calculus context programming algorithm typically used intuitive concept designed help people express solution problem formal counterpart algorithm procedure program fragment express algorithm formally defined programming language process formalizing algorithm program typically requires decision superficial type statement chosen set loop great practical consequence given range value n algorithm asymptotic complexity analysis relevant misleading present algorithm notation appears convey key idea clearly clear preference picture present program extended version pascal reader little difficulty translating programming language choice mastery interesting small program best way started computer science encourage reader work example literature algorithm development new algorithm proceeding rapid pace decade specialist stay abreast state art subfield graph algorithm numerical algorithm geometric algorithm rapid development sure continue unabated particularly increasingly important field parallel algorithm cutting edge algorithm research published journal specialize research topic including journal algorithm algorithmica literature generally accessible student studied textbook algorithm ahu baa bb clr gb h knu knu knu man meh meh meh rnd sed wil wir book licensed creative common attribution license truth value data type bit acrobatics learning objective value bit variable function sum clever algorithm compared time space bit boolean function english mathematician george boole founder symbolic logic endeavored express logical argument mathematical form goal book law thought investigate law operation mind reasoning performed expression symbolic language calculus truth value boolean value named boole honor possess smallest possible useful domain binary domain represented late use binary arithmetic standard information theory came regard quantity natural unit information concise term bit coined abbreviation binary digit bit truly primitive data sufficient level happens today computer bit manipulation just bit simple data quantity doe mean processing necessarily simple illustrate section presenting clever efficient bit manipulation algorithm boolean variable range boolean value boolean function boolean argument produce boolean result distinct boolean function single boolean variable useful yield complement argument turn vice versa identity function yield constant distinct boolean function boolean variable frequently used particular negation implication function defined follows aba ba ba nand ba ba xor ba b bit atomic data element today computer programming language provide data type operator avoid necessity boolean expression fully algorithm data structure global truth value data type bit acrobatics parenthesized precedence relation defined operator take precedence take precedence x y x y x y x y compute boolean variable theoretically large finite domain represented sufficient number boolean variable integer example use boolean variable represent integer domain boolean variable used program optimization practical problem efficiency important swapping crossover versatile consider swap statement x y use abbreviate cumbersome triple t x x y y computer provide bitwise boolean operation register swap operator implemented efficiently use temporary variable operator abbreviated defined x xor y x y x yield true iff exactly argument true bitwise boolean operation z x op y register x n y n z n defined n z x op y bitwise swap x y programmed x x xor y y x xor y x x xor y take statement temporary variable given register usually short supply logical operation register typically just fast assignment code preferable exhibit trace execution code register show exhaustively swap performed correctly possible value x exhibit trace register x y repeated operation exercise planar circuit crossover wire code interpretation design logical circuit effect logical crossover wire x y avoiding physical crossover gate circuit diagram shown exhibit solve problem gate typically realized circuit built simpler primitive design circuit consisting gate effect crossing wire x y avoiding physical crossover exhibit gate series interchange value wire book licensed creative common attribution license bit sum population count computer word sequence bit bit vector typical word length instruction computer operate bit word time parallel efficiency great importance worth exploiting utmost bit parallelism built hardware computer today programming language fail refer explicitly hardware feature register word memory usually possible access individual bit know representation integer data type section freedom drop constraint strong typing built pascal modern language interpret content register word memory suit need moment bit string integer set aware danger ambiguous interpretation program compiler dependent lose portability ambiguity localized single small procedure danger kept control gain efficiency outweigh drawback pascal example type especially suited operate bit level s set b c consists set formed element b basic set m underlying declaration type s set m consists n element s element usually value type s internally represented vector n contiguously allocated bit bit element set computing value type s operate single bit using boolean operator union set type s obtained applying bitwise intersection applying bitwise complement set obtained applying bitwise example m set bit vector element integer represented small computer bit assume type word length defined pascal type set variable type set element represented vector bit asking number element set s asking number bit pattern represents operation count number element set number word called population count bit sum bit sum frequently used inner loop combinatorial calculation programmer tried make fast possible let look try beginning obvious algorithm data structure global truth value data type bit acrobatics inspect bit function w integer var c integer begin c inspect bit w w c c count one return c end skip zero faster way following algorithm look myster iou tricky expression w w contains intersection operation assumes operand set subtraction assumes w integer c w c c w w w mixing make sense rely implicit assumption set integer represented bit vector usual binary number representation example show body loop executed rightmost w replaced w w w w clever code look skip loop executed time word saving worthwhile long sparsely populated word statement w w w w used integer w set operand intersection operation strongly typed language pascal allow mixing type following function conversion routine introduced avoid double interpretation type conversion requires extra time know set integer represented internally function w integer var c integer begin w c ø set begin convert type integer convert type integer intersection set c c end return c end book licensed creative common attribution license language provide facility permitting purely formal type conversion result work statement fortran variant record pascal conversion merely interpreting content given storage location different way logarithmic bit sum computer word length n following algorithm computes bit sum word w running loop time opposed n time n time following description hold arbitrary n understood easily n logarithmic bit sum work familiar principle let w denote word consisting n bit let s w bit sum bit string split w half denote left wl right wr bit sum obviously satisfies recursive equation s w s wl s wr repeating argument substring wl wr turn substring create arrive process compute s w process terminates hit substring length substring consisting single bit b case s b b repeated halving lead recursive decomposition w bit sum computed tree n addition shown n exhibit exhibit logarithmic bit sum algorithm result approach treating part w symmetrically repeated halving lead computation depth h obtain logarithmic bit sum apply additional trick performing addition parallel notice total length operand level pack single word arrange thing cleverly perform addition level machine operation addition word exhibit show number addition short string carried single addition long string s w denotes bit sum binary representation padded zero left appropriate length algorithm applied wl wr wl wr equal length exactly operation performed stage wl part wr corresponding part operation addition shifting operate word length n single operation interpreted performing operation shorter part w split logarithmic speedup work word length computer n example recursive splitting generates level translates iteration loop algorithm data structure global text truth value data type bit acrobatics exhibit process generated performed parallel shared data register algorithm best explained example use n extract bit w place zero left bit obtain w newly inserted zero shown small type extract bit w shift right place bit position w place zero left bit obtain w odd numerically add w wodd considered integer written base obtain w index bit pair bit right left w w zeroth pair w w second pair extract pair w w w w place pair zero left pair obtain w book licensed creative common attribution license extract pair w w w w shift right place bit position w w w w respectively insert pair zero left pair obtain w odd numerically add obtain w w w index quadruple bit extract quadruple w w w w place zero left obtain w w w extract quadruple w w w w shift right place bit position w w w w place zero left obtain w odd w w finally numerically add w w odd obtain w representation base bit sum w example following function implement algorithm logarithmic bit sum implemented computer apply addition division operation directly variable type performing type conversion necessary strongly typed language pascal function w integer constmask mask mask mask var d integer weven wodd begin d begin weven w mask w w d shift w right bit d wodd w mask w weven wodd end return w end algorithm data structure global truth value data type bit acrobatics time space fastest algorithm faster algorithm computing bit sum word optimal algorithm question optimality algorithm important answered special case algorithm optimal specify precisely class algorithm allowed criterion optimality case bit sum algorithm specification complicated largely arbitrary involving specific detail computer work make plausible argument following bit sum algorithm fastest possible us table lookup obtain result essentially operation penalty speed extravagant use memory space location making algorithm impractical small value choice algorithm involves various desirable property better algorithm aspect worse algorithm based idea precompute solution possible question store result simply look needed example n store information wordbit sum fastest way looking word w table assumption similar used preceding algorithm interpret w address memory cell contains bit sum w giving algorithm requires memory reference table lookup implemented computer function w integer const c array integer begin return c w end concluding exa mple notice variety algorithm exist computing bit sum based entirely different principle giving different space time solve problem brute force simple understand look bit requires time store solution separate case requires space logarithmic bit sum algorithm elegant compromise efficient respect space time merely challenge programmer wit exercise exactly distinct boolean function variable boolean function universal following sense boolean function f x y written nested expression involving written using boolean function variable universal book licensed creative common attribution license logarithmic bit sum algorithm strategy splitting w just halving split requires n addition algorithm data structure global textthis book licensed creative common attribution license ordered set learning objective ordered set search proof program correctness search permutation algorithm rotation clipping set element processed computer ordered according criterion preceding example population count operation set ordered arbitrarily implicitly simply mapped linear storage programmer using set ignore order imposed implementation access set function hide irrelevant detail case order imposed set accidental prescribed problem solved algorithm used case programmer explicitly deal issue order set use existing order advantage searching ordered set frequent task performed computer operate data item item selected set item searching ideal ground illustrating basic concept technique programming time ordered set need rearranged permuted chapter sorting complexity dedicated frequent type rearrangement permuting set element ascending order discus type rearrangement reordering set according given permutation sequential search consider simple case fixed set n data element given array const n n type index n elt var array n elt var array n elt sequential linear search simplest technique determining contains given element trivial example incremental algorithm process set data element time search x successful return index n point convention signal unsuccessful search convenient efficient encodes possible outcome single parameter function x elt index var index begin n access cand x n k k k x algorithm data structure global ordered set k k x n x return end operator used termination condition conditional evaluation proceeds left right stop soon value boolean expression determined yield immediately terminate evaluation boolean expression accessing avoiding error included assertion express main point necessary formal proof correctness mainly iteration loop extends element subarray known contain search argument assertion trivially true initialization n remains true body loop executed assertion state loop terminates way signal entire array scanned unsuccessfully index formal correctness proof include argument loop doe simple argument initialized n decrease iteration finite number step loop terminated boolean expression composed term reaching end array testing current array element second term unavoidable spared making sure x index drop end array achieved extending array cell placing search argument x sentinel true element x stop scan array sentinel exit loop value reveals outcome search convention signal unsuccessful search function x elt index var index begin x n x return end efficient sequential search unsuccessful search scan entire array n array element equal probability searched average number iteration loop successful search algorithm need time proportional n average worst case binary search data element stored array ordered according order relation defined domain k k n k k search element x faster comparison x array element m provides information doe unordered case result x m excludes m element m depending x greater smaller m exhibit book licensed creative common attribution license exhibit binary search identifies region search argument guaranteed absent following function exploit additional information const n n type index n elt var array n elt function x elt var m index boolean var u v index begin u v n u v begin u v k k u k x k v k n k x m value u m v x m thenv m elsif x m thenu m x m return true end u v k k u k x k v k n k x return false end u v bound interval uncertainty contain assertion state u known smaller x v n known greater assertion exit function state x index assertion u v signal interval uncertainty shrunk exists match algorithm algorithm correct independently choice m efficient m midpoint current search interval m u v div choice m comparison find x eliminates half remaining element iteration loop performed worst case exercise binary search array var array n integer contains n integer ascending order n write recursive binary search function rb x u v integer integer return x index x x b maximal depth recursive call term n algorithm data structure global texta m x mx m mif x lie ordered set c advantage disadvantage recursive binary search compared iterative binary search exercise searching partially ordered array consider n m array var array n m integer assume integer row column ascending order j j n j m j j n j design algorithm determines given integer x stored array algorithm word figure hint start comparing x m exhibit exhibit example idea excluded region b implement algorit hm function isinarray x integer boolean c algorithm s correct terminates determine worst case time complexity solution algorithm compare x m x smaller m x contained column search process continued comparing x m x greater m x contained row search process continued comparing x m exhibit show typical search process exhibit excluded region combine leave strip examine b function isinarray x integer boolean var r c integer begin r c m r n c ifx r c thenc c elsifx r c thenr r book licensed creative common attribution license x r c return true return false end c position invariant n j j m j c x j r x j state hatched row column contain r n c m x r c state r c index range x r c r n c state r c outside index range coupled implies x r n c o n j j m x j iteration loop decrease c increase r x contained array c zero r greater n finite number step algorithm terminates step algorithm eliminates row column right worst case work way upper right corner lower left corner n m step leading complexity θ n m permutation representation permutation consider array d n hold n data element type ordered position array rearranged according specific permutation given array exhibit show example n assume b c d e stored order rearranged order c e d permutation represented naturally permutation array t f declared var t f array n n exhibit show representation permutation decomposition permutation cycle element d move d d d d d closing cycle abbreviate cycle entire permutation represented exhibit permutation representation term cycle cycle representation intuitively informative directly reflects decomposition problem independent subproblems information easily extracted dispense parenthesis lead concise program algorithm data structure global text ordered set consider problem executing permutation place given data result stored array d small constant auxiliary storage used independently let use example permutation introduce notation frequently convenient illustrate choice primitive operation affect solution multiple assignment statement job using n d t d n d d f characteristic property multiple assignment statement sequence variable sequence expression sequence matched according length type value expression right assigned variable left expression evaluated using original value variable occur resulting value assigned simultaneously variable use sign designate concurrent parallel execution today programming language offer multiple assignment particular variable length used breaking multiple assignment single assignment usually force programmer introduce temporary variable example notice direct sequentialization n d t d n d d f faulty element d overwritten moved overwriting avoided cost nearly doubling memory requirement allocating array n data element temporary storage n t d n d computation auxiliary storage grows unnecessarily inefficient elegant permutation algorithm based conventional primitive single assignment statement assume permutation array destroyed permutation executed representation permutation preserved additional storage required bookkeeping typically size proportional additional space little n bit order distinguish element processed moved algorithm technically place nondeterministic algorithm problem rearrangement appear admit different solution phenomenon apparent considers multitude sorting algorithm literature reason clear n element moved matter element moved one later useful look nondeterministic algorithm refrain specifying precise sequence action taken instead merely iterate condition action statement meaning condition applies perform corresponding action algorithm nondeterministic distinct condition apply lot different place action book licensed creative common attribution license currently enabled adding sequential control nondeterministic algorithm turn deterministic algorithm nondeterministic algorithm corresponds class deterministic one share common invariant differ order step executed correctness nondeterministic algorithm implies correctness sequential instance good algorithm design practice develop correct nondeterministic algorithm turn deterministic ordering execution step goal efficiency mind deterministic sequential algorithm come variety form depending choice primitive assignment swap data representation technique focus consider technique cycle rotation cycle clipping cycle rotation follows naturally idea decomposing permutation cycle processing cycle time using temporary storage single element fit representation somewhat efficiently representation requires swap element us assignment cycle clipping us primitive element effectively step executing permutation need temporary storage element temporary storage tied necessary finish processing cycle starting clipped cycle order clipping work efficiently representation easier understand present cycle rotation cycle clipping leave algorithm exercise cycle rotation search algorithm naturally lead idea processing permutation cycle time element place destination bump avoid holding unbounded number bumped element temporary storage rotating cycle element time work best using representation following loop rotates cycle pass arbitrary index rotate cycle starting index updating f j initialize fork travel cycle p f j p j predecessor cycle d j save single element auxiliary variable p d j d p f j j j p p f j d j reinsert saved element cycle f j j fixed point code work trivially cycle length p f guard body loop executed statement f j j loop unnecessary rotating cycle purpose identify element placed final destination code iterated n yield permutation algorithm sake efficiency add detail avoid unnecessary movement d j d j possibly voluminous element guarding cycle length test f terminate iteration n ground n element permutation correct place using code lead n f rotate cycle starting index updating f exercise implement cycle rotation using representation hint use swap primitive element assignment algorithm data structure global ordered set cycle clipping cycle clipping key elegant permutation using representation step clip arbitrary element d arbitrary cycle length reducing length shown exhibit place d destination form cycle length need processing element displaces c temporary home cell vacated probably place previous home time come relocated final destination permuted element update permutation array reflect accurately permutation performed local operation vicinity element swapped somewhat like tightening belt notch element clipped cycle remain unaffected exhibit show example order execute permutation clip d cycle placing d destination d bumping c vacant cell d amount representing cycle product shorter cycle swap right away cycle executed later cycle remains unaffected oval exhibit indicate corresponding entry d t moved exhibit show happens cycle clipped swap t d t t d t exhibit clipping element cycle permutation exhibit effect swap caused condition t book licensed creative common attribution license cycle length left absence cycle length signal termination following condition action statement iterated long condition t met executes permutation represented array t t t d t t d t use multiple swap operator meaning evaluate expression using original value variable involved perform assignment simultaneously implemented using single assignment auxiliary variable type n type swap place element final position say j guarded swap virtue j t j nondeterministic algorithm executes n swap n element final position condition checked order long checked exhaustively example j j t j n j j t j t t d t t d t j j t j j n j t j value leftmost position cycle pass loop reduces cycle cycle length swap involve t asserted invariant j j t j precedes loop completion loop assertion strengthened include stated invariant j j t j reestablishes higher value vacuously true assertion serf basis proof induction final assertion just restatement assertion value t t n permutation implies n t n exercise cycle clipping using representation nondeterministic algorithm expressed multiple assignment n d d f equally valid representation analog n d t d representation contrast translated simple iteration condition action statement f f d f f d f salvage idea cycle clipping using representation exercise function implement sequential search sentinel shown section sequential search sentinel measure compare running time random array various size compare running time sequential search binary search random array size n n n sequential search obviously faster small value n binary search large n crossover explain observation algorithm data structure global textthis book licensed creative common attribution license string learning objective pattern string machine programming language support simple operation string comparison concatenation extraction searching searching specified pattern string text computational kernel string processing operation efficient algorithm developed potentially operation approach presented general allows searching pattern consists single string set string cardinality set influence storage space needed time lead concept machine fsm recognizing pattern consisting single string problem given long string z zn n character usually shorter string p p pm m character pattern nonoverlapping occurrence p sliding window length m left right z examining character z m time solve problem using m n comparison constructing machine pattern p suffices examine character z exactly shown exhibit state corresponds prefix pattern starting prefix ending complete pattern input symbol input character z zn step input character z j lead state corresponding prefix p pi state prefix p pi zj different state prefix λ zj example p barbara exhibit exhibit state diagram showing transition state transition lead initial state notice pattern sound repetitive overlap constructing machine pattern straightforward consider pattern k character identical text contains overlapping occurrence pattern contains occurrence machine constructed analogous fashion used find algorithm data structure global text string overlapping occurrence miss later one exercise construct machine detect occurrence pattern recognizing set string interpreter machine fsm called finite automaton typically used recognize pattern consist set string adequate treatment general problem requires introducing concept terminology widely used computer science given finite set input symbol alphabet denotes infinite set finite string including nullstring subset l finite infinite called set string language recognizing language l refers ability examine string z symbol time left right deciding z deterministic machine m essentially given finite set s state finite alphabet input symbol transition function f s x state diagram depicts state input lead state machine map string sequence state treating specific problem typically useful expand minimal definition specifying following additional concept initial state s subset f s final accepting state finite alphabet b output symbol output function g s b used assign certain action state use concept initial state s accepting state f define notion recognizing set string set l string recognized accepted machine m s f s f iff string l lead m s state s example exhibit show state diagram machine recognizes parameter list defined syntax diagram exhibit l letter stand character z d digit digit exhibit syntax diagram simple parameter list book licensed creative common attribution license exhibit state diagram machine accept parameter list starting state single accepting state straightforward implementation machine interpreter us transition matrix t represent state diagram current state s input symbol c lead state t s c convenient introduce error state capture illegal transition transition matrix t corresponding exhibit look follows l represents character d represents digit represents character explicitly mentioned ld state skip blank left parenthesis read reading variable identifier skip blank colon read reading type identifier skip blank right parenthesis read following suitable environment programming interpreter const nstate number state error state typestate nstate error state initial state inchar consecutive ascii character tmatrix array state inchar state var t tmatrix initializing transition matrix t procedure interprets machine defined process sequence input character jump state space produce output procedure silentfsm var t tmatrix var s state c inchar begin s initial state s read c s t s c algorithm data structure global text string end simple structure employed useful interpreter initialization error condition input processing transition state space handled procedure function implemented according desired behavior terminating procedure print message screen confirms correct termination input show error condition procedure fsmsim var t tmatrix var begin initfsm alive processinput transition terminate end exercise recognizer multiple consider set string alphabet represent multiple interpreted binary number design machine recognizing set right mlr read string significant bit significant left mrl read string significant bit significant solution left right let rk number represented k leftmost bit let b k bit interpreted integer r state correspond r k mod exhibit starting state accepting state exhibit machine computes remainder modulo left right right left rk induction power alternatingly congruent modulo mod k mod k odd need modulo counter appears exhibit row state starting state accepting state book licensed creative common attribution license exhibit machine computes remainder modulo right left exercise programming project state diagram machine search string z occurrence interesting pattern repetitive part state diagram machine detect occurrence pattern recognizer various day design machine automatic recognition set word text underlying alphabet consists lowercase letter z blank draw state diagram machine identify initial state indicate accepting state double circle suffices recognize membership set recognizing word individually pattern recognizer useful procedure function require parameter programming language incorporate concept parameter list reasonable syntax convention write header parameterless procedure function procedure p function f t procedure p function f t example pascal us convention allows procedure function procedure convention modify syntax diagram exhibit allow parameter list draw state diagram corresponding machine pascal defines parameter list mean syntax diagram shown exhibit algorithm data structure global text string exhibit syntax diagram standard pascal parameter list draw state diagram corresponding machine brevity sake consider reserved word atomic symbol string character book licensed creative common attribution license matrix graph transitive closure learning objective versus structured object versus undirected graph closure connectivity matrix matrix multiplication algorithm asymptotic notation s algorithm graph spanning tree systematic presentation data object useful distinguish primitive atomic object composite structured object preceding chapter seen type bit character identifier usually considered primitive word bit string character array identifier naturally treated composite proceeding common primitive object computation number let discus important type structured object matrix matrix filled simplest primitive object bit generate interesting problem useful algorithm path graph syntax diagram state diagram example type object abounds computer science graph consists node vertex edge arc connect pair node node edge additional information attached label number wish treat graph mathematically need definition object directed graph let n set n element n e binary relation e n ξ n denoted arrow consider n set node directed graph g e set arc directed edge directed graph g represented adjacency matrix exhibit n ξ n boolean matrix element j determine existence arc j j true iff arc path length derive path length lead relation denoted double arrow called transitive closure e j iff exists path j sequence arc ik j accept path length relation represented matrix exhibit algorithm data structure global matrix graph transitive closure c j true iff c stand connectivity reachability matrix c called transitive hull transitive closure smallest transitive relation encloses exhibit example directed graph adjacency connectivity matrix undirected graph relation e n ξ n symmetric ordered pair j node contains opposite pair j identify arc j j single edge unordered pair j book graph theory typically start definition undirected graph graph short treat special case directed graph occur computer science graph based concept edge node directed graph embody concept arc leading node boolean matrix multiplication let b c n ξ n boolean matrix defined type nnboolean array n n boolean var b c nnboolean boolean matrix multiplication c b defined implemented implemented procedure mmb var b c nnboolean var j k integer begin n j n begin c j false k n c j c j k b k j end end remark remember section pascal dialect lingua franca computer science usually assume boolean operation conditional argument evaluated far necessary determine value expression extension simple idea lead alternative way coding boolean matrix multiplication speed innermost loop large value explain following code equivalent k tt t ttt t tttt tt t ttt t ttc tt t ttathis book licensed creative common attribution license c j k n c j k b k j k k multiplication defines power give solution problem computing transitive closure denotes power formu la clear interpretation exists path length l j iff node k exists path length l k path length single arc k represents path length general al represents path length l l al j true iff exists path length l dealing directly adjacency matrix convenient construct matrix identity matrix value diagonal diagonal element true l describes path length l instead exactly equal l l transitive closur e efficiency algorithm measured number elementary operation executed given data set execution time elementary operation binary boolean operator used doe depend operand estimate number elementary operation performed boolean matrix multiplication function matrix size n concentrate leading term neglect lesser term let use asymptotic notation intuitive way defined formally iv number operation executed procedure multiplying boolean n ξ n matrix θ nested loop iterated n time cost computing repeatedly multiplying θ algorithm improved θ log n repeatedly squaring k k smallest power k n necessary compute exactly instead example suffices compute higher power contains path length graph node set equal set path length warshall algorithm search faster algorithm consider way iterating set path instead iterating path growing length iterate increasing number node used path node node idea lead elegant algorithm warshall war compute sequence matrix b bn j j true iff j j true iff j using node way j true iff j using node way bk j true iff j using node k way matrix express existence path touch increasing number node way node node j b n talk unrestricted path connectivity matrix c b iteration step bk computed formula algorithm data structure global matrix graph transitive closure bk j j k k j cost performing step θ cost computing connectivity matrix θ comparison formula warshall algorithm wit h formula matrix multiplication show replaced binary sight following procedure appears execute algorithm specified closer look reveals executes assignment innermost loop computes new value used immediately instead old one procedure warshall var nnboolean var j k integer begin k n n j n j j k k j assignment mix value old new matrix end thorough examination show naively programmed procedure computes correct result efficiently direct application formula matrix b encourage verify replacement old value new one leaf intact value needed later step following equality hold bk k k bk k j k j exercise distance directed graph floyd algorithm modify warshall algorithm computes shortest distance pair node directed graph arc assigned length assume data given n ξ n array real d j length arc node node arc exists d j set constant largest real number represented given computer write procedure work array d type type nnreal array n n real think meaning boolean operation warshall algorithm arithmetic operation play analogous role problem computing distance explain reasoning word picture solution following procedure implement floyd algorithm flo assume length nonexistent arc x min x x procedure dist var d nnreal var j k integer begin k n n j n d j min d j d k d k j end book licensed creative common attribution license exercise shortest path addition distance d j preceding exercise wish compute shortest path j realizes distance extend solution write procedure return result array type type nnn array n n n j contains node shortest path j path exists solution procedure shortestpath var d nnreal var nnn var j k integer begin n j n d j j j j k n n j n d k d k j d j d j d k d k j j k end easy prove j end algorithm iff d j path j minimum spanning tree graph consider weighted graph g v e w v v vn set vertex e e em set edge edge ei unordered pair v j vk vertex w e r assigns real number edge weight consider connected graph g sense pair v j vk vertex connected sequence edge following example edge labeled weight exhibit exhibit example minimum spanning tree tree t connected graph contains circuit pair v j vk vertex t connected unique sequence edge spanning tree graph g subgraph t g given set edge e t e tree satisfies additional condition maximal sense edge e e t added t destroying tree property observation connected graph g spanning tree weight algorithm data structure global text matrix graph transitive closure spanning tree sum weight edge minimum spanning tree spanning tree minimal weight exhibit bold edge form minimal spanning tree consider following algorithm grow et initialize set t spanning tree et et min cost edge doe form circuit added e t shrink et e initialize set edge t spanning tree et et max cost edge leaf t connected removal claim growing algorithm shrinking algorithm determine minimum spanning tree t spanning tree g e v j vk et define ckt e t circuit formed adding e t set edge et form path v j vk example exhibit spanning tree shown bold edge obtain ckt v t exercise edge e et exists exactly circuit e et t ckt e t graph formed et t e spanning tree local minimum spanning tree g spanning tree t property exist edge e et t ckt e t w e w t consider following algorithm computes local minimum spanning tree exchange t spanning tree exists e et t ckt e t w e w t et et t e exchange theorem local minimum spanning tree graph g minimum spanning tree proof theorem need lemma t t arbitrary spanning tree g t t exist e et e et e ckt e t e ckt e t proof t t spanning tree g t t exists e et et assume ckt e t e edge ckt e t form circuit t contradicts assumption t tree e ckt e t et assume e ckt e t et e ckt e t form circuit t contradicts proposition t tree e ckt e t et e ckt e t book licensed creative common attribution license proof theorem assume t local minimum spanning tree let t minimum spanning tree t t lemma implies existence e ckt e t et e ckt e t et w e w e graph defined edge e t e e spanning tree lower weight t t minimum spanning tree impossible follows w e e w e w e graph defined edge e t e e spanning tree lower weight t t local minimum spanning tree impossible follows w e w e follows w e w e hold graph defined edge e t e e spanning tree weight t replace t new minimum spanning tree continue replacement process t t finitely edge process terminate t equal t prof t minimum spanning tree theorem implies tree computed minimum spanning tree exercise extend transitive closure algorithm based boolean matrix multiplication computes distance b shor test path algorithm compute local minimum spanning tree minimum spanning tree theorem section entitled minimum spanning tree graph algorithm data structure global textthis book licensed creative common attribution license integer learning objective operation algorithm eratosthenes integer arithmetic remainder theorem number generator operation integer basic operation account lion share integer arithmetic mod product x y quotient x div y remainder x mod y related following identity x div y y x mod y x y programming language provide operation unfortunately tends behave differently different language different implementation language come learned school remainder division identity cornerstone number theory defines assuming operation defined used context nonnegative integer x y clear particular convention x mod y half domain integer consists negative number good reason extending basic operation domain integer possible exception y operation undefined result hinders portability testing program forbidden operation doe executed mistake computation nonrepeatable state example practical point view better leave x div undefined customary mathematics define result overflow feature typically supported hardware algorithm usually consider context nonnegative integer natural extension domain integer following section modular number representation unfortunately attempt extend domain integer run problem mentioned define let follow standard mathematical approach listing desirable property operation possess addition sacred identity consider symmetry div div y x div x div y plausible way extend negative number algorithm data structure global integer constraint possible value assumed x mod y y reduces convention nonnegative remainder x mod y important standard use partition set integer y residue class consider weak strict requirement number residue class given y varying x x mod y assumes exactly distinct value addition ask nonnegative remainder x mod y pondering consequence desideratum soon realize extended negative argument mean symmetry relatively innocuous case positive denominator y make impossible preserve following failed attempt show div mod div using fails weak condition consider essential incompatible y follows residue class modulo x mod yield value example mod mod mod doe fact x mod assumes value reasonable partition residue class important superficially appealing symmetry admit just wishful thinking giving reason knu chapter reducing task given primitive programming motion defines mean identity follows x mod y x y y x mod x implicitly defines x div y floor z denotes largest integer z ceiling denotes smallest integer knuth extends domain defining x mod x exception special case y knuth definition satisfies number residue class definition doe satisfy slightly complicated condition given y x mod y y y x mod y y y knuth definition added advantage hold real number useful operation expressing periodic behavior function tan x tan x mod π exercise definition definition conjunction identity meet strict requirement book licensed creative common attribution license solution exercise comparable table value knuth definition solution euclidean algorithm famous algorithm computing greatest common divisor gcd natural number appears book euclid element ca bc based identity gcd u v gcd u v v used u v reduce size argument smaller use property greatest common divisor integer u v gcd u u convention hold u gcd u v gcd v u permutation argument important termination following procedure gcd u v gcd v u q v integer formula translate directly recursive procedure algorithm data structure global integer function gcd u v integer integer begin v return u return gcd v u mod v end test relative size u v unnecessary initially u v recursive permutes argument argument larger second simple concise solution relatively high implementation cost stack introduced manage recursive procedure call consumes space time addition operation visible code test equality assignment hidden stack maintenance operation executed equally concise iterative version requires bit thinking writing significantly efficient function gcd u v integer integer var r integer begin v r u mod v u v v r return u end prime number sieve eratosthenes oldest algorithm type sieve named eratosthenes ca bc set element separated class good one bad one case life bad element easier good one sieve process successively eliminates element recognized bad element eliminated help identifying bad element element survive epidemic good sieve algorithm applicable striking asymmetry complexity length proof assertion p good element p bad element theme occurs prominently complexity theory problem appear admit algorithm time requirement grows faster polynomially size input np completeness let illustrate asymmetry case prime number eratosthenes sieve designed analogy prime good nonprime bad prime positive integer greater divisible prime defined term lack easily verified property prime factor trivial one prove prime suffices exhibit pair factor verification hand t proof prime hand elaborate general knowledge special property particular number verify number qualifies candidate factor factor obviously time consuming mere multiplication exhibiting factor multiplication example called trapdoor function function easy evaluate just multiplication inverse hard context inverse multiplication division factoriz ation modern cryptography relies difficulty factorization prime number sieve eratosthenes work follow mark smallest prime erase multiple desired range smallest remaining number prime mark erase book licensed creative common attribution license multiple repeat process number integer c n factored c b factor sieve eratosthenes mark prime n const n varsieve packed array n boolean p sqrtn integer begin n sieve true initialize sieve sqrtn trunc sqrt n suffices consider divisor number p p sqrtn begin p p n sieve false p repeat p p sieve p end end large integer range number represented directly hardware typically limited word length computer example small computer word length bit limit integer range number insufficient variety software technique used extend range differ greatly respect property intended application come additional cost memory time required performing arithmetic operation let mention common technique integer word used hold integer square available range compared integer stored word computer integer bit computer integer operation integer typically slower factor variable precision integer idea extended allocate word necessary hold given integer technique used size intermediate result arise course computation unpredictable call list processing technique manage memory time operation depends size argument linearly addition quadratically multiplication packed bcd integer compromise double precision variable precision come commercial data processing programmer defines maximal size integer variable used typically giving maximal number decimal digit needed express compiler allocates array byte variable contains following information maximal length current length sign digit stored bcd decimal representation decimal digit coded bit packed byte packed bcd integer expensive space time unused allocated space time arithmetic unsuitable lengthy computation ok data processing application algorithm data structure global integer modular number system poor man large integer modular arithmetic technique narrow range application extremely efficient combinatorial problem handle addition particularly multiplication unequaled efficiency lack equally efficient algorithm division comparison certain combinatorial problem require high precision solved division comparison modular number unbeatable chinese remainder theorem let mk pairwise relatively prime positive integer called modulus let m mk product given k positive integer r rk called residue ri mi rk exists exactly integer r r m r mod m ri chinese remainder theorem used represent intege r range r m uniquely residue modulo mi denote number representation r rk practicality modular number system based following fact arithmetic operation integer r range r m represented operation applied componentwise r rk modular number replaces single large range k operation type small range r rk s sk t tk r s mod m ri si mod mi ti k r s mod m ri si mod mi ti k r s mod m ri si mod mi ti example m following table number r range represented pair modulo modulo let r s r s modular representation r s r s useful modular number formed modulus m nearly million integer range r represented conversion decimal number modular form easily computed hand adding subtracting pair digit follows r add pair digit resulting sum mod r significant pair digit r alternatingly add subtract pair digit result mod largest integer produced operation component smaller cause overflow computer arithmetic book licensed creative common attribution license example r r mod mod r mod r mod mod r s s mod mod s mod s mod mod s r s modular arithmetic shortcoming division comparison overflow detection conversion decimal notation trigger intricate computation exercise fibonacci number modular arithmetic sequence fibonacci number defined xn n write recursive function b iterative function computes element sequence using modular arithmetic compute fibonacci number computer integer arithmetic largest integer c using modulus range integer represented uniquely residue r respect modulus d word formula compute triple r uniquely represents number r range e modify function b compute fibonacci number modular arithmetic modulus use declaration type triple array integer write procedure procedure modfib n integer var r triple solution function fib n integer integer begin n return n return fib n fib n end b function fib n integer integer var p q r integer begin n return n algorithm data structure global integer begin p q n r p q p q q r return r end end c range m m m d r r mod mod r mod r mod mod e procedure modfib n integer var r triple varp q triple j integer begin n j r j n begin j p j q j n begin j r j p j q j mod j p q q r end end end random number colloquial meaning term random implies unpredictable random number used computing situation unpredictability required desirable needed simulation sampling generation test data unpredictability certain statistical property random number generator program generates sequence number pass number specified statistical test additional requirement include run fast us little memory portable computer use different arithmetic sequence random number generated reproduced test run repeated condition practice random number generated simple formula widely used class linear congruential generator given formula ri c mod m characterized integer constant multiplier increment c modulus sequence initialized seed r constant chosen carefully consider bad example formula designed generate random day month february ri mod generates sequence r m generator form generates sequence prefix length m followed period length example book licensed creative common attribution license prefix length followed period length usually want long period result number theory assert period length m obtained following condition met chosen prime number multiple doe divide example ri mod generates sequence period length shall accept sequence random integer prefer sequence application random number identify important statistical property required normal circumstance include periodicity length sequence actually used example generate sequence random weekday su mo sat pick generator modulus generate period length pick period longer desired distribution uniform distribution range m partitioned k equally sized interval ik number generated uniformly distributed interval case end period trivially generator maximal period m initial sequence statistical test used check quality random number generator run test length monotonically increasing monotonically decreasing subsequence occur right frequency gap test given test interval called gap consecutively generated number fall outside permutation test partition sequence subsequence t element t possible relative ordering element subsequence ordering occur equally exercise visualization random number write program let user enter t constant c m seed r linear congruential generator display number generated dot screen pair consecutive random number interpreted x y dot observe generator enter obvious flaw visual excellent detector regular pattern regularity correspond undesirable statistical property point substantiated pm following simple random number generator property easily memorized ri mod remainder mod represented significant bit binary representation integer overflow regard representation negative number algorithm data structure global integer number rk generated exactly range r k rk mod period length statistical property described kru knu contains comprehensive treatment theory random number generator conclusion brief introduction remember important rule thumb choose random number generator random exercise detail implem enting bcd integer arithmetic estimate time required operation compared time operation single precision variable precision bcd introduce length l representation parameter common multiple lcm integer u v smallest integer multiple u design algorithm compute lcm u v prime decomposition natural number n unique multiset pd n pk prime pi product multiset differs set element occur repeatedly pd design algorithm compute pd n given n detail modular arithmetic modulus linear congruential random number generator given formula ri mod m prime modulus m disqualified sight simple visual test consider period rngs book licensed creative common attribution license real learning objective number property numeric computation method method number real number declared type real programming language represented number computer number z represented signed mantissa m signed exponent e respect base b section present brief introduction arithmetic recommend comprehensive survey number approximate real number important way behave differently major difference fact number finite number mantissa m exponent e lie bounded range consider simple example following number z e value number representation unique real number different representation arranged following table numerical value line constant exponent column table symmetric negative number notice cluster representable number zero different number different representation exercise number consider number represented word follows bit b b represent signed mantissa bit e e signed exponent base number form b algorithm data structure global real exponent mantissa integer represented complement form mean integer value assigned different representation e e shown following table value mantissa representation write formula compute v b b different number representation different number draw axis number representation machine number represented byte bit bit signed mantissa bit signed exponent mantissa m interpreted fraction m precision bounded bit exponent permit scaling range number system common coexisting hardware number system identified single precision double precision respectively recent year ieee standard format precision number emerged standard higher precision double single extended double extended book licensed creative common attribution license following example show representation number ieee format danger computation fraught problem hard analyze control unexpected result abound following example use binary number signed bit mantissa signed exponent representable number lie range z example y x y x suffices choose small compared example x y addition force mantissa x shifted right exponent equal x represented sum computed correctly accumulator double length storing result memory force rounding x example addition associative x y z x y z following value x y z assign different value left right side left right useful rule thumb help prevent loss significant digit add small number adding large one example x y let evaluate expression large small number decimal digit x y x y x y rounded digit yield x y digit lost x y digit lost result meaningless example numerical instability recurrence relation sequence number prone phenomenon numerical instability consider sequence xn algorithm data structure global real solve linear recurrence relation closed form trying x lead quadratic equation r solution r r general solution recurrence relation linear combination xi b starting value x determine coefficient sequence given exactly xi sequence xi computed recurrence relation number decimal digit following happen rounding exact value represented exactly decimal digit represented exactly decimal digit represented exactly decimal digit exact rounded represented exactly decimal digit represented exactly decimal digit soon rounding error occurred computed sequence change alternative solution x seen doubling consecutive computed value exercise number system calculation consider number ternary digit t mantissa ternary digit e exponent base number form x e assume value chosen draw diagram show different number number representation representation different number b recall series hold example use formula express series power horner method polynomial degree n usually represented form x better evaluated nested form x x x book licensed creative common attribution license formula need n multiplication form xi addition multiplication compute power second formula need n multiplication total power x obtained free effect coefficient multiplication following procedure assumes coefficient stored sufficiently large array type type coeff array m real function horner var coeff n integer x real real var integer h real begin h n n downto h h x return h end bisection bisection iterative method solving equation form f x assuming function f r r continuous interval b f f b root equation f x zero f lie interval b exhibit let m midpoint interval f m m root f m f root contained m proceed subinterval f m f b proceed m b iteration interval uncertainty contain root half size interval produced previous iteration iterate interval smaller tolerance root determined exhibit binary search bisection excludes half interval consideration step function bisect function f real b real real const epsilon var m real faneg boolean begin faneg f repeat m b f m faneg m b m epsilon return m algorithm data structure global real end sequence converging x converges linearly exist constant c index c algorithm said converge linearly sequence approximation constructed algorithm converges linearly linearly convergent algorithm iteration add constant number significant bit example iteration bisection half interval uncertainty iteration add bit precision result bisection converges linearly c sequence x converges quadratically exist constant c index c newton method computing square root newton method solving equation form f x example algorithm quadratic convergence let f r r continuous differentiable function approximation x obtained xi approximating f x neighborhood x tangent point x f xi computing intersection tangent exhibit x x exhibit newton iteration approximates curve locally tangent newton method guaranteed converge exercise construct counterexample converges doe quadratically fast iteration double number significant bit compute square root x real number consider function f x solve equation f x x obtain iteration formula formula relates x transformed analogous formula determines propagation relative error book licensed creative common attribution license obtain relative error using recurrence relation relative error start follows obtain soon ri small r ri obtain newton method converges quadratically soon x close true solution bad initial guess ri hand r ri obtain ri computation appears converge linearly r proper quadratic convergence start highly desirable start good initial approximation x quadratic convergence right beginning assume normalized binary number m m good approximation obtained choosing mantissa c c halving exponent order construct initial approximation x programmer need read write access real number component mantissa exponent example procedure procedure mantissa z real integer procedure exponent z real integer procedure buildreal mant exp integer real today programming language lack facility programmer forced use backdoor trick construct good initial approximation x constructed halving exponent obtain following upper bound relative error algorithm data structure global real remarkable iteration suffice compute exact square root number bit used mantissa bit sign bit exponent iteration number cruncher word length bit starting value x optimized choosing c carefully shown optimal value c computing square root real number c exercise square root consider number decimal digit mantissa number form x different number representation b different number reasoning c compute number using newton method starting value x step calculation round result operation digit immediately solution number representation contains sign bit decimal digit distinct number representation b source redundancy representation zero equal exponent mantissa detailed count reveals different number zero representation form sign bit decimal digit e freely chosen r subtracted e assume furthermore d case covered pair r subtracted case treated assume d assume different value pair subtracted different number c computing newton square root algorithm book licensed creative common attribution license exercise distinct number number representation form value mantissa exponent represented complement notation simple numerical example illustrate arithmetic violation mathematical identity algorithm data structure global textthis book licensed creative common attribution license straight line circle learning objective line segment configuration line circle algorithm straight line point simplest geometric object straight line line segment come make lion share primitive object used geometric computation computer graphic using primitive approximate curve draw picture mapped discrete raster query complex figure reduced basic query point line segment given point left right given line given line segment intersect simple question appear handled efficiently carefully efficiently basic primitive geometric computation likely executed million time single program run carefully ubiquitous phenomenon degenerate configuration easily trap unwary programmer overflow meaningless result intersection problem deciding line segment intersect unexpectedly tricky requires consideration distinct nondegenerate case half dozen degenerate one starting degenerate object case line segment degenerate point code assumes line segment length zero eliminated consider nondegenerate object degenerate configuration illustrated exhibit line segment b intersect strictly c d e f intersect intersection point infinitely extended line lie c case lie e f second case case degenerate g h intersect barely endpoint j overlap intersect infinitely point k l intersect careless evaluation case likely generate overflow exhibit case distinguished segment intersection problem computing intersection point infinitely extended line naive approach decision problem lead process algorithm data structure global text straight line circle line segment parallel necessary precaution attempting compute intersection point degenerate configuration lead special case collinear collinear nonoverlapping collinear overlapping intersection point extended line step subject numerical problem line parallel intersection point lie line segment want answer intersection question save effort computing intersection point obtain simpler robust procedure based following idea line segment intersect strictly iff endpoint line segment lie opposite side infinitely extended line segment let l line given equation h x y x b y c coefficient normalized line l given hessean normal form point p x y function h evaluated p yield signed distance p l h p p lie l h p p lie h p p lie line segment usually given endpoint x hessean normal form infinitely extended line l pass x length line segment h x y distance p x y point p q lie opposite side l iff h p h q exhibit h p h q signal degenerate configuration h p h q iff segment p q collinear exhibit segment s extended line l distance point p q computed function typepoint record x y real end segment record point end function d s segment p point real computes h p line l determined s var dx dy real book licensed creative common attribution license begin dx dy sqrt dx dx dy dy return dy dx end optimize intersection function recall assumption l notice need actual distance sig function d used avoids computing l function begin checking line segment collinear test overlap intersecting interval obtained projecting line segment segment vertical interval b c d intersect f min b max c d min c d max b condition simplified assumption representation segment interval ordered left right interval b b assume line segment natural direction turned function d s segment p point real begin return end function overlap b c d real boolean begin return min b max c d min c d max b end function intersect segment boolean var real begin d d collinear vertical return overlap vertical return overlap begin collinear d d return end end addition degeneracy issue addressed numerical issue mention length l condition number indicator computation accuracy exhibit suggests numerically impossible te ll short line segment l distant point p lie algorithm data structure global straight line circle exhibit point distance segment amplifies error computation conclusion geometric algorithm check degenerate configuration code handle configuration general position handle degeneracy clipping widespread use window graphic screen make clipping frequently executed operation given rectangular window configuration plane draw configuration lie window configuration consist line segment clip line segment given endpoint window given corner coordinate left right position point relation window described boolean variable ll left left border rr right right border bb lower border tt upper border type wcode set ll rr bb tt point inside window code ll rr bb tt false abbreviated exhibit exhibit clipping window partition plane region procedure determines position point relation window procedure classify x y real var c wcode begin c ø set x left c ll elsif x right c rr y c c bb elsif y c c tt end procedure computes endpoint clipped line segment call procedure draw procedure clip real l book licensed creative common attribution license var c wcode x y real outside boolean begin clip classify classify outside false ø ø ø line segment lie completely outside window ø ø outside true begin c c ø c c ll c segment intersects left y left x left elsif rr c segment intersects right y right x right elsif bb c segment intersects x y elsif tt c segment intersects x y c x y classify x y c x y classify x y c end outside showline x end clip drawing digitized line raster graphic screen integer grid pixel turned euclidean geometry doe apply directly discretized plane designer using cad prefer euclidean geometry discrete geometry model world problem approximate euclidean plane integer grid turn hard question map euclidean geometry digitized space way preserve rich structure geometry possible let begin simple instance map straight line integer grid draw efficiently exhibit show reasonable example exhibit digitized line look like staircase consider slope m segment endpoint p want pixel blackened x coordinate pixel y coordinate requirement consistent diagonal consider case unit step x take point x y line x y m x x paint pixel x y closest mathematical line according formula y round y m x case reverse role x y taking unit step y incrementing x following procedure draw line segment using unit step procedure line integer var x sx integer m real algorithm data structure global straight line circle begin paintpixel begin x sx sgn m x x x sx paintpixel x round m x end end straightforward implementation number disadvantage us arithmetic compute integer coordinate pixel costly process addition rounding error prevent line reversible reversibility mean paint pixel reverse order procedure endpoint interchanged reversibility desirable avoid following blemish line painted twice end look thicker line worse painting line end erasing leaf spot screen weaker constraint concerned result process painting easy achieve useful weak reversibility easily achieved ordering point p lexicographically x y coordinate drawing line left right vertical line solution inadequate animation direction drawing important sequence pixel painted determined application trajectory falling apple interactive graphic need stronger constraint efficient algorithm bresenham bre avoid arithmetic expensive multiplication incremental computation starting current point p point computed function current point line segment parameter turn addition shift comparison required following assume slope m line satisfies let δx sx sign δx δy sy sign δy assume pixel x y determined closest actual line want decide pixel set x sx y x sx y sy exhibit depicts case sx sy exhibit coordinate x sx identify paint pixel closest line let t denote absolute value difference y point abscissa x sx actual line t given book licensed creative common attribution license value t determines pixel drawn following example show reversibility automatic consequence geometric fact point determine unique line regardless correct rounding order endpoint presented problem arises grid point equally close straight line exhibit exhibit breaking tie equidistant grid point tie broken consistent manner taking upper grid point resulting algorithm fails reversible variable introduced problem range integer ratio δy δx appears introduce rational expression easily remedied multiplying δx define decision variable d d t sx δx t let di denote decision variable determines pixel x y drawn step substituting t inserting x x y y obtain di sx sy x sx δy y δx sy sx sy x sx δy y δx sy subtracting di di sx sy x x δy δx y y x x sx obtain di sy δy sx δx sy y y algorithm data structure global text straight line circle di di sy y y di di di sy y y sy di iterative computation d previous d let select pixel drawn initial starting value evaluating formula d knowing x y obtain arithmetic needed evaluate formula minimal addition subtraction left shift multiplication following procedure implement algorithm assumes slope line procedure bresenhamline integer var dx dy sx sy d x y integer begin dx sx sgn dy sy sgn d dy dx x y paintpixel x y x begin d d sy y y sy x x sx d d dy paintpixel x y end end riddle braiding straight line straight line plane intersect point right important geometric algorithm rest theorem euclidean geometry reexamined untrue theorem true computer line data object represent approximate straight line processed program yes yes possible course program geometric problem way pair straight line exactly intersection point readily achieved symbolic computation example intersection l denoted expression l evaluated simply combined expres sion represent geometric construction free postulate l point reason efficiency computer application geometry require immediate numerical evaluation geometric operation calculation discrete finite number case theorem need true fact easily seen work discrete plane pixel represent straight line set pixel uched ideal mathematical line exhibit show digitized straight line square grid model plane geometry line intersect common interval pixel pixel common obviously intersect book licensed creative common attribution license exhibit intersecting line share pixel arithmetic situation complicated fact remains euclidean plane replaced discrete set point embedded point coordinate representable particular number used experience numerical computation hazard rounding error suggests question point straight line intersect admits following answer mathematically correct intersection represented number set point lie close example interval abort calculation result computed correct result representable number used exercise line intersect point construct example illustrate phenomenon using arithmetic choose suitable g number distinct straight line ai x bi y ci ai bi ci g operation performed g point coordinate x y g satisfy linear equation b point coordinate x y g satisfy linear equation c exactly point coordinate x y g satisfy linear equation straightforward computation x y lead overflow d consequence follows definition line intersect share common point inappropriate numerical computation formulate numerically meaningful definition statement line segment intersect exercise b suggest point shared line neighbor pictorially slope line identical expect blurred elongated intersection worse thing happen straight line intersect arbitrarily point point separated interval line alternate lying computer line braided understand algorithm data structure global straight line circle phenomenon need clarify concept exactly straight line represented computer intersection answer consider analogy mathematical concept real number defined axiom approximate real number computer choice different number system various number system rational arithmetic variable precision interval arithmetic system typically defined mean axiom term concrete representation number algorithm executing operation number similarly computer line defined term concrete representation point point slope linear expression obtain depends formula use basic arithmetic operate representation notion straight line formalized different way likely mathematically equivalent lead data object different behavior evaluated numerically performing operation consists evaluating formula substituting formula mathematically equivalent lead result topologically different equivalent formula exhibit different sensitivity rounding error consider computer integer arithmetic use operation div let z set integer straight line g given following equation ai x bi y ci ai bi ci z bi consider problem given straight line intersect given point x use following method solve equation y y e x y x test e equal method suitable need following definition x z turn pair iff sign x x sign x x algorithm intersection problem correct iff turn intuitive idea definition recognition rounding error force deal intersection interval single intersection point wish avoid separate interval definition partition disjoint interval left interval line lie second line middle interval line intersect right interval complementary relation left exhibit book licensed creative common attribution license exhibit desirable consistency condition intersection nearly parallel line consider straight line x y x y lead evaluation formula naive approach compare expression x div x div using definition easy calculate turn straight line step function intersect time braided exhibit exhibit braiding straight line violate consistency condition exhibit exercise straight line x y k x k y integer k algorithm data structure global x x div div straight line circle k turn quadrant braiding merely integer arithmetic certainly rounding error occur arithmetic construct pathological behavior example consider arithmetic mantissa perform evaluation operation truncate intermediate result immediately decimal place consider straight line exhibit x y x y exhibit example verified manual computation example constructed intersecting straight line numerically conditioned problem working integer arithmetic mistake using operator comparison rational expression doe require division let x y x y straight line intersect x check equa lity hold equivalent formula evaluated error sufficiently large integer argument allowed way evaluate formula error limit size operand example bi ci binary number suffices able represent binary number compute digit binary number example demonstrate program ming simple geometric problem cause unexpected difficulty numerical computation force rethink redefine elementary geometric concept book licensed creative common attribution license digitized circle concept problem technique discussed chapter restricted dealing straight counterpart kind digitized spatial object straight line defined linear formula simplest nontrivial spatial object best suited illustrate problem solution section incremental drawing technique generalizes straightforward manner complex object circle basic parameter define circle center coordinate x c yc radius simplify presentation consider circle radius r centered origin circle given equation efficient algorithm drawing circle bresenham bre avoid arithmetic expensive multiplication incremental computation new point computed depending current point circle parameter bresenham circle algorithm conceived use pen plotter generates point circle centered origin incrementing way circle present modified version algorithm take advantage symmetry circle x y point circle easily determine seven point lying circle exhibit consider segment circle shown figure incrementing x x y r use symmetry display point entire circle exhibit eightfold symmetry circle assume pixel p x y determined closest actual circle want decide pixel set p x y x y restrict circle segment shown pixel candidate define d x d x y difference squared distance center circle p actual circle p closer equidistant actual circle p closer define decision variable d d d d rule d select p select algorithm data structure global text straight line circle correctly selects pixel closest actual circle exhibit show small pixel grid illustrates various possible way actual circle intersect vertical line x relation pixel p exhibit given octant circle pixel p lit pixel need examined case lie inside inside circle obtain d d d applying rule lead selection p selection correct case p lie outside inside circle obtain d d applying rule lead selection d d selection correct case d equivalent case p lie outside outside circle obtain d d d applying rule lead selection p selection correct let di denote decision variable determines pixel x y drawn step starting x y r obtain di x y x y di di x y x y di iterative computation d previous d let select correct pixel drawn step arithmetic needed evaluate formula minimal addition subtraction left shift multiplication following procedure implement algorithm draw circle center xc yc radius us procedure display point entire circle case x y r draw pixel twice cause problem raster display procedure bresenhamcircle xc yc r integer procedure circlepoints x y integer begin paintpixel xc x yc y paintpixel xc x yc y paintpixel xc x yc y paintpixel xc x yc y paintpixel xc y yc x paintpixel xc y yc x paintpixel xc y yc x paintpixel xc y yc x end book licensed creative common attribution license var x y d integer begin x y r d r x y begin circlepoints x y d d x d d x y y y x x end x y circlepoints x y end algorithm circle exercise programming project implement efficient geometric primitive determines aligned rectangle rectangle side parallel coordinate ax intersect implement geometric primitive function intriangle t triangle p point take triangle t given vertex point p return ternary value p inside t p boundary t p outside function intersection program function segmentintersectstriangle s segment t triangle check segment s triangle t share common point return ternary value yes degenerate list distinct case degeneracy occur code handle bresenham incremental algorithm drawing digitized straight line circle circle x y r x y r given coordinate center radius effective formula deciding question circle intersect line b circle intersect disk c avoid operation possible algorithm data structure global textthis book licensed creative common attribution license iv complexity problem algorithm fundamental issue computation successful search better better algorithm naturally lead question best algorithm unsuccessful search lead ask apprehensively algorithm certain type solve problem question turned difficult fertile historically question existence algorithm came led concept computability decidability question best algorithm led development complexity theory study fundamental issue computation requires mathematical arsenal includes mathematical logic discrete mathematics probability theory certain part analysis particular asymptotics introduce topic example illustrate use mathematical technique algorithm analysis important problem sorting algorithm data structure global textthis book licensed creative common attribution license computability complexity learning objective reduced instruction set computer computable halting problem undecidable algorithm problem matrix multiplication model computation ultimate risc algorithm computability originally intuitive concept remain intuitive long want specific result computed following specific algorithm informal explanation suffices convince requisite background given algorithm computes specified result illustrated informal approach iii change wish desired result computable question arises immediately tool allowed use computable help oracle know answer question attempt prove negative result nonexistence certain algorithm force agree rigorous definition algorithm question computed algorithm studied intensively emil post alan turing alonzo church logician defined various formal model computation production system turing machine recursive function capture intuitive concept computation application precise rule different formal model computation turned equivalent fact greatly strengthens church thesis intuitive concept algorithm formalized correctly mathematical system define standard model computation share trait designed conceptually simple primitive operation chosen weak possible long retain property universal computing system sense simulate computation performed machine usually come surprise novice set primitive universal computing machine simple long machine possess essential ingredient unbounded memory unbounded time simulation powerful computer simple share characteristic straightforward principle involves laborious coding practice explodes space time requirement algorithm data structure global computability complexity computation weakness primitive desirable theoretical point view consequence simple operation integer addition exercise programming model computation used algorithm analysis significantly powerful turing machine respect memory tape array primitive operation deal number arbitrary size model computation called random access machine abbreviated ram ram essentially random access memory abbreviated ram unbounded capacity suggested exhibit memory consists infinite array memory cell addressed cell hold number say integer arbitrary size arrow pointing right suggests exhibit ram unbounded address space unbounded cell size ram arithmetic unit driven program meaning word random memory cell accessed unit time opposed tape memory say access time depends distance crucial assumption ram model arithmetic operation take unit time regardless size number involved assumption unrealistic computation number grow large useful assumption case model responsibility using properly lie user reader flavor model computation define ram architecture similar real computer unrealistically simple ultimate risc risc stand reduced instruction set computer machine type instruction built hardware minimum number instruction computer need universal theory consider computer von neumann type data program stored memory john von neumann let random access memory ram doubly infinite countable infinity memory cell addressed hold integer arbitrary size instruction assume constant hardwired memory cell integer constructed single type instruction subtract test jump abbreviated stj x y z x y z address semantics equivalent stj x y z x x y x goto z x y z refer cell cx cy cz content cx cy treated data integer content cz instruction exhibit book licensed creative common attribution license exhibit stored program computer data instruction share memory risc just type instruction waste space field instruction contains address unbounded integer theory fortunately unbounded integer packed space required single unbounded integer following exercise simple idea lead technique introduced mathematical logic kurt gödel exercise gödel numbering motel infinity countable infinity room numbered room occupied sign claim vacancy convince manager room person b assume memory cell risc store integer sign bit followed sequence d decimal digit significant devise scheme storing address cell c sequence positive integer arbitrary length n encoded single natural number j given j sequence uniquely reconstructed gödel lution basic program fragment computer best understood considering program fragment simple task fragment implement simple operation setting variable given constant assignment operator given primitive programming language programming fragment naturally lead introduce basic concept assembly language particular symbolic relative addressing set content cell stj current content cell subtract obtain integer instruction resides address memory abbreviate read current value program counter address regardless outcome test control flow instruction memory b b symbolic address use temporary variable t stj t t t stj t b t stj stj t b exercise program library write risc program b c b c b div c b mod c min b c gcd b c algorithm data structure global counter executing instruction setscell incrementsthe program computability complexity b risc compute rational number represented pair b integer denoting numerator denominator c advanced risc universal sense simulate computation computer exercise building risc program library elementary function provides experience equivalent exercise turing machine lead goal faster primitive stj powerful primitive turing machine purpose section introduce idea conceptually simple model computation powerful theory complex model programming language section demonstrate result opposite nature universal computer sense just introduced subject striking limitation remove limit memory time use prove existence noncomputable function halting problem undecidable theory computability developed greatly expanded basic idea foundation computer scientist expected know computability theory directly useful based concept computable principle offer concept feasible computation feasibility possible principle touchstone computer science theory complexity computation developed goal partitioning range computability complexity class according time space requirement theory development breaking new ground particular area concurrent computation used concept iii continue illustrate idea simple example surprising result computable consider model computation programming language fictitious feature implemented machine infinite memory operational time limit reach conclusion computable follows simply observation fewer program problem solved function computed number program number function infinite infinity higher cardinality programming language l defined alphabet ak k character set program l subset set string countable subset l correspondence natural number following mapping string order increasing length case equal length lexicographic order string represent program according syntax rule remaining string originally given order program l consider compute partial function set n natural number recognized heading example function f x n n subset l exist countably program uncountably function f n n georg cantor proved famous diagonalization argument start assuming opposite set f f n n countable derives book licensed creative common attribution license contradiction countable number f unction enumerate according following scheme construct function g n n g fi obtained adding diagonal element scheme g different fi argument g f assumption enumerated function f n n wrong exists countable infinity program uncountable infinity function function noncomputable halting problem undecidable predict program p executed data set d p terminates infinite loop interesting useful technique prediction based rule prescribe exactly pair p d tested write program h fundamental result computability theory state reasonable assumption model computation halting program h exist consider programming language l contains construct use mainly recursive procedure procedure parameter consider procedure p l parameter property recognized heading procedure p simplifies problem avoiding data dependency termination assume exists program h l take argument parameterless procedure p l decides p halt loop run indefinitely consider behavior following parameterless procedure x procedure x begin h x end consider reference x trick corresponds diagonalization previous example consider loop h x infinite h x return true exactly x halt terminates h x return false exactly x run forever trick corresponds change diagonal g f obtain algorithm data structure global computability complexity definition x construction x fiendishly crafted program x trap h web contradiction blame weakest link chain reasoning lead contradiction unsupported assumption existence halting program prof halting problem undecidable computable unknown preceding section illustrated limitation computability clearly stated question halting problem undecidable mean halting question answered general computation matter extensive time space course lot individual halting question answered asserting particular program running particular data set terminates fails illuminate key concept theoretical computer science following example highlight different type practical limitation computability computable decidable concept naturally involves algorithm denumerably infinite set problem indexed parameter say uniform procedure solve problem infinite set example question really denumerable infinity question given integer n expressed sum prime decidable exists algorithm answer single instance question procedure n integer boolean n n return true n sum prime false function p k integer integer k p k return prime p p p end begin j p n p j n p p j n return true return false end general question given integer sum prime solved readily simple program single related question harder integer sum prime let try book licensed creative common attribution license bit experimentation suggests number distinct representation sum prime increase target integer grows christian goldbach good fortune stating plausible conjecture yes problem hard defied proof counterexample century ask goldbach conjecture decidable straight answer concept decidability doe apply single question goldbach conjecture asking algorithm tell conjecture true false meaninglessly trivial course algorithm goldbach conjecture true algorithm say decides conjecture false algorithm say job problem know algorithm right quite compatible saying right algorithm package trivial algorithm following trivial algorithm deciding goldbach conjecture function goldbachoracle boolean begin return goldbachisright end notice function argument boolean constant true false occasionally stark triviality argument concealed cleverly technical jargon sound profound watch following plot let integer sum prime counterexample certainly reason exist define function g k cardinal boolean follows goldbach conjecture equivalent g true implausible rival conjecture exactly counterexample equivalent g false g true know value g k single k definition g tell lot artificial function g true g k true k strong monotonicity property g look goldbach right g constant g k true finite number exception g step function g k false k g k true k infinite number exception g constant g k false infinitely function listed obviously computable g computable value g determines truth falsity goldbach conjecture doe help settle mathematical puzzle obviously rephrase honest statement started section answer yes know circuitous answer obtained evaluating computable function know algorithm data structure global computability complexity multiplication complex number let turn attention noncomputable function undecidable problem simple function obviously computable ask complexity primitive operation executed evaluating specific function example consider arithmetic operation real number primitive consider product z complex number x y x y x y z complex product defined term operation real number follows appears complex multiplication requires real multiplication real surprisingly turn multiplication traded addition compute intermediate variable using multiplication obtain z addition subtraction evaluation complex product requires real multiplication real addition subtraction trade multiplication addition look like good deal practice computer arithmetic chip fast multiplication circuitry theory trade clearly favorable cost addition grows linearly num ber digit cost multiplication using standard method grows quadratically key idea algorithm linear combination k product sum generate k product simple term let exploit idea context make real difference complexity matrix multiplication complexity algorithm given time space requirement time usually measured number operation executed space number variable needed time input intermediate result output given algorithm easy count number operation performed worst best case usually difficult determine average number operation performed averaged possible input data practical algorithm time complexity order o log n o o n log n o space complexity order o n n measure size input data complexity problem defined minimal complexity algorithm solve problem difficult determine complexity problem possible algorithm considered including unknown lead surprising result disprove obvious assumption complexity algorithm upper bound complexity problem solved algorithm algorithm witness assertion need operation solve problem specific algorithm provides lower bound complexity extinguish hope efficient algorithm occasionally algorithm designer engage race lasting decade result theoretically faster faster algorithm solving given problem volker strassen started race paper book licensed creative common attribution license gaussian elimination optimal str showed matrix multiplication requires fewer operation commonly assumed necessary race ended obvious way multiply n n matrix us nested loop iterated n time saw transitive hull algorithm chapter matrix graph transitive closure fact obvious algorithm matrix multiplication time complexity θ doe imply matrix multiplication problem complexity strassen matrix multiplication standard algorithm multiplying n n matrix need scalar multiplication n addition case matrix multiplication addition seven scalar multiplication suffice accept evaluate seven expression product sum element product matrix computed follows algorithm doe rely commutativity scalar multiplication generalized n n matrix using principle reason simplicity consider n power n value n imagine padding matrix row column zero power n n matrix partitioned matrix product n n matrix strassen method requires seven multiplication matrix large n work required addition negligible compared work required single multiplication saved multiplication asymptotically cost matrix partitioned recursively matrix log n partitioning step arrive matrix matrix multiplication primitive scalar multiplication let t n denote number scalar arithmetic operation used strassen method multiplying n n matrix n t n obeys recursive equation algorithm data structure global computability complexity interested leading term solution constant justify omitting quadratic term obtaining number primitive operation required multiply n n matrix using strassen method proportional statement abbreviate strassen matrix multiplication take time θ doe asymptotic improvement lead efficient program practice probabl y ratio grows slowly practical importance n example remember factor disdained way win lose factor trading algorithm simple code straightforward matrix multiplication requires elaborate bookkeeping strassen easily result fourfold increase constant factor measure time take execute body innermost loop exercise set ordered pair integer countably infinite recursive function defined finite set rule specify function term variable nonnegative integer constant increment function expression built composition function example consider ackermann function defined n n n ak n determined ak k n n ak n ak k calculate b prove ak k n n n n n n c define inverse ackermann function α n min m m n α n n α n n tower α n n book licensed creative common attribution license strassen algorithm showing multiply n n matrix n exact power multiply matrix using k multiplication largest k lead asymptotic improvement strassen algorithm permutation matrix p n n matrix exactly row column entry permutation matrix represented array var array n integer follows j row p contains column product permutation matrix permutation matrix algorithm multiplies time θ n permutation matrix given array representation store result array representation algorithm data structure global textthis book licensed creative common attribution license mathematics algorithm analysis learning objective average performance algorithm rate function o ω behavior sum technique recurrence relation performance algorithm number inversion average distance permutation property growth rate order magnitude understand specific algorithm useful ask answer following question usually order problem solved main idea algorithm based correct efficient variety problem vast variety main idea lead design algorithm establish correctness true general algorithmic principle schema rarely suffice interesting algorithm typically exploit specific feature problem unified approach understanding logic algorithm remarkably unified approach efficiency analysis algorithm efficiency measured program time storage requirement remarkable great variety set input data environment computer operating system programming language coding technique difference great influence run time storage consumed program type difference overcome follows different set input data average performance important characteristic set data size measured term unit convenient problem hand typically number primitive object data bit byte integer monotonic function thereof magnitude integer example sorting number n element natural square matrix number n row column convenient monotonic function square root actual size data algorithm behave differently different data set equal size possible configuration o f given size n favorable data set size n average data set size n provide important measure efficiency example sorting data set order known average performance characterized averaging run time n permutation n element algorithm data structure global mathematics algorithm analysis different environment focus growth rate ignore constant work performed algorithm expressed function problem size typically measured size n input data focusing growth rate function ignoring specific constant succeed losing lot information change wildly computing environment retaining essential information remarkably invariant moving computation supercomputer machine language pascal amateur professional programmer definition general measure complexity problem efficiency algorithm major achievement computer science based notion asymptotic time space complexity asymptotics renounces exact measurement state work grows problem size increase information suffices distinguish efficient algorithm inefficient one asymptotic behavior algorithm described o ω θ o notation determine work performed algorithm count operation constant time independently n data object require constant storage space time required addition comparison exchange number typically independent number processing storage requirement number assume time required algorithm n n respectively following table show size data set frequently occur practice n difference growth rate translates large numerical difference n specific algorithm function multiplied constant factor proportional time take execute body innermost loop comparing different algorithm solve problem happen innermost loop time faster slower rare difference approach factor n algorithm time complexity θ n log n efficient algorithm time complexity θ small n say n algorithm time complexity θ efficient complexity θ n log n constant time smaller wish predict exactly second byte program need asymptotic analysis useful small work formula track constant factor discarded cavalier fashion o notation assign number time consumed score primitive o operation sufficient estimate time consuming primitive operation necessary include hidden programming language answer question long doe array access j procedure incrementing index loop n asymptotics asymptotics technique used estimate compare growth behavior function consider function book licensed creative common attribution license f x said behave like x x like x x motivation statement x x intuitively simpler easily understood function f x complicated function unlike simpler entire domain usually behaves like simpler x approach particular value asymptotic statement include qualifier x purpose algorithm analysis interested behavior function large value argument definition assume x asymptotic behavior function described o ω θ o notation f x o g x notation assigns given function g set function related g way intuitively o ω θ o used compare growth function used compare number o g set function g precise technical sense corresponds intuitive notion grows faster g definition involves technicality signaled preamble x x say ignore constant factor initial behavior interested function behavior point set nonnegative integer set nonnegative real following definition x stand let g x definition o big oh o g f x x c x x xo f x c g x say f o g f grows fast g x x definition ω omega ω g f x x c x x f x c g x say f o g f grows fast g x x definition θ theta θ g o g ω g say f θ g f growth rate g x x definition o small oh say f o g f grows slower g x x notation th e literature us place x o just remember standard property equality commutative transitive o x used x o o doe follow x key avoiding confusion insight o function set function summation formula denotes logarithm t o base ln natural logarithm base algorithm data structure global mathematics algorithm analysis asymptotic behavior sum derived comparing sum integral evaluated closed form let f x monotonically increasing integrable function bounded sum exhibit exhibit bounding definite integral lower upper sum letting xi inequality x xy ξνthis book licensed creative common attribution license example substituting k obtain example substituting obtain cdotln n withg n logn example substituting obtain g n o n log n recurrence relation homogeneous linear recurrence relation constant coefficient form xn ak coefficient independent n x specified general technique solving linear recurrence relation constant coefficient determining x n function demonstrate technique fibonacci sequence defined recurrence algorithm data structure global mathematics algorithm analysis xn seek solution form xn c rn constant c r determined substituting fibonacci recurrence relation yield c rn c c c r equation satisfied c r r obtain trivial solution x n n c r interestingly r sum solution homogeneous linear recurrence relation obviously solution shown linear combination solution solution general solution fibonacci recurrence form determined solution linear equation derived initial condition yield complete solution fibonacci recurrence relation recurrence relation linear constant coefficient general solution technique comparable discussed general recurrence relation solved solution approximated bounded technique trial error guided general technique yield good estimate asymptotic behavior solution recurrence relation example consider recurrence relation book licensed creative common attribution license b appears analysis algorithm data structure know interpretation recurrence solution monotonically nondecreasing systematic process lead asymptotic behavior solution simplest possible try constant x n substituting lead xn c solution x n smaller average previous value solution recurrence relation grow faster try linear function x n c n stage analysis suffices focus leading term c n left c n right assumption make right larger left conclude linear function grows slowly solution recurrence relation new attempt function grows faster x n c lead comparing leading term side left larger right conclude quadratic function grows fast having bounded growth rate solution try function growth rate lie linear quadratic function x n c sophisticated approach considers family function form x n c ε grow fast suggests xn c n n give g n o n log n h n o log n match linear term choose c c ln know solution recurrence relation form algorithm data structure global mathematics algorithm analysis asymptotic performance algorithm illustrate power technique developed previous section analyzing asymptotic performance specific algorithm entire class algorithm divide conquer recursion presented following schema algorithm partition set data part d simple d thenreturn d divide partition d conquer combine return merge r assume data set d partitioned half d level recursion comment appropriate repeated halving possible necessary size n data set d power n important d partitioned exact half imagine padding data set d size power dummy element power dummy disturb real computation example replicating element appending sentinel padding usually just conceptual trick help understanding process need necessarily generate additional data divide step guaranteed partition d approximate half hand depends critically problem data structure used example binary search ordered array partition d half probing element midpoint idea impractical linked list midpoint directly accessible assumption halving time complexity t n algorithm applied data d size n satisfies recurrence relation f n sum partitioning splitting time stitching time required merge solution size n solution size repeated substitution yield term n t express fact data item get looked second sum splitting stitching time typical case occur constant time splitting merging f n c yield book licensed creative common attribution license t n t c example maximum n number b linear time splitting merging f n n b yield t n n n t b example mergesort quicksort c expensive splitting merging n o f n yield t n n t o f n log n rarely lead interesting algorithm permutation inversion let ak k n permutation integer pair aj j n called inversion iff ai aj average number inversion permutation consider permutation pair permutation xn consider inverse contains element inverse order xn permutation x xj correct order form inversion n pair element x xj j n average inversion average distance let ak k n permutation natural number distance element correct position total distance ll element correct position average total distance average n permutation algorithm data structure global mathematics algorithm analysis let n j consider permutation equal n permutation obtain average distance element correct position tree tree ubiquitous disc rete mathematics computer science section summarizes basic concept terminology result tree come different version context algorithm data structure tree mean ordered rooted tree ordered rooted tree consists node called root sequence k ordered subtrees tk exhibit node ordered tree subtrees called leaf external node node called internal node exhibit root subtrees attached node child node parent book licensed creative common attribution license exhibit recursive definition rooted ordered tree level node defined recursively root tree level child node level t level t level node length path root tree node height tree defined maximum level leaf path length tree sum level node exhibit exhibit tree height path length binary tree ordered tree node child binary tree tree node zero child tree n leaf exactly n internal node binary tree height h called complete completely balanced node exhibit binary tree height h called complete leaf level h h leaf level h far left possible exhibit algorithm data structure global text mathematics algorithm analysis exhibit example binary tree exercise comparing implementation algorithm machine input size n algorithm run step second algorithm run n n step assuming step algorithm time value n doe algorithm beat second algorithm smallest value n algorithm running time run faster algorithm running time machine following function f n determine function g n f n θ g n function g n simple possible n n n n log n log n n n n log n log n n n log n log n formally n n θ asymptotically tight bound follo wing summation general solution following recurrence relation recurrence t hint make change variable m log number inversion total distance permutation book licensed creative common attribution license sorting complexity learning objective sorting idea intrinsic complexity sort sort sort sort lower bound ω log n linear time network sorting difficult problem assume s set n element x xn drawn domain x total order defined relation satisfies following axiom reflexive x x x antisymmetric y x x y y x x y transitive y z x x y y z x z total y x x y y x sorting process generating sequence permutation integer n hold phrased abstractly sorting problem finding specific permutation permutation distinct element equal value n possible permutation n given element usually set s element sorted given data structure case element s ordered implicitly data structure necessarily according desired order typical sorting problem assume s given array sequential file magnetic tape result generated structure characterize element position structure array algorithm data structure global sorting complexity value pointer sequential file access operation provided underlying data structure determine sorting algorithm possible algorithm sorting algorithm refinement following idea j j j j denotes exchange operator sorting algorithm explicitly exchange pair element use array underlying data structure usually thought conforming schema insertion sort example take element time insert proper place sorted correct place insertion think ripple effect new element successively displaces exchange position larger schema show type operation needed order sort information order given element element exchanging pair designing efficient algorithm seek economize number operation type try avoid collecting redundant information hope element time possible nondeterministic algorithm given let perform number exchange given time regardless usefulness example sorting sequence nondeterministic algorithm permit seven exchange xi xj j reached state shown following exotic sorting technique sort middle end know time single exchange x complete sort nondeterministic algorithm give handle express use knowledge attempt economize work force depart nondeterminacy impose control structure carefully sequence operation performed make maximal use information g ained far resulting algorithm complex difficult understand useful remember sorting basically simple problem simple solution acrobatics chapter quest efficiency intrinsic complexity obvious limit economize absence previously acquired information clear element inspected general moved hope away fewer ω n primitive operation obvious limit mention information collected asking binary question question receive answer question comparison element yield n n question necessary general proved section lower bound ωn logn model computation sorting requires time θ n log n addition collecting information rearrange element section permutation chapter shown permutation average distance element correct book licensed creative common attribution license position approximately element average distance approximately element end destination depending access operation underlying storage structure element moved correct position single step average length step average length element rearranged exchanging adjacent element average θ moving operation required short step insufficient obtain efficient θ n log n sorting algorithm practical aspect sorting record instead element discus sorting assuming element sorted drawn totally ordered domain practice element just key record contain additional data associated key example type recordtype record key keytype totally ordered data anytype end use relational operator compare key given programming language say pascal undefined value type keytype general replaced procedure example comparing string respect lexicographic order key field small large record exchange operation interpreted literally unnecessarily costly copy operation avoided leaving record just data field place moving small surrogate record consisting key pointer associated record sort generator system particularly world commercial data processing need write sorting program sorting frequently executed operation sorting taken care sort generator program akin compiler selects suitable sorting algorithm repertoire tailor problem hand depending parameter number element sorted resource available key type length record partially sorted sequence algorithm discus ignore order exist sequence sorted application sorting file sorted example case sorted master file updated unsorted transaction file algorithm advantage order present input data time complexity varies o n sorted file o n log n randomly ordered file type sorting algorithm important class e incremental sorting algorithm create order processing element turn placing correct position class insertion sort selection sort best understood maintaining disjoint mutually exhaustive structure called initialize ø xn loop n element correct place following illustration sharing array n case boundary represented index increase element ordered important distinction type sorting algorithm emerges question algorithm data structure global sorting complexity structure work insertion sort remove easily accessible element search proper place selection sort search element appended insertion sort step insert element sorted sequence element exhibit exhibit insertion sort easily accessed element correct place selection sort step selects smallest n element sorted move position exhibit exhibit selection sort search correct element easily accessed place insertion selection sort repeatedly search large entire data proper place insertion proper element moved efficient search requires random access sorting technique used primarily internal sorting central memory merge sort merge sort process sub sequence element unidirectional order suited external sorting secondary storage medium provide sequential access magnetic tape random access large block data disk merge sort efficient internal sorting basic idea merge sorted sequence element called run longer sorted sequence read input run write output run starting small element ending large one comparing smallest remaining element input run append smaller output run input run exhausted exhibit book licensed creative common attribution license exhibit merge sort exploit order present processor shown left exhibit read tape tape contains run tape b contains run processor merges run single run tape c run single run tape second merge step processor shown right read tape c d merges run run exhibit merge step sequence distribution sort distribution sort process representation element value radix number use primitive arithmetic operation extract digit sort compare element directly introduce different model computation sort based comparison exchange insertion deletion considered far example consider number digit radix representation step number distributed queue according significant digit queue concatenated increasing order process repeated middle digit finally leftmost significant digit shown exhibit algorithm data structure global text sorting complexity exhibit distribution sort use radix representation key organize element bucket seen basic idea sorting algorithm built important understand idea know dozen algorithm based appreciate intricacy sorting understand algorithm begin simple one turn inefficient simple sorting algorithm work time θ invent sorting technique prior study literature probably discover inefficient algorithm work time o requires time θ worst case time complexity ω algorithm similar described consider algorithm work array declared var array n elt place element ascending order assume comparison operator defined value type elt let cbest caverage cworst denote number comparison e best eaverage eworst number exchange operation performed best average worst case respectively let inv average denote average number inversion permutation insertion sort exhibit let denote constant key value smallest value domain serf sentinel book licensed creative common attribution license exhibit straight insertion propagates sorted array n begin j j j j j exchange j j end straight insertion sort θ n algorithm best case θ algorithm average worst case program point insertion linear search interleaved exchange binary search possible doe improve time complexity average worst case actual insertion requires ripple ex change selection sort exhibit exhibit straight selection scan unsorted array n begin minindex minkey j n j minkey minkey j minindex j minindex exchange end algorithm data structure global text sorting complexity sum formula number comparison reflects structure nested loop body inner loop executed number time case straight selection sort time complexity θ lower bound ω n log n straightforward counting argument yield lower bound time complexity sorting algorithm collect information ordering element asking binary question binary question answer yes true false comparison element x y obvious example following theorem hold binary question general theorem sorting algorithm collect information asking binary question executes binary question worst case averaged n permutation average time complexity algorithm ω n log n proof sorting algorithm type considered represented binary decision tree internal node tree represents binary question leaf corresponds result decision process decision tree distinguish n possible permutation input data n leaf permutation example decision tree shown exhibit collect information necessary sort element x y z comparison element exhibit decision tree show possible n outcome sorting n element book licensed creative common attribution license average number binary question needed sorting algorithm equal average depth leaf decision tree lemma following theorem binary tree k leaf average depth leaf log average depth leaf corresponding n permutation log follows average binary question needed time complexity sorting algorithm ω n log n average worst case lemma binary tree k le aves average depth leaf log proof suppose lemma true let t counterexample smallest number node t consist single node lemma true tree root r t child subtree t rooted child contain k leaf t smaller average depth t t counterexample smallest number node t exist root r t child k l leaf left subtree k r leaf right subtree r kl kr k t chosen minimal k l leaf left subtree average depth kl kr leaf right subtree average depth log kr average depth k leaf t easy assumes minimum value k l kr value k kl kr k contradiction assumption lemma false quicksort quicksort hoare hoa combine powerful algorithmic principle conquer efficient way moving element using exchange divide phase partition array disjoint part small element left large element right conquer phase sort separately thanks work divide phase merge phase requires work combine partial solution quicksort efficiency depends crucially expectation divide phase cut sizable subarrays merely slicing element end array exhibit algorithm data structure global sorting complexity exhibit quicksort partition array small element left large element right chose arbitrary threshold value m define small m large m ensuring small element large element partition arbitrary subarray l r sorted executing scan incrementing index concurrently scan decrementing j exhibit scan pause element m scan pause element j scan paused exchange j resume scan partition complete scan crossed j quicksort called recursively l j r unless subarrays consists single element trivially sorted example partitioning m j j ij j exhibit scanning array concurrently left right right left thresho ld value m appeared arbitrary description meet criterion correctness efficiency correctness set element m set element m quicksort fails terminate require min x m max xi efficiency requires m close median median n element obvious answer sort element pick middle lead problem trying sort place exist sophisticated algorithm determine exact median n element time o n worst case bfprt multiplicative constant large theoretical point view doe matter element partitioned half quicksort run time o n log n worst case practical point view worthwhile spend effort finding exact median cheaper way finding acceptable approximation following technique used pick threshold m guess median array element fixed position l r div warning stay away end l r threshold lead poor performance element partially sorted array element random position simple technique yield good result median array element fixed random position book licensed creative common attribution license average smallest largest element requires separate scan entire array beginning average subarray calculated previous partitioning process recursive procedure possible implementation quicksort function yield threshold lie smallest largest element sorted array element used threshold procedure changed way finishing partitioning process element final position left right part array procedure rqs l r n sort l r var j n procedure partition var m elt begin partition m guessmedian l r min l r m max l r l j r repeat l m j r m l m m j j j j m j r j begin j exchange j m j j j l m j r end j j exit end j end partition begin rqs partition l j rqs l j r rqs r end rqs initial n n guarantee l r hold recursive iterative implementation quicksort given following procedure sort array n boundary subarrays sorted maintained stack procedure iq const stacklength type stackelement record l r n end vari j l r s n stack array stacklength stackelement procedure partition rqs end partition begin iq s stack stack n repeat l stack s r stack s s s algorithm data structure global sorting complexity repeat partition j l r begin r s s stack s stack s r r j end begin l j s s stack s l stack s j l end l r s end iq partitioning push bound larger stack making sure sorted later sort smaller length stack bounded log small array overhead managing stack make quicksort efficient simpler o algorithm insertion sort practically efficient implementation quicksort switch sorting technique subarrays size sed comprehensive discussion optimize quicksort analysis case best typical worst consider quicksort algorithm chooses guessed median differs element sorted partition array part k element n k element work q n required sort n element satisfies recurrence relation constant b measure cost calling quicksort array sorted term n cover cost partitioning term q k q n k correspond work involved quicksorting subarrays quicksort algorithm partition array part small left single array element used guess median large right work expressed equation analyze equation close second equation asymptotic solution quicksort behavior best worst case easy analyze average permutation analyze average typical case quicksort behavior obtained guess correct median partition array subarrays simplicity sake following calculation assumes n power assumption doe affect solution rewritten use recurrence equation calculate book licensed creative common attribution license substitute obtain repeated substitution yield constant q whic h measure quicksort work trivially sorted array length b cost single procedure affect dominant term n log constant factor dominant term estimated analyzing code procedure detail matter summarize quicksort time complexity best case θ n log n quicksort behavior occurs subarrays consists single element partitioning case equation use recurrence equation calculate substitute obtain repeated substitution yield time com plexity quicksort worst case θ analysis quicksort typical behavior make plausible assumption array equally likely partitioned element k k n probability array partitioned subarrays k k n n average work performed quicksort expressed recurrence relation algorithm data structure global sorting complexity recurrence relation approximates recurrence relation discussed chapter solution ln quicksort asymptotic behavior typical case worse best case remains θ n log n sed thorough analysis quicksort merging merge sort internal sorting algorithm presented far require direct access element reflected analysis treating array access exchange j primitive operation cost constant independent n assumption valid element stored secondary storage device magnetic tape disk better assumption mirror reality external sorting element sorted stored sequential file file accessed file pointer given time provides direct access single element accessing element requires repositioning file pointer sequential file permit pointer advance direction case pascal file backward forward case theoretical model assumes time required repositioning pointer proportional distance traveled assumption obviously favor algorithm process compare exchange pair adjacent element penalizes algorithm quicksort access element random position following external sorting algorithm based merge sort principle make optimal use available main memory algorithm creates init ial run run sorted subsequence element f fj stored consecutively file f f k k k j assume buffer capacity m element available main memory create initial run length m run processing run r read m element f memory sort internally write sorted sequence modified file f reside physical storage area original file new file f partially sorted run f k k r m k r m point need file g h addition file f contai n initial run copy phase distribute initial run copying half g half subsequent merge phase run g merged exactly run h resulting new run double length written f exhibit cycle consisting copy phase followed merge phase f contains half run did n m cycle f contains single run sorted sequence element book licensed creative common attribution license exhibit cycle half number run double length exercise merge sort main memory consider following procedure sort array const n var array n integer procedure sort l r n var m n procedure combine varb array n integer j k n begin combine l j m k l r m cor j r cand j b k j j j b k k l r k b k end combine begin sort l r m l r div sort l m sort m r combine end sort relational operator conditional procedure initially called sort n draw picture work array element b write recurrence relation work sorting n element c determine asymptotic time complexity solving recurrence relation d assume called m subarrays equal size just doe asymptotic time complexity change solution depends algorithmic principle divide conquer dividing array left right subarray number element differ call recursively subarrays call finished procedure merges sorted subarrays l m m r finally b copied example shown exhibit algorithm data structure global text sorting complexity exhibit sorting array using scheme b work w n performed sorting n element satisfies term describes cost recursive call term n cost merging sorted subarrays constant b cost calling array c substituted obtain continuing substitution process result book licensed creative common attribution license w constant time complexity θ n log n d called recursively m subarrays equal size cost w n solving recursive equation show time complexity doe change θ n log n possible sort linear time lower bound ω n log n derived sorting algorithm gather information ordering element binary question lower bound need apply situation example sorting permutation integer n know element sorted permutation integer n possible sort time θ n storing element array element index example sorting element finite domain assume element sorted sample finite domain w possible sort time θ n gap element allowed exhibit gap closed time θ w exhibit sorting element finite domain linear time example contradict lower bound ω n log n example information ordering element obtained asking question powerful binary question valued question example question example question equivalent log binary question exchange rate taken consideration theoretical time complexity sorting technique θ n log n θ n log w respectively conforming lower bound section lower bound ω n log n sorting algorithm sort linear time expected linear time worst case described literature term bucket sort distribution sort radix sort sorting network sorting algorithm designed run sequential machine operation comparison exchange performed time single processor algorithm efficient need rethought ground rule execution change theoretician us model computation executed computer different architecture particularly true different type multiprocessor architecture built conceived processor available share workload question distribute work synchronize operation transport data prevail intention discus sorting purpose parallel machine wish illustrate point algorithm redesigned model algorithm data structure global text sorting complexity computation change purpose discussion sorting network suffices processor sorting network merely comparators function compare value input wire switch output wire smaller larger exhibit exhibit building block sorting network comparators arranged network n wire enter left n wire exit right exhibit show vertical connection joining pair wire represents comparator illustration show happens input element chosen example travel left right network exhibit comparator network fails sort output comparator performing exchange shown oval network comparators sorting network sort input configuration consider input configuration consist distinct element loss generality regard n permutation sequence n network sort configuration sort configuration containing duplicate comparator network correctly sort input configuration fails sequence sorting network evident network sufficient number comparators right place sort correctly example show immediately evident number suffices comparators placed network exhibit show comparators arranged judiciously suffice sort element exhibit comparators suffice sort element tell given n etwork sort successfully exhaustive testing feasible small network trace flow input configuration network regular structure book licensed creative common attribution license usually admit simpler correctness proof example observe c place smallest element wire similarly c place largest wire leaf middle element middle wire c put place design principle lead create large sorting network guaranteed correct sorting algorithm designed sequential machine general mapped directly network notation network restricted model computation sequential sorting algorithm make comparison based outcome previous comparison sorting netw ork make comparison input configuration fundamental algorithm design principle useful designing sequential algorithm apply parallel algorithm place sorting network n wire combine sorting network n wire appending merge network merge output sequential computation merging simple choose useful comparison depending outcome previous comparison rigid structure comparator network make merging network harder design incremental algorithm place wire sorting network n wire precede follow network ladder comparators tie extra wire existing network shown following figure lead design mirror straight insertion selection algorithm section simple sorting algorithm work time θ insertion sort n element sorted element wire trickle correct place induction yield expanded diagram right exhibit exhibit insertion sort lead induction sorting network right selection sort maximum element trickle remaining element sorted expanded diagram right exhibit exhibit selection sort lead induction sorting network right comparators shifted pair wire reduce number stage provided topology network remains unchanged compression reduces insertion selection sort triangular network shown exhibit distinction insertion selection distinction sequential order operation data flow algorithm data structure global text sorting complexity exhibit shifting comparators reduces number stage number comparators aligned vertically require single unit time compressed triangular network o comparators time complexity n o n network better asymptotic behavior exotic k nu exercise programming project insertion sort selection sort merge sort quicksort animate sorting process algorithm example shown snapshot algorithm animation compare number comparison exchange operation needed algorithm different input configuration smallest possible depth leaf decision tree sorting algorithm n comparison necessary worst case merge sorted array containing n element obvious method systematically interchanging pair element array var array n elt scan adjacent pair element imagine array drawn vertically n repeatedly interchanging order n j n downto j j j j technique known bubble sort smaller element bubble explain word figure example bubble sort work algorithm sort correctly b determine exact number comparison exchange operation performed bubble sort best average worst case c time complexity algorithm sorting algorithm called stable preserve original order equal element sorting algorithm discussed chapter stable quicksort cho os threshold m element sequence sorted running time quicksort algorithm θ input array sorted nonincreasing nondecreasing order input configuration quicksort algorithm chooses threshold m median middle element sequence sorted contains m array b contains n different integer necessarily ordered constm length array n length array b vara array m integer b array n integer book licensed creative common attribution license duplicate integer contained problem duplicate b determine time complexity algorithm compare integer contained array integer array b write efficient function duplicate integer solution rearrange integer array c time complexity improved algorithm algorithm data structure global textthis book licensed creative common attribution license v data structure tool bookkeeping thinking algorithm emphasize dynamic sequence action human experience usually straightforward operation mean work programming hand lot interesting example complex incrementing counter setting bit trigger long sophisticated search need fancy data structure ca just spread data desk everyday experience doe prepare appreciate importance data take programming experience algorithm data structure algorithm presented far carefully chosen require simplest data structure static array geometric algorithm vi hand lot useful algorithm depend sophisticated data structure efficiency key insight understanding data structure recognition algorithm execution time state chosen potentially huge state space state record vital information step taken result remains data structure bookkeeper record state information tidy manner accessed updated efficiently remarkable fact relatively small number standard data structure turn useful varied type algorithm problem constitute essential knowledge programmer literature data structure present algorithm emphasizing data structure did iii appears pointless discus data structure typical algorithm use access update algorithm form necessary data structure accordingly new data structure typically published context particular new algorithm later notice general applicability way textbook data structure standard today book ahu clr gb h knu knu meh meh rnd sam sam tar wir algorithm data structure global textthis book licensed creative common attribution license data structure learning objective structure manual use card data structure data type specify functional property structure include access maintenance algorithm implementation criterion measure data structure old new discipline data structure systematic body knowledge truly creation computer science question best organize data lot simpler answer day existence computer organization simple automatic device processed elaborate data structure human patience consider example file catalog used business office library exhibit distinct organizing principle sequential hierarchical order today point view manual file data structure good reason people did rigorously define aspect consider essential characterizing data structure constraint imposed data structure content operation data structure support constraint operation satisfy consequence searching updating manual file typically process automated requires common sense expert training case library catalog manual computing pencil paper nonprogrammable calculator algorithm focus attention data structure frequently person computing writes data input intermediate result output convenient place field vision hoping need occasionally facilitate highly repetitive computation income tax declaration design form prompt user operation time write data item specific field form specifies algorithm data structure considerable formality compared data structure study chapter form highly special purpose card sophisticated data structure designed manual use let illustrate example database english word organized help solving crossword puzzle write word card index according vowel contains one doe contain row card punch hole labeled e o u word say abaca exhibit given vowel cut notch hole doe e cut notch hole pronounced e exhibit show encoding word beautiful exeter omaha omega example search word contain e u sticking algorithm data structure global data structure needle pack card hole e exeter omega drop principle easy make sample database powerful including additional attribute occurs exactly occurs exactly twice occurs letter word practice dozen attribute thousand card stretch mechanical implementation multikey data structure limit feasibility exhibit encoding different word card contrast data structure suitable manual processing developed automatic data processing complex complexity goal course unavoidable consequence search efficiency efficiency measured processing time memory space required primary concern discipline data structure criterion simplicity code play role question asked evaluating data structure support specified set operation typically time space doe require contrast typical situation manual computing consideration algorithm come data get organized needed programmed computing typically proceeds opposite direction define organization data rigorously structure algorithm follows algorithm design driven data structure design range data structure studied present generally useful data structure corresponding query update maintenance algorithm develop concept technique designed organize vast body knowledge coherent let elaborate goal generally useful refers data structure occur naturally application relatively simple point view operation support queue various type typical example basic data structure building block application programmer construct elaborate structure tailored particular application collection specific data structure small cover great majority technique application programmer likely need develop unified scheme understanding data structure special case general concept includes book licensed creative common attribution license separation abstract data type specify functional property data structure involve aspect implementation classification data structure major type implicit data structure list address computation rough assessment performance data structure based asymptotic analysis time memory requirement simplest common assumption element stored data structure belong domain total order defined example integer ordered magnitude character set alphabetic order character string bounded length ordered lexicographically assume element domain requires storage element domain word data structure manages memory fragment fixed size data object greatly variable size length fragment text typically considered element instead broken constituent piece fixed size element data structure element stored data structure processed according order defined domain topic sorting surveyed sorting complexity closely related study data structure sorting algorithm appear free list structure structure implement abstract data type dictionary lead sorting algorithm successive insertion element followed traversal performance criterion measure design data structure dominated consideration efficiency specifically respect time memory efficiency multifaceted quality easily defined measured scientific discipline study data structure directly concerned number microsecond machine cycle byte required specific program processing given set data particular concerned general statement expert practitioner predict concrete outcome specific processing task measuring run time memory usage typical way evaluate data structure need concept notation expressing performance algorithm independently machine speed memory size programming language operating host detail vary run run solution problem emerged past decade discipline computational complexity developed theory algorithm executed mathematical machine carefully designed simple possible reflect bare essential problem machine make available certain primitive operation measure time counting executed given algorithm data set accepts input analyze number primitive operation executed function size data interested worst case data set given size cause algorithm run long possible average case run time averaged data set given size different mathematical machine defined theory computation data structure evaluated exclusively respect theoretical random access machine ram ram essentially memory location needed hold data element integer real number processing unit read location operate content write result location time unit model close actual sequential algorithm data structure global data structure computer incorporates bound memory term number location size content location implies example multiplication large number requires time doe assumption unrealistic certain problem excellent program run fit central memory require arithmetic length data element point programmer understand model assumption bear responsibility applying judiciously model time memory requirement expressed function input data size comparing performance data structure reduced comparing function asymptotics proven just right tool comparison sharp distinguish different growth rate blunt ignore constant factor differ machine machine example concise description possible asymptotic operation count following table evaluates implementation abstract data type operation respect order exhibit different asymptotic time requirement different implementation student able explain derive table studying book ordered array linear list balanced tree hash table o log n o n o log n o o o o log n o n insert o n o n o log n o delete o n o n o log n o b average necessarily worst case b deletion possible degrade performance exercise manual data structure developed organize library catalog allow user access literature field circulation record track borrowed book example query answered data structure book licensed creative common attribution license abstract data type learning objective abstraction data type tool functional behavior data structure abstract data type stack fifo queue priority queue dictionary string concept data structure organizes data processed way relation data element reflected operation performed data supported goal achieved efficiently central issue data structure major concern book chapter ask particular ask exact functional behavior data structure exhibit called stack queue dictionary table reason seeking formal functional specification common data structure primary motivation increased generality abstraction specifically separate behavior implementation implementation changed affecting program us particular data type goal led earlier introduction concept type programming language type real implemented differently different machine usually program using real doe require modification run machine secondary motivation ability prove general theorem data structure exhibit certain property avoiding need verify theorem instance goal akin sparked development algebra axiom define field prove theorem hold equally true real complex number quaternion primary motivation explained calling analogy data program programming language support concept procedural abstraction operation algorithm isolated procedure making easy replace change affecting part program program part know certain operation realized know corresponding procedure effect procedure modern programming language increasingly support analogous concept data abstraction data encapsulation organization data encapsulated module package possible change data structure having change program secondary motivation formal specification data type remains unrealized goal abstract data type active topic theoretical research difficult today make case theorem use programmer proved abstract data type consists domain data element drawn set operation specification abstract data type identify domain define operation identifying describing domain generally straightforward definition operation consists syntactic semantic syntactic corresponds procedure heading specifies operation algorithm data structure global abstract data type type operand present syntax operation mathematical function notation specifying domain range semantic attache meaning operation value produce effect environment specify semantics abstract data type algebraically axiom property deduced formal approach advantage operation defined rigorously domain required property formal description doe appeal intuition force specify detail prefer ignore matter hand formal specification superior precise specification natural language tends cumbersome difficult understand take word avoid ambiguity chapter consider abstract data type stack queue priority queue dictionary data type ideal unbounded version version reflect reality finite machine theoretical point view need ideal data type practical point view doe tell story order capture different property programmer intuitively associate vague concept stack example forced specifying different type stack addition ideal unbounded stack specify stack mirror behavior array implementation stack mirror behavior list implementation similar distinction apply data type specify unbounded version let x denote domain data element drawn stack fifo queue make assumption x priority queue dictionary require total order defined let set finite sequence stack stack called queue lifo queue brief informal description abstract data type stack specifically unbounded stack contrast version introduced later merely state following operation defined new stack true stack new element element recently inserted stack element recently inserted stack exhibit help clarify meaning word exhibit element inserted removed stack definition us conventional mathematical notation capture intention description define operation explicitly showing effect content stack let s set book licensed creative common attribution license possible state stack let s xk s arbitrary stack state k element let λ denote state stack corresponding null string x let denote string concatenation define function create s s true false push s x s s λ x pop s λ s follows s y x create λ λ true s λ s false push s y s cat y x xk y s λ s xk s pop s definition refers explicitly content stack prefer hide content refer operation result led style formal definition abstract data type express semantics operation relating explicitly listed content data structure commonly used approach define abstract data type follow rest chapter let s set s distinguished state s denotes stack s set stack state obtained stack performing finite sequence operation following function represent stack operation create s s true false push s x s s x pop s s semantics stack operation specified following axiom s x create true push s x false push s x x pop push s x s axiom described natural language follows produce stack distinguished state distinguished state stack element inserted element recently inserted stack inverse notice play different role stack operation merely mechanism causing stack come existence omitted postulating existence stack st ate implementation code corresponds technical note identify algorithm data structure global abstract data type choose make distinction act creating new stack state result creation recur normal operation stack reduced sequence s s obtained stac k performing finite sequence operation axiom sequence reduced sequence transforms s s consists operation example push pop push push s x y z push push x z x implementation stack provide following procedure procedure create var s stack function s stack boolean procedure push var s stack x elt function s stack elt procedure pop var s stack program us data type restricted calling procedure creating operating stack allowed use information underlying implementation procedure called constraint specification example called stack s pop s specification assumes stack grow bound defines abstract data type called unbounded stack implementation imposes bound size depth stack size underlying array array imple reflect limitation following stack describes implementation array fixed size m limit maximal stack depth stack create s s true false s true false push s s s x s s x pop s s specify behavior function need internal function depth s m measure stack depth number element currently stack function interacts function following axiom specify stack semantics s x create s true s push s x false depth book licensed creative common attribution license s depth pop s depth s s depth push s x depth s s depth s m s push s x x pop push s x s stack stack implemented list overflow unpredictable moment depending content entire memory just stack specify behavior postulating function domain act oracle chooses value independently state stack gave domain set state entire memory create s s true false true false push s x s s x pop s s s x create true push s x false push s x x pop push s x s implementation seen abstract data type capture intuitive vague concept stack single model rigor enforced formal definition make aware different type stack different behavior quite apart issue domain type x specifies type element stored clarity advantage attempt process abstract data type automatically disadvantage human communication rigorous definition force specify detail different type stack introduced directly related different style implementation stack example describes following implementation const m maximum length stack typeelt stack array m elt d m current depth stack end procedure create var s stack begin end function s stack boolean begin return end function s stack boolean begin return m end procedure push var s stack x elt called stack begin x end algorithm data structure global abstract data type function s stack elt called stack begin return end procedure pop var s stack called stack begin end function exported available user data type need provided procedure instead implemented variable d serf stack pointer implementation assumes user check stack calling calling course write procedure protect illegal call stack simply returning error message calling program requires adding argument procedure lead type stack formally different abstract data type one discussed queue following operation exhibit defined abstract data type fifo queue queue return true queue enqueue insert new element tail end queue return element queue dequeue remove element exhibit element inserted tail removed head fifo queue let f set queue state obtained queue performing finite sequence operation f f denotes queue following function represent fifo queue operation create f f true false enqueue f x f f x dequeue f f semantics fifo queue operation specified following axiom f x create true enqueue f x false enqueue f x x f enqueue f x f dequeue enqueue f x f dequeue enqueue f x enqueue dequeue f x book licensed creative common attribution license f f obtained fifo queue f performing finite sequence operation axiom sequence reduced sequence consisting operation transforms f example enqueue dequeue enqueue enqueue f x y z enqueue enqueue dequeue enqueue f x y z enqueue enqueue f y z dequeue enqueue f y z z implementation fifo queue provide following procedure procedure create var f fifoqueue function f fifoqueue boolean procedure enqueue var f fifoqueue x elt function f fifoqueue elt procedure dequeue var f fifoqueue priority queue priority queue order element according value arrival time assume total order defined domain following example x set integer small integer mean high priority following operation exhibit defined abstract data type priority queue true queue new element queue element highest priority contained queue element highest priority queue exhibit element priority determines position priority queue let p set priority queue state obtained queue performing finite sequence operation priority queue denoted p following function represent priority queue operation create p p true false insert p x p min p x delete p p semantics priority queue operation specified following axiom x y x function min x y return smaller value algorithm data structure global text abstract data type p x create true insert p x false min insert x x p min insert p x min x min p delete insert p x p delete insert p x p p obtained queue p finite sequence operation axiom sequence reduced shorter transforms p p consists operation example assume x z y insert delete insert insert p x z y insert insert delete insert p x z y insert insert p z y z implementation priority queue provide following procedure procedure create var p priorityqueue function p priorityqueue boolean procedure insert var p priorityqueue x elt function min p priorityqueue elt procedure delete var p priorityqueue dictionary stack fifo queue designed retrieve process element depending order arrival dictionary table designed process element exclusively value priority queue hybrid insertion according value dictionary deletion according position fifo queue simplest type dictionary support following operation true given element contained dictionary new element dictionary given element dictionary let d set dictionary state obtained dictionary performing finite sequence ete operation d denotes dictionary operation represented function follows create d insert d x d member d x true false delete d x d semantics dictionary operation specified following axiom book licensed creative common attribution license d y x create member x false member insert d x x true x y member insert d y x member d x delete x delete insert d x x delete d x x y delete insert d x y insert delete d y x d d obtained dictionary d finite sequence operation axiom sequence reduced shorter transforms d d consists operation example insert insert insert x y z y delete insert insert x y y z delete insert x y z insert delete y x z insert x z specification allows duplicate inserted axiom guarantee duplicate removed delete operation performed prevent duplicate following axiom added specification member d x insert d x d case axiom weakened member d x delete insert d x x d implementation dictionary provide following procedure procedure create var d dictionary function member d dictionary x elt boolean procedure insert var d dictionary x elt procedure delete var d dictionary x elt actual programming practice dictionary usually support additional operation similar addition answer provides pointer element pointer element e argument return pointer element dictionary immediately precedes follows e according order repeated process dictionary sequential order exercise extending abstract data type defined dictionary supporting operation dictionary table usually support additional operation based total ordering defined domain let add operation argument x x deliver neighboring element table succ x return successor x table pred x return predecessor x table algorithm data structure global abstract data type successor x defined smallest element table larger x exists predecessor defined symmetrically largest element table smaller x present formal specification behavior table solution let t set state table special state denotes table function axiom follows member t x true false insert t x t delete t x t succ t x x pred t x x t y x member x false member insert t x x true x y member insert t y x member t x delete x delete insert t x x delete t x x y delete insert t x y insert delete t y x x pred t x x succ t x succ t x member t succ t x true pred t x member t pred t x true x y member t y y succ t x succ t x y x y member t y y pred t x y pred t x exercise abstract data type define following operation abstract data type string true string new element tail string head element string head element given string length string index occurrence value string let x b z s set string state obtained string performing finite number operation s s denotes string operation represented function follows s true false append s x s head s x tail s s length s s x example false append head book licensed creative common attribution license tail length b axiom specify semantics abstract data type b function hchop s x s return substring string s beginning occurrence given value similarly tchop s x s return substring s beginning head s ending occurrence given value specify behavior operation additional axiom example hchop c tchop b c function cat s s s return concatenation sequence specify behavior additional axiom example cat d function reverse s s return given sequence reverse order specify behavior reverse additional axiom example reverse solution axiom operation s x y x true append s x false head append x x s head s head append s x tail append x s tail append s x append tail s x length length append s x length s x x y s x append s y x s x append s x x length s s x d append s y x d b axiom s y x hchop x s head s x hchop s x s s head s x hchop s x hchop tail s x tchop x tchop append s x x append s x x y tchop append s y x tchop s x c axiom s s cat s s s cat s s cat append s head s tail s d axiom s algorithm data structure global abstract data type reverse s reverse s append reverse tail s head s exercise stack ν onε array m way stack overflow unless total number element stack operation run o time queue deque grow shrink end left right using procedure present formal specification behavior abstract data type deque abstract data type priority queue operation x return element priority queue having lower priority x book licensed creative common attribution license implicit data structure learning objective data structure relationship data element implicitly formula declaration storage matrix matrix eliminate temporary speed difference interacting producer consumer process queue implemented circular buffer queue implemented heap implicit data structure important aspect art data structure design efficient representation structural relationship data element stored data usually modeled graph node corresponding data element link directed arc bidirectional edge corresponding relationship relationship serve double purpose primarily define semantics data allow program interpret data correctly aspect relationship highlighted database field example relationship model secondarily relationship provide mean accessing data starting element following access path lead element studying data structure mainly concerned use relationship access data structure data irregular structure highly dynamic extensively modified run time practical alternative representing relationship explicitly domain list structure presented chapter list structure structure data static obeys regular pattern hand alternative compress structural information replace explicit link formula tell neighboring element approach work save memory space lead faster program use term implicit denote data structure relationship data element given implicitly formula declaration program additional space needed relationship data storage best known example array look area array stored impossible derive content relationship element information element belong array given type data structure hand hand corresponding procedure accessing operating data particularly true implicit data structure simply exist independent accessing procedure separated code implicit data structure represents best unordered set data right code exhibit rich structure beautifully illustrated heap end chapter algorithm data structure global implicit data structure array storage array declared var array m n elt usually written rectangular shape n n m m m n stored linearly addressed memory typically row row shown column column fortran consecutive storage cell starting base address element fit cell address b b n b n b n b n n b n m n b m n element type occupies c storage cell address α j j linear formula generalizes array declared var array mk elt address α ik element ik book licensed creative common attribution license point access element j invokes evaluation linear formula α j tell element programming language hide detail address computation wish advantage special structure matrix following type sparse matrix occur frequently numerical linear algebra band matrix n n matrix m called band matrix width b b mi j j word nonzero element located main diagonal b adjacent minor diagonal side main diagonal n large b small space saved storing m dimensional array n b cell array cell type bandm array n b elt var bandm row store nonzero element corresponding row m diagonal element m b element left diagonal mi mi mi b element right diagonal mi mi mi b row contain cell corresponding triangle stick m exhibit element m stored array j contains mi n j b total b b cell upper left lower right remain unused worth saving additional b b cell packing band matrix m array minimal size mapping irregular formula calculating ind ice mi j complicated exhibit extending diagonal dummy element give band matrix shape rectangular array algorithm data structure global text implicit data structure exercise band matrix write procedure add p q bandm var r bandm add band matrix stored p q store result b write procedure bmv p bandm v var w multiplies band matrix stored p vector v length n store result solution procedure add p q bandm var r bandm var n j b begin n j b r j p j q j end b type vector array n real procedure bmv p bandm v vector var w vector var n j b begin n begin w j b j j n w w p j v j end end sparse matrix matrix called sparse consists zero seen sparse matrix regular shape compressed efficiently using address computation irregularly shaped sparse matrix hand yield gracefully compression smaller array way access based address computation instead nonzero element stored unstructured set record record contains pair j j consisting index tuple j value j element absent set assumed zero position data element stored explicitly index pair j representation implicit data structure consequence access random element irregularly shaped sparse matrix typically requires searching likely slower direct access element matrix regular shape stored implicit data structure exercise triangular matrix let b n element diagonal zero j bi j j prove inverse exists matrix product matrix b devise scheme storing matrix b array c minimal size write pascal declaration c draw picture content c write function function j n real function b j n real book licensed creative common attribution license d access c return corresponding matrix element e write procedure computes b place entry c replaced entry product use small constant number additional variable independent size b f d using solution inverse n exists iff determinant matrix non zero let triangular matrix inverse matrix b exists let j b matrix let b c b j sum ci j c b b stored array c size n n follows exhibit const n var c array n n real algorithm data structure global implicit data structure exhibit staircase separate triangular matrix c stored rectangular array graphic doe match function j n real begin j return return c j end function b j n real begin j return return c n n j end d new element result matrix c overwrite old element important compute right order specifically row c element c j computed left right increasing order procedure mult var j k integer x real begin n j begin x k j x x k b k j c j x end end e procedure inverta var j k integer x real begin n begin j begin x k j x x c k c k j book licensed creative common attribution license c j x c end c c end end procedure ainvertedmultb begin inverta mult end implementation fifo queue circular buffer fifo queue needed situation process interact following way process called producer generates data process called consumer process typically work burst producer generate lot data consumer busy data saved temporarily buffer consumer take needed keyboard driver editor example consumer interaction keyboard driver transfer character generated key press buffer editor read buffer interprets control character text inserted worth remembering buffer help process work speed long run producer faster buffer overflow consumer faster buffer needed buffer equalize temporary difference speed knowledge statistical behavior producer consumer usually compute buffer size sufficient absorb producer burst high probability allocate buffer statically array fixed size statically allocated buffer circular buffer natural implementation fifo queue circular buffer array b considered ring cell b successor cell b m shown exhibit element stored buffer consecutive cell pointer point cell element inserted point cell containing element removed new element inserted storing b advancing cell element b removed advancing cell algorithm data structure global implicit data structure exhibit insertion pointer deletion pointer counterclockwise array notice pointer meet buffer get get clearly able distinguish buffer avoid insertion removal sight appears pointer insufficient determine circular buffer following implementation us additional variable n count element buffer const m length buffer type addr m index range varb array addr elt storage addr access buffer n m number element currently buffer procedure create begin n end function boolean begin return n end function boolean begin return n m end procedure enqueue x elt called queue begin b x mod m n n end function elt called queue begin return b end procedure dequeue called queue begin mod m n n end book licensed creative common attribution license producer us deletes element circular buffer consumer us insert element state circular buffer described content value changed producer need changed consumer need variable n changed process shared variable process exhibit exhibit producer consumer shared variable b producer consumer concurrent programming environment process execute independently access shared variable synchronized synchronization overhead avoided possible shared variable n superfluous exhibit b use trick leaving cell free sentinel ensures expressed term distinguished specifically define mod m lead elegant efficient implementation fifo queue circular buffer const m length buffer typeaddr m index range fifoqueue b array addr elt storage addr access buffer end procedure create var f fifoqueue begin end function f fifoqueue boolean begin return end function f fifoqueue boolean begin return mod m end procedure enqueue var f fifoqueue x elt called queue begin x mod m end algorithm data structure global text implicit data structure function f fifoqueue elt called queue begin return end procedure dequeue f fifoqueue called queue begin mod m end implementation priority queue heap priority queue realized circular buffer element stored cell ordered according priority point element highest priority exhibit implementation operation time complexity o point directly element highest priority insertion requires finding correct cell corresponding priority element inserted shifting element buffer make space binary search achieve task time o log n requires time o n exhibit implementing priority queue circular buffer shifting element make space new element cost o n time implementing priority queue linear list element ordered according priority doe speed insertion finding correct position insertion requires time o n exhibit exhibit implementing priority queue linear list finding correct position new element cost o n time heap elegant efficient data structure implementing priority queue allows operation performed time o allows performed time o log n heap binary tree structural property order property embedded array certain way structure binary tree balanced possible leaf adjacent level node level located far left possible exhibit book licensed creative common attribution license exhibit heap structure complete binary tree order element assigned node element assigned child node exhibit exhibit order property implies smallest element stored root order property implies smallest element priority stored root operation return value time o obvious way delete element leaf hole take time tree reorganized retain structural order property structural condition requires removal rightmost node lowest level element stored used temporarily vacuum root root violate order condition restored sifting tree according weight exhibit order condition violated node element node exchanged smaller element stored child example exchanged process continues element find proper level latest land leaf algorithm data structure global implicit data structure exhibit rebuilding order property tree exhibit removed moved root insertion handled analogously structural condition requires new node created level leftmost slot new element example temporarily stored node exhibit parent node violates order condition restore floating new element upward according weight new element smaller stored parent node element example exchanged process continues element find proper level latest surface root exhibit rebuilding order property tree exhibit inserted new rightmost node lowest level number step executed process process equal height tree structural condition implies height n heap work time o log n book licensed creative common attribution license binary tree implemented different way special class tree meet structural condition stated particularly efficient array implementation heap binary tree satisfies structural order condition embedded linear array way child node index index exhibit parent node index j index j div subtree heap heap stored contiguously order property heap implies element stored index element stored index order called heap order exhibit embedding tree exhibit linear array procedure useful tool managing heap creates heap binary tree embedded linear array h satisfies structural condition provided subtrees root node heap procedure applied subtrees entire heap node stored index l r tree structure defined formula const m length heap type addr m var h array addr elt procedure restore l r addr var j addr begin l r div begin r cand h h j j h j h h h j j r end end operates single path root leaf tree r l node work time o log r l creating heap array h turned heap follows n div restore n algorithm data structure global text implicit data structure efficient repeated insertion single element existing heap loop executed n div time n n time complexity creating heap n element o n log n careful analysis show time complexity creating heap o n heap implementation priority queue const m maximum length heap typeaddr m priorityqueue record h array addr elt heap storage n m current number element end procedure restore var h array addr elt l r addr begin end procedure create var p priorityqueue begin end function p priorityqueue boolean begin return end function p priorityqueue boolean begin return m end procedure insert var p priorityqueue x elt called queue var m begin x cand div div div end function min p priorityqueue elt called queue begin return end procedure delete var p priorityqueue called queue begin restore end heapsort heap core elegant o n log n sorting algorithm following procedure sort n element stored array h decreasing order procedure heapsort n addr sort element stored h n var addr begin heap creation phase heap built n div downto restore n phase element extracted heap increasing order n downto h h restore end loop executed n time time complexity restore o log n heapsort work time o n log n book licensed creative common attribution license exercise programming project matrix composed smaller matrix line diagonal element shown exhibit store arbitrary matrix minimal storage area write corresponding address computation formula exhibit structure matrix antisymmetric n element matri x satisfy aij value diagonal element ii matrix b stored linear array c minimal size s size c c write function j n real return value corresponding matrix element product n n matrix width b b band matrix width product matrix write procedure computes product band matrix having width store result band matrix minimal width queue deque circular buffer minimum maximum number element heap height h time complexity following operation performed heap storing n element searching element b searching largest element element lowest priority heapsort animate sorting process example shown snapshot algorithm animation compare number comparison exchange operation needed heapsort sorting algorithm quicksort different input configuration running time heapsort array h n sorted increasing order decreasing order heap node k child instead child represent heap array b height heap term number element n k c implement priority queue heap time complexity operation term n k algorithm data structure global text book licensed creative common attribution license list structure learning objective v dynamic data structure circular list queue implemented linear list tree traversal binary tree auxiliary memory triple tree traversal algorithm implemented binary search tree tree guarantee dictionary operation performed logarithmic time tree tree list memory management pointer variable spectrum data structure range static object table constant dynamic structure list list designed data value stored size shape change run time insertion deletion rearrangement data element data structure discussed far change size shape limited extent circular buffer example support insertion end deletion grow predeclared maximal size heap support deletion end insertion array list local change effort independent size list provided know memory location data element involved key meeting requirement idea abandoning memory allocation large contiguous chunk instead allocating dynamically smallest chunk hold given object data element stored randomly memory contiguously insertion deletion list doe propagate ripple effect shift element element inserted allocated memory space tied element pointer address memory location element happen stored moment element deleted doe leave gap need filled array instead leaf free space reclaimed later memory management process element deleted likely break chain tie element broken chain relinked according rule specific type list used pointer language feature used modern programming language capture equivalent memory address pointer value essentially address pointer variable range address pointer contain information merely address pascal strongly typed language example pointer reference type definition object point feature enhances compiler ability check consistent use pointer variable let illustrate concept simple example linear list sequence cell point successor cell head list cell tail algorithm data structure global list structure tail successor pointer assigned predefined value differs address cell access list provided external pointer list value cell store element xi pointer successor cell exhibit e elt cptr end exhibit linear list local operation insertion deletion position given pointer p efficient example following statement insert new cell containing element y successor cell pointed p exhibit new q y q exhibit insertion local operation successor cell pointed p deleted single assignment statement exhibit exhibit deletion local operation insertion deletion head tail list special case handled separately support insertion tail additional pointer variable set point tail element exists linear list handier tail point head making circular list circular list head tail cell replaced single entry cell cell reached having start external pointer exhibit exhibit circular list combine head tail single entry point book licensed creative common attribution license doubly linked list cell contains pointer successor predecessor list traversed direction exhibit show circular list exhibit circular list exercise traversal singly linked list direction write recursive procedure traverse p cptr traverse singly linked list head tail visit node procedure visit p cptr solve problem iteratively using additional storage local pointer traversal procedure modify structure list temporarily solution procedure traverse p cptr begin p nil visit p traverse visit p end initial procedure traverse head b procedure traverse p cptr var o q cptr integer begin forward begin o nil p nil begin visit p q o o p p q fork advance end p o end end traversal simpler let pointer tail cell point cell procedure traverse p cptr var o q cptr begin o nil p nil begin visit p q o o p p q fork advance end end algorithm data structure global text list structure fifo queue implemented list natural implement fifo queue linear list element point line operation occurs pointer fast having external pointer point element queue crafty implementation data structure involves cell called sentinel tail list purpose make procedure simpler faster making queue look like state queue precisely queue external pointer point sentinel having value sentinel allows insertion queue deletion result queue handled code handle general case reader verify claim sentinel simplifies code programming plausible efficient procedure assume queue represented head tail nil queue point sentinel head tail operation performed inserting new element sentinel cell creating new sentinel e elt cptr end fifoqueue record head tail cptr end procedure create var f fifoqueue begin new end function f fifoqueue boolean begin return end procedure enqueue var f fifoqueue x elt begin x new end function f fifoqueue elt called queue begin return end procedure dequeue var f fifoqueue called queue begin end tree traversal speak tree computer science usually mean rooted ordered tree distinguished node called root subtrees node ordered rooted ordered tree best defined recursively tree t empt y tuple n tk n root tree tk sequence tree binary tree special case k tree typically used organize data activity hierarchy data set activity composed level data activity wish gather survey data activity necessary traverse tree visiting processing node systematic order visit node simple printing content complicated computing function depends node tree major way traverse tree breadth depth traversal visit node level level useful heuristic search node represents partial solution problem deeper level representing complete solution pursuing solution great depth advantageous assess partial solution present book licensed creative common attribution license level order pursue promising discus traversal merely suggest following exercise traversal decide representation tree node variable number child write procedure traversal tree hint use fifo queue organize traversal node visited removed head queue child enqueued order tail end traversal move unvisited node deeper level turn better fit recursive definition tree doe order node way useful discus binary tree leave generalization tree reader generate basic order traversing binary tree preorder inorder postorder defined recursively preordervisit root traverse left subtree traverse right subtree inorder traverse left subtree visit root traverse right subtree postordertraverse left subtree traverse right subtree visit root tree exhibit obtain order shown exhibit standard order defined binary tree arithmetic expression represented binary tree assigning operand leaf operator internal node basic traversal order correspond different notation representing arithmetic expression traversing expression tree exhibit preorder inorder postorder obtain prefix infix suffix notation respectively exhibit standard traversal order correspond different notation arithmetic expression binary tree implemented list structure way common way us external pointer access root tree represents node cell contains field element stored pointer root left subtree pointer root right subtree exhibit left right subtree represented pointer value pointing sentinel shall pointer point node e elt l r nptr end varroot nptr algorithm data structure global text list structure exhibit straightforward implementation binary tree following procedure implement order preorder inorder postorder depending procedure v process data node referenced pointer root subtree traversed passed formal parameter simplest case visit doe simply print content node procedure traverse p nptr begin p nil begin p preorder traverse p inorder traverse p postorder end end traversing tree involves advancing root leaf backing leaf root recursive invocation procedure build stack entry contain reference node called entry provide mean returning node traversal subtrees finished bookkeeping stack equivalent auxiliary structure avoided tree traversed modified temporarily following traversal algorithm provides elegant efficient way traversing binary tree using auxiliary memory stack used assumed node contains pointer parent node data structure modified temporarily retain information needed way tree restore subtree initial condition traversal traversal algorithm assumes subtree encoded pointer l left r right pointer point node shown exhibit book licensed creative common attribution license exhibit coding leaf used procedure ttt procedure ttt var o p q nptr begin o nil p root p nil begin visit p q rotate left pointer o rotate right pointer o p p q end end procedure pointer p present o old serve fork tree traversed pointer p companion pointer o lag step pointer form fork run tree starting initial condition p pointing root tree o nil auxiliary pointer q needed temporarily advance fork loop executed long p point node tree terminated p assumes value initial value o pointer get saved temporary value assigned r pointer root later l pointer finally get assigned p fork exit root tree traversal tree complete correctness algorithm proved induction number node tree induction hypothesis h beginning iteration loop fork pointer p point root subtree n node o value x different pointer value inside subtree n iteration subtree traversed triple order visiting node exactly time tree pointer subtree restored original value fork pointer reversed p value x o point root subtree base induction h true n proof smallest tree consider exactly node root loop executed subtree fork tree initial state shown exhibit exhibit show state fork tree iteration loop node visited iteration exhibit initial configuration traversing tree consisting single node algorithm data structure global text list structure exhibit tracing procedure ttt traversing smallest tree induction step h true n n k h true k proof consider tree t k node t consists root k node shared left right subtrees root subtrees k node apply induction hypothesis following highly compressed account proof induction step illustrated exhibit consider tree k node shown state root node field left right subtrees shown triangle figure show typical case subtrees nonempty subtrees corresponding pointer point root case handled similarly case n fork start p pointing root o pointing outside subtree traversed want initial state transformed k iteration final state final state subtrees shaded indicate correctly traversed fork exited root p o having exchanged value algorithm correctly transforms state state consider intermediate state happens transition iteration loop advance fork left subtree rotates pointer root h applied left subtree root say subtree correctly traversed fork exit subtree pointer reversed second iteration loop visit root fork advance right subtree pointer root rotate second time h applied right subtree root say subtree correctly traversed fork exit subtree pointer reversed iteration loop visit root fork move tree traversed pointer root rotate time assume original value book licensed creative common attribution license exhibit trace procedure ttt invoking induction hypothesis exercise binary tree consider binary tree declared follows l r nptr end varroot nptr node left right subtree corresponding pointer value prove binary tree n node n n pointer algorithm data structure global text list structure b write function node integer return number node function depth integer return depth binary tree depth root defined depth node depth parent increased depth tree maximum depth node solution node contains pointer total n pointer tree exactly pointer point n node point root n n n pointer proved induction number node tree b function node p nptr integer begin p nil return return node node end function depth p nptr integer begin p nilthenreturn elsereturn max depth depth end function max b integer integer begin b return return b end exercise list copying effective memory management make desirable necessary copy list example performance improve drastically list spread page compressed single page list copying involves traversal original concurrently traversal copy built consider binary tree built node type pointer type tree accessed pointer root tree node e elt l r nptr end write recursive function cptree p nptr nptr copy tree given pointer p root return pointer root copy b consider arbitrary graph built node type similar node additional pointer field cn intended point copy node type node record e elt l r nptr cn nptr end graph accessed pointer node called origin concerned node reached origin access pointer graph write recursive function cpgraph p nptr nptr book licensed creative common attribution license copy graph given pointer p origin return pointer origin copy use field cn assuming initial value node original graph set node copy solution function cptree p nptr nptr var cp nptr begin p nil return nil begin new cp cptree cptree return cp end end b function cpgraph p nptr nptr var cp nptr begin p nil return nil elsif nil node copied return begin new cp cp nil cpgraph cpgraph return cp end end exercise list copying constant auxiliary memory consider binary tree preceding exercise memory stack implied recursion saved writing iterative tree copying procedure us constant auxiliary memory requires trick traversal able leaf root tree traversal procedure return path temporarily encoded tree traversed idea used simpler solution return path temporarily encoded copy field certain node copy point corresponding node original work detail procedure work o auxiliary memory exercise traversing directed acyclic graph directed graph consists node directed arc arc lead node directed graph acyclic arc form cycle way ensure graph acyclic label node distinct integer draw arc lower number higher number consider binary directed acyclic graph node pointer field l r represent arc lead node example shown exhibit exhibit rooted acyclic graph algorithm data structure global text list structure write program visit node directed acyclic graph reachable pointer called free execute procedure node like b write program similar required execute procedure exactly node hint node need additional field exercise counting node square grid consider network superimposed square grid node connected neighbor direction east north west south exhibit e n w s nptr status boolean end varorigin nptr exhibit graph embedded square grid pointer indicates absence neighbor neighboring node doubly linked pointer node p point node q reverse pointer q point p q p pointer point node consider problem counting number node reached assume status field node initially set false use field write function nn p nptr integer count number node solution function nn p nptr integer begin p nil cor return begin true return nn nn nn nn end end exercise counting node arbitrary network generalize problem arbitrary directed graph exhibit node number neighbor graph represented data structure defined exhibit type definition node linked arbitrary number node exhibit arbitrary cyclic directed graph book licensed creative common attribution license exhibit possible implementation list structure cptr status boolean np nptr cp cptr end np nptr cp cptr end varorigin nptr pointer value point node consider problem counting number n node reached status field node initially set false use write function nn p nptr integer return binary search tree binary search tree binary tree t node n store data element e n domain x total order defined subject following order condition node n t element left subtree l n n e n element right subtree r n n e n let xn n element drawn domain definition binary search tree x xn binary tree t n node mapping n given element n node n t n l n n r n e n e n e n exercise following statement equivalent order condition inorder traversal node t coincides natural order element assigned node remark order condition relaxed e n e n e n accommodate multiple occurrence value minor modification statement algorithm presented section simplicity sake assume value tree distinct order condition permit binary search guarantee search time o h tree height tree balanced intuitive sense section definition degenerated linear list height h o log n support search logarithmic time algorithm data structure global text list structure basic operation binary search tree easily implemented recursive procedure consider tree represented preceding section subtrees denoted following function search element x subtree pointed return pointer node containing x search successful function x elt p nptr nptr begin p nil return nil elsif x return x elsif x return x x return p end following procedure leaf tree element x inserted stored tree parameter p initially point root subtree x inserted procedure insert x elt var p nptr begin p nil new p x nil nil elsif x insert x elsif x insert x end initial insert x root delete element x node n store node leaf semileaf node subtree easily deleted subtrees efficient leave node place replace element x element leaf semileaf node delete exhibit distinguish case n child remove n exactly child replace n child node n child replace x largest element y left subtree smallest element z right subtree element stored node child removed case book licensed creative common attribution license exhibit element x deleted preserving node node n filled new value y old node easier delete sentinel key elegant iterative implementation binary search tree node left right child corresponding pointer point sentinel sentinel node contains element left pointer point root right pointer point root exists accessed left pointer sentinel tree represented sentinel exhibit typical tree shown exhibit exhibit binary tree represented sentinel point exhibit binary tree implemented list structure sentinel following implementation dictionary binary search tree us sentinel accessed variable d e elt l r nptr end dictionary nptr procedure create var d dictionary begin create sentinel new d d d end algorithm data structure global text list structure function member d dictionary x elt boolean var p nptr begin x initialize element sentinel p point root exists x x p x p return p d end procedure search p point node containing x q parent p point sentinel q new node x inserted procedure d dictionary x elt var p q nptr begin x p q d x begin q p x p x p end end procedure insert var d dictionary x elt var p q nptr begin d x p q p d begin x tree new p x d d x p x p end end procedure delete var d dictionary x elt var p q t nptr begin d x p q p d x d d begin p left right child largest element left subtree t q p d q t t end begin p child d left child p d right child p p child p d x p x p end end best case completely balanced binary search tree n element leaf level n n search tree height n cost performing operation bounded longest path root leaf height tree o log n book licensed creative common attribution license provision binary search tree degenerate linear list worst case cost operation o n expected average cost search operation randomly generated binary search tree randomly generated mean permutation n element stored binary search tree probability chosen input sequence furthermore assume tree generated insertion n element equally likely chosen root tree le t pn expected path length randomly generated binary search tree storing n element shown chapter section recurrence relation recurrence relation solution average search time randomly generated binary search tree measured term number node visited pn n ln follows cost o log n cent higher case completely balanced binary search tree balanced tree general definition insertion deletion occurred random assumption preceding section realistic let search tree grow shrink incurring modest increase cent search time completely balanced tree real data random typically clustered long run monotonically increasing decreasing element occur result previous processing step unfortunately deviation randomness degrades performance search tree prevent search tree degenerating linear list monitor shape restructure balanced shape skewed class balanced search tree guarantee operation performed time o log n worst case work depends directly height tree class b search tree satisfy following condition s ht height tree t n t number node t balance condition t b ht c nt rebalancing condition operation performed tree t b yield tree t b possible rebalance t time o log n yield tree t example complete tree class complete binary search tree satisfies balance condition restructuring condition worst case take time o n restructure binary search tree exhibit defined include rebalancing necessary operation guaranteed run time o log n algorithm data structure global list structure exhibit restructuring worst case section present class balanced tree meet condition balanced landis al various multiway tree tree bm com generalization b meh small node hold single data element used primarily storing data main memory multiway tree potentially large node hold element useful organizing data secondary storage device disk allow direct access sizable physical data block case node typically chosen physical data block read written access operation tree definition binary tree node height subtrees differ search tree called exhibit exhibit various exhibit example tree exhibit example tree marked node violates balance condition th height h minimal number node starting t shown exhibit th obtained attaching t subtrees new root book licensed creative common attribution license exhibit skewed avl tree height h h number node height h given recurrence relation nh section recurrence relation chapter entitled mathematics algorithm analysis shown recurrence relation mh solution nh obtain follows nh behaves asymptotically algorithm data structure global text list structure applying logarithm result height n node class satisfies balance condition operation performed time o log n class satisfies rebalancing condition support insertion deletion time o log n node n balance property leaning horizontal depending relative height subtrees local tree operation rotation double rotation allow restructuring tree disturbed insertion deletion split tree subtrees rebuild different way exhibit show node marked black got balance local transformation build equivalent tree element arranged order balanced transformation mirror image shown algorithm insertion deletion use rebalancing operation described exhibit local rebalancing operation insertion new element inserted case binary search tree balance condition new node horizontal starting new node walk root tree passing message height subtree rooted current node increased node encountered path operation determined following rule performed rule depend balance condition node new element inserted direction node entered left right child book licensed creative common attribution license rule current node balance condition change depending entered node left right child current node root terminate continue follow path upward rule current node balance condition entered subtree previously shorter change balance condition terminate height subtree rooted current node changed rule current node balance condition entered subtree previously taller balance condition cu rrent node violated get restored follows step direction left child right child appropriate rotation restores balance procedure terminates b step opposite direction left child right child appropriate double rotation restores balance procedure terminates initial insertion travel path root leaf rebalancing process travel path cost insertion o h o log n worst case ice insertion call rotation double rotation shown example exhibit example insert initially exhibit balance condition node shown boldfaced node violate balance condition algorithm data structure global list structure exhibit trace consecutive insertion rebalancings trigger deletion element deleted case binary search tree starting parent deleted node walk root passing message height subtree rooted current node decreased node encountered perform operation according following rule rule depend balance condition node deletion direction current node child entered rule current node balance condition change depending entered node left right child terminate height subtree rooted current node changed rule current node balance condition entered subtree previously taller change balance condition continue upward passing message subtree rooted current node shortened rule current node balance condition entered subtree previously shorter balance condition violated current node distinguish subcases according book licensed creative common attribution license balance condition child current node consider mirror image following illustration xyzab xyzbarotation appropriate rotation restores balance current node changing height subtree rooted node terminate b xyzba xyzabrotation rotation restores balance current node continue upward passing message subtree rooted current node shortened c double rotation wabcabc xyzwxyz double rotation restores balance current node continue upward passing message subtree rooted current node shortened similar transformation apply x y level shorter shown figure balance condition node differ shown influence total height subtree contrast insertion deletion require rotation double rotation restore balance cost rotation double rotation constant cost rebalancing tree depends height tree cost deletion o log n worst case multiway tree node multiway tree variable number child interested balanced tree add restriction insist leaf node child occur depth second constrain number child internal node lower bound upper bound variety multiway tree known differ detail based similar idea example defined requirement internal node child generalize concept discus b definition consider domain x total order defined let b integer let c n denote number child node b ordered tree following property algorithm data structure global list structure leaf level c root b internal node n root c n b node k child contains k element x drawn x subtrees corresponding k child denoted t tk b support c n search way binary tree support binary search thanks following order condition xi element y stored subtrees t ti z element z stored subtrees t tk definition b b known bm com algorithm discus operate internal node shown white exhibit ignore leaf shown black purpose understanding search update algorithm leaf considered fictitious entity used counting practice thing different internal node merely constitute directory file stored leaf leaf typically physical storage unit disk block hold record key value lie adjacent element stored internal node exhibit example number n element stored internal node b height h bounded show class b satisfies balance condition h o log n class meet rebalancing condition b support insertion deletion time o log n insertion insertion new element x begin search x terminates unsuccessfully leaf let n parent node leaf n contained fewer b element insertion insert x n terminate n imagine b element temporarily squeezed overflowing node let m median b element use m split n left node n l populated b element smaller m right node nr populated b element larger tha n condition b ensures b word new node contains element median element m pushed upward parent node serf separator new node nl nr place inhabited problem insertion node given level replaced problem level higher tree new separator element absorbed nonfull parent parent overflow splitting process described repeated recursively book licensed creative common attribution license worst splitting process propagates root tree new root contains median element created b grow root reason allowing root child deletion deletion element x begin searching case binary search tree deletion easiest tree node maximal depth child leaf x higher level tree node internal node child x separator subtrees t l tr replace x element z largest element t l smallest element t r stored node tree exchange problem reduced deleting element z node n deepest level deletion x z leaf n element try restore n occupancy condition stealing element adjacent sibling node sibling m spare element m minimally occupied m n merged single node l contains element n element m separator m n stored parent node total b element parent old node m n new node l lost element merger parent underflow case insertion underflow propagate root cause deletion b grow shrink root insertion deletion work single path root l eaf possibly time bounded o h equivalently o log n b rebalanced logarithmic time amortized cost performance b better analysis suggests shown total cost sequence s insertion deletion initially b linear length s sequence cost single operation o log n amortized cost operation o meh amortized cost complexity measure involves average consideration average taken operation sequence worst case taken sequence operation time o log n guaranteed total s operation sequence length s time o s single operation time o exhibit slightly skewed exercise insertion deletion starting shown exhibit perform sequence operation insert delete delete delete draw tree operation solution inserting cause leaf parent split exhibit deleting cause underflow remedied borrowing element left sibling exhibit deleting cause underflow leaf parent remedied merging exhibit deleting cause merging leaf level borrowing parent level exhibit algorithm data structure global text list structure exhibit node split propagate root exhibit deletion absorbed borrowing exhibit deletion propagates node merges root exhibit node merges borrowing combined special case b node child exhibit omits leaf starting tree state insert value rightmost node level overflow split median move parent parent overflow median generates new root state deletion absorbed rebalancing state deletion cause node underflow remedied stealing element sibling replaced replaced state deletion book licensed creative common attribution license trigger merger node assigned cause underflow parent turn propagates root result tree reduced height state exhibit tracing insertion deletion mentioned earlier multiway tree particularly useful managing data disk node allocated disk block searching record trigger disk access level tree depth tree minimized maximal b maximized pack element node shrinking size record stored normally larger identifying key store key internal node store entire record leaf considered internal node serve index assigns key value path corresponding leaf exercise programming project implement list structure storing sparse matrix implementation provide procedure inserting deleting changing reading matrix element fifo queue circular list using external pointer f sentinel f point sentinel provides access head tail queue queue deque doubly linked list search tree sorting binary search tree given following declaration used manage set integer l r nptr x integer end varroot nptr tree represented root nil draw result inserting sequence tree algorithm data structure global text list structure b write procedure smallest var x integer return smallest number stored tree procedure remove smallest deletes tree procedure procedure message c write procedure sort sort number stored var array n integer inserting number binary search tree writing array sorted order traverse tree d analyze asymptotic time complexity typical worst case e doe approach lead sorting algorithm time complexity θ ν λογ ν implementation dictionary binary search tree binary search tree section support operation defined chapter section dictionary deletion starting insert order draw insertion delete element opposite order insertion order doe state insertion reverse order supporting dictionary operation smallest element b predecessor given element b dictionary book licensed creative common attribution license address computation learning objective hashing resolution method separate chaining coalesced chaining open addressing linear probing double hashing degrade performance hash table doe depend number data element stored load factor hash table transform unknown distribution uniform distribution hashing us radix tree adapt address range dynamically content stored deletion degrade performance extendible hashing concept terminology term address computation hashing hash coding scatter storage transformation refers search technique aim assign address storage cell key value x mean formula depends x assigning address x independently presence absence key value lead faster access possible comparative search technique discussed earlier chapter goal achieved address computation doe provide fastest access possible practical situation use following concept terminology exhibit home address x obtained mean hash function h map key domain x address space h x address range m m number storage cell available storage cell represented array t m hash table t cell addressed t h x cell element key value x preferentially stored ala necessarily exhibit hash function h map typically large key domain x smaller address space algorithm data structure global text address computation cell capacity b element b stand bucket capacity number n element stored bounded m case usefully distinguished depending hash table resides disk central memory secondary storage device consideration efficiency suggest bucket identified physical unit transfer typically disk block unit usually large compared size element b memory cell size important code simplest cell hold exactly element b simplicity exposition assume b unless stated generalization arbitrary b straightforward key domain x normally larger number n element stored number m available cell t example table used storing thousand identifier key domain set string length t alphabet b z cardinality close general function h different key value map address content stored sample key domain programmer control usually known hash function table size chosen expect collision event b element stored assigned address collision resolution method designed handle case storing colliding element collision occur longer search time number collision random event search time random variable hash table known excellent average performance terrible performance hope occur address computation technique support operation lesser extent expected time o remarkable difference data structure discussed far average time complexity doe depend number n element stored load factor λ n m b special case b λ n note λ consider typical case hash table illustrate concept special case simple represent ideal rarely attainable special case small key domain number possible key value equal number available storage cell h map x simple efficient collision occur consider following example x b z h x ord x ord h h b h c h z h key value x implied address h x need store key value explicitly single bit present absent suffices var t array boolean function member x boolean begin return t h x end book licensed creative common attribution license procedure insert x begin t h x true end procedure delete x begin t h x false end idea address computation extended large key domain combination address computation list processing technique chapter metric data structure special case perfect hashing table content known priori certain common application require storing set element change set reserved word programming language example lexical analyzer compiler extract identifier issue determined reserved word programmer defined special case table content known priori insertion deletion occur handled efficiently data structure general dictionary element xn stored known hash table designed underlying key domain important set actually occurring key value usually table size m larger number n element stored easily evaluated hash function h assigns xi unique address address space m take trial error perfect hash function h given set element benefit avoiding collision worth effort code implement hash table simple fast perfect hash function work static table single insertion h chosen likely cause collision destroy simplicity concept efficiency implementation perfect hash function generated automatically program following unrealistically small example illustrates typical approach designing perfect hash table task get harder number m available storage cell reduced minimum possible number n element stored example designing perfect hash table element look arithmetic pattern easily detected considering binary representation number stored bit position observe significant bit identify element uniquely hash function h x x mod map element address space m cell attempt economize space lead observe bit position weight binary number representation identify element uniquely ranging address space minimal size function h x x div mod extract bit assigns following address algorithm data structure global address computation perfect hash table store element explicitly just bit example element map address present table access function x implemented single statement return h x cand t h x x boolean operator used understood conditional evaluation expression proceeds left right stop soon value determined example h x suffices assign expression h x t h x x operator guarantee table declared var t array element accessed index bound table content realistic size impractical construct perfect hash function manually need program search exhaustively large space function slack m n allow denser population perfect function quicker meh present analytical result complexity finding perfect hash function exercise perfect hash table design perfect hash table content solution designing perfect hash table like answering question type element sequence infinitely answer elegant consider h address range x div mod x mod x div mod x x mod conventional hash table collision resolution contrast special case discussed application address computation present data structure designer greater uncertainty favorable condition typically underlying key domain larger available address range known element stored upper bound n know probability distribution governs random sample element stored setting customer list local business example number customer bounded population town distribution name obtained telephone directory name start h s hardly q basis information ignorance actual table content stored choose size m hash table design hash function h map key domain x address space m live consequence decision decide rehash resize table redesign hash function reinsert element stored far later section present pragmatic advice choice h let assume appropriate hash function available regardless smart hash function designed collision b element share home address bucket capacity b inevitable practice hashing requires technique book licensed creative common attribution license handling collision present major collision resolution technique use separate chaining coalesced chaining open addressing technique called chaining list processing technique organize overflowing element separate chaining used list live overflow area distinct hash table proper coalesced chaining list live unused part table open addressing us address computation organize overflowing element technique come different variation illustrate typical choice separate chaining memory allocated table split primary overflow area overflowing cell bucket primary area head list called overflow chain hold element overflow bucket exhibit show element inserted der arrival resides home address later one appended overflow chain exhibit separate chaining handle collision separate overflow area separate chaining easy understand insert delete search operation simple contrast collision handling technique hybrid address computation list processing major advantage deletion degrade performance hash table regardless number m home address hash table overflow entire memory exhausted size m table critical influence performance m n overflow chain long essentially list processing technique doe support direct access m n overflow chain short waste space table practical choice m n separate chaining disadvantage different accessing technique required space significant overhead small element algorithm data structure global text address computation partitioned separate area share space overflow area entire table space array home cell consideration lead technique coalesced chaining chain emanate overflowing bucket stored space hash table separate overflow area exhibit advantage available space utilized fully overhead pointer managing space shared accessing technique get complicated exhibit coalesced chaining handle collision building list share memory hash table technique similar advantage addition incurs overhead pointer disadvantage thing considered probably best collision resolution technique open addressing assign element x x probe sequence h x address fill entire address range intention store x preferentially t occupied cell encountered probe sequence occupied cell probe sequence called collision path collision path prefix probe sequence enforce invariant x table t precedes probe sequence x t occupied following fast simple loop travel collision path used search x h x t x t address probe sequence let work detail loop terminates correctly code concise fast make probe sequence defined formula program example implicit data structure pointer data case coalesced chaining example linear probing ai mod m simplest possible formula disadvantage phenomenon called clustering clustering arises collision path element table overlap large extent likely happen linear probing element collided linear probing store consecutive cell element hash block contiguous occupied cell travel collision path book licensed creative common attribution license lengthening block turn increase probability future element hash block positive feedback loop get started cluster keep growing double hashing special type open addressing designed alleviate clustering problem letting different element travel step different size probe sequence defined formula h x δ g x ai δ mod m m prime g second hash function map key space x m important important detail solved probe sequence element span entire address range achieved m relatively prime step size δ easiest way guarantee condition choose m prime termination condition search loop t x t unsuccessful search x table terminate address generated t insisted probe sequence generates address addition guarantee table contains cell time serf sentinel terminate search loop following declaration procedure implement double hashing assume comparison operator defined x x contains special value differs value stored table example string blank denote table identifier choose identify unsuccessful search simply returning address cell constm size hash table prime typekey addr m step m vart array addr key n integer number element currently stored t function h x key addr hash function home address function g x key step hash function step procedure init var addr begin n m t end function x key addr var addr d step begin h x d g x t x t d mod m return end function insert x key addr var addr d step begin h x d g x t begin t x return d mod m end n m n n t x msg algorithm data structure global address computation return end deletion element creates problem case type hash table element deleted simply replaced break collision path element recall basic invariant correctness open addressing based idea rearranging element table refill cell emptied need remain quickly abandoned complicated deletion numerous programmer ought choose data structure fully support deletion balanced tree implemented list structure limited number deletion accommodated open address hash table using following technique time cell state occupied initial state cell currently used occupied currently free cell state terminates loop cell state state terminates insert loop state diagram shown exhibit describes transition possible lifetime cell deletion degrade performance hash table cell occupied return virgin state terminates unsuccessful equal number insertion deletion keep hash table low load factor λ unsuccessful find ultimately scan entire table cell drift state occurs table ought rehashed content inserted new initially table exhibit state diagram describes possible life cycle cell occupied cell useful cell exercise hash table deletion modify program implement double hashing deletion choice hash function randomization conventional terminology hashing based concept randomization purpose randomizing transform unknown distribution key domain x uniform distribution turn consecutive sample dependent independent sample task appears magic little mathematics applies construction hash function commonsense observation worth remembering observation primarily stem property set element wish store frequently possess based knowledge population stored assumed strictly population little say hash function proportional mapping x good function practice following example book licensed creative common attribution license fortran compiler use hash table store set identifier encounter program compiled rule language human habit conspire make set highly biased sample set legal fortran identifier example integer variable begin j k l m n convention likely generate cluster identifier begin letter example successive identifier encountered considered independent sample x y occurred higher chance z follow wrkhg example frequently sequence identifier statement number character code form arithmetic progression file system require encourage use naming convention file name begin end just prefix suffix individual user user community likely generate additional convention file name begin example initial name people involved file store text example structured according currently file directory file name sorted alphabetically inserted table order process monotonic sequence purpose hash function break regularity present set element stored reliably achieved hashing element word dictionary offer following explanation french hache chop small piece confuse muddle approximate elusive goal randomization hash function destroys pattern including unfortunately order defined hashing typically proceeds step element x number x case x integer occasionally real number x possible conversion x x involves action representation x type x reinterpreted representation number x x item example string representation x partitioned piece suitable length folded example word x encoded letter byte using ascii code leading folded form integer leading pair byte trailing pair byte xor represents x folding hashing pattern representation element easily survive folding example leading used pad ascii code byte remains zero regardless padded trailing zero x x representation x closely related drop use x slightly ambiguously denote original element interpretation number x precisely x obtain h x scrambling technique sensible try long avoids fairly obvious pitfall rule thumb algorithm data structure global address computation bit address h x depend bit key value particular ignore x computing h x thu s h x x mod suspect significant bit x affect h x sure arithmetic progression broken mapped arithmetic progression h x x mod k k significantly smaller table size m suspect function produce uniform distribution address h x suspect x uniformly distributed distribution highly skewed hash function fast simple desideratum obtained hash function type h x x mod m m table size prime number x key value interpreted integer hash function guaranteed avoid worst case hashing element stored collide address happens store multiple prime m hash function judged relation data asked store usually possible begun using hashing provides perfect example injunction programmer think data analyze statistical property adapt program data necessary performance analysis analyze open addressing deletion assuming address αi chosen independently address uniform distribution assumption reasonable double hashing lead conclusion average cost search operation hash table o consider load factor λ constant analyze average number probe executed function λ case u λ unsuccessful search s λ successful search let pi denote probability using exactly probe unsuccessful search event occurs probe hit occupied cell probe hit cell pi λ let qi denote probability probe used unsuccessful search occurs inspected cell occupied q qi expressed sum probability probe exactly j cell j running obtain number probe executed successful search element x equal number probe unsuccessful search element x inserted hash table note hold element relocated deleted average number probe needed search element inserted hash table u m s λ computed average u µ µ increasing discrete step reasonable approximation let µ vary continuously range λ book licensed creative common attribution license exhibit suggests reasonable operating range hash table keep load factor λ λ smaller waste space larger cent domain performance degrades rapidly note search successful hash table performs loaded searching killer table average number probe search grows rapidly load factor approach u λ s λ exhibit average number probe search grows rapidly load factor approach hash table designer able estimate n factor easy task incorrect guess waste memory cause poor performance table overflow followed crash programmer aware load factor lie outside range rehash size table change hash function reinsert element previously stored extendible hashing contrast standard hashing method extendible form hashing allow dynamic extension shrinkage address range hash function map key major advantage memory allocated needed unnecessary determine size address range priori deletion element doe degrade performance address range change hash function changed way element assigned new address need stored new bucket idea make possible map key large address space portion active given time various extendible hashing method differ way represent manage smaller active address range variable size subrange larger virtual address range following method extendible hashing especially suited storing data secondary storage device case address point physical block secondary storage contain element address bit string maximum length k time prefix d bit used bit string length k represented radix tree height k active bit string obtained using upper d level tree cutting tree level d exhibit show example d algorithm data structure global address computation exhibit address space organized binary radix tree radix tree shown exhibit node clipped describes active address range address considered bit string binary number active node address s corresponds bucket b store b record new element inserted bucket b b split instead b twin bucket b bit longer address b element stored b distributed b according bit new radix tree point data bucket b instead b active address range extended locally moving broken line exhibit block address overflow new twin block address created represented corresponding node tree overflowing bucket b depth d d incremented radix tree grows level extendible hashing clipped radix tree represented directory implemented array let d maximum number bit used bit string forming address example d directory consists entry entry directory corresponds address point physical data bucket contains element assigned address hash function directory radix tree exhibit look shown exhibit exhibit active address range tree exhibit implemented array bucket address corresponds node level radix tree entry directory corresponding bucket bucket overflow directory data bucket reorganized shown exhibit twin bucket jointly contain fewer b element merged single bucket keep average bucket occupancy high cent presence deletion probabilistic analysis predicts simulation result confirm bucket merging lead halving directory large file shrink smaller size directory shrink proportion extendible hashing unlike conventional hashing suffers permanent performance degradation deletion book licensed creative common attribution license exhibit overflowing bucket trigger doubling directory virtual radix tree extendible hashing hashing usual sense word destroys structure buy uniformity cost order extendible hashing hand practical randomization need accept inevitable consequence destruction order uniform distribution element nearly important nonuniformity cause directory deeper larger uniform distribution affect access time bucket occupancy directory small space overhead space required store data typically contains pointer say dozen byte data bucket say byte add percent total space requirement table growth critical extendible hashing remains feasible identity used address computation function h case data accessible processed sequentially order defined domain h preserve order word hashing place directory resides central memory data bucket disk implementing virtual memory organized form radix tree unbounded size contrast conventional virtual memory address space grows end address space grow virtual radix tree example consider domain x character string length say assume element stored sampled according distribution letter english word obtain approximate distribution counting page dictionary exhibit encode blank z example code quintuple zero pad address computation function h identity map z address computation function support useful type operation example range query list alphabetic order word stored algorithm data structure global text address computation exhibit relative frequency word beginning given letter webster dictionary page word starting x page word starting s suggests active address space partitioned equally sized interval interval populated time densely translates directory time larger necessary uniform distribution directory grow power time larger sound like lot bearable following estimate assume store record disk avera ge occupancy record bucket requiring bucket uniform distribution generates directory entry bucket total entry say byte nonuniform distribution requires number bucket generates directory entry pointer requires byte amount mbyte memory requirement application require today personal computer application warrant reservation mbyte memory small price pay large data set extendible hashing approximates ideal characteristic special case discussed chapter section special case small key domain take disk central memory size standard today practically infeasible decade ago impossible decade ago unthought decade ago exercise programming project perfect hash table element name al fl ga nc sc va distinguished ordered pair uppercase letter solve problem name stored array t easily mean hash function type addr pair record z end var t array addr pair write function h pair adr map name different address range book licensed creative common attribution license b write procedure inittable initializes entry hash table c write function member pair boolean return pair uppercase letter stored hash function h x x mod table having entry collision hash table resolved coalesced chaining demonstrate insertion element inserting key hash table length m using open addressing hash function h x x mod result inserting element using linear probing b double hashing second hash function g x x mod dictionary supporting operation hash table double hashing dictionary supporting operation preserving extendible hashing algorithm data structure global textthis book licensed creative common attribution license metric data structure learning objective embedding space versus organizing content octtrees grid file principle geometric object parameter space query arbitrary shape complex object enclosing simple container organizing embedding space versus organizing content data structure discussed far organize set element stored depending primarily exclusively relative value element order insertion data structure assumption element drawn ordered domain structure support comparative search technique search argument compared stored element shape data structure based comparative search varies dynamically set element currently stored doe depend static domain element sample technique organize particular content stored embedding space data structure discussed chapter mirror organize domain element structure determined element inserted typically basis fixed point reference independent current content inch mark measuring scale independent measured reason data structure organize embedding space metric data structure increasing importance particular spatial data needed design geographic data processing typically domain exhibit richer structure mere order euclidean space example order defined line just coordinate ax distance point query spatial data involve absolute position element space just relative position typical query graphic example asks object intercepted given ray light computing answer involves absolute position location ray relative order nearest ray data structure support direct access object according position space clearly efficient based merely relative position element term organizing embedding space organizing content suggest extreme spectrum possibility seen previous chapter data structure hybrid combine feature distinct type particularly true metric data structure aspect address computation needed locate element space use list processing technique efficient memory utilization algorithm data structure global metric data structure radix tree try encountered binary radix tree possible implementation chapter section extendible hashing radix tree branching factor greater ubiquitous dewey decimal classification used library radix tree hierarchical structure textbook including seen radix tree determined subsection depth d packed section depth example consider try type radix tree permit retrieval data traverse tree check node visiting successor trie long certain path example consider trie containing word english language exhibit word shown explicitly letter word letter word field corresponding contains value signaling spelled valid word pointer longer word beginning letter b word marked beginning word following pointer string word beginning word field contains pointer exhibit radix tree alphabet letter store prefix word word begin long one wasteful introduce additional node character just record word making significant use provided node try typically use overflow technique handle long entry pointer field prefix point text field contains lectasis lier quadtrees octtrees consider square recursively partitioned quadrant exhibit show square partitioned depth quadrant depth separated thickest line quadrant separated slightly thinner line quadrant separated thinner line finally leaf quadrant separated thinnest line partitioning structure described quadtree particular type radix tree root corresponds entire square child quadrant depth shown exhibit book licensed creative common attribution license exhibit quarter circle digitized grid representation quadtree quadtree obvious analog binary radix tree seen accordingly quadtrees frequently used represent store process spatial data image figure show quarter circle digitized grid pixel image easily represented array bit quadtree provides alternative representation advantageous image digitized high level resolution graphic image practice digitized rectangular grid hundred thousand pixel example quadtree largest quadrant constant color black white example represented explicitly subquadrants implicit quadtree exhibit interpreted follows child root northwest quadrant labeled simple entirely white fact recorded root child labeled contain black white pixel description simple contained quadtrees quadrant pointer subquadtrees emanate corresponding field root southwestern quadrant labeled turn quadrant depth labeled entirely white pointer emanate corresponding field node subquadrant contains black white pixel corresponding field contains pointer discussion introduced notation identify quadrant depth quadtree root identified null string quadrant depth d uniquely identified string d digit string interpreted various way number expressed base accessing processing quadtree readily reduced arithmetic addressing label root child grand child generation algorithm data structure global text metric data structure notice child node parent node div similar address computation used heap implicit data structure binary tree node child parent node obtained div exercise string radix digit path root node called path address node interpret path address integer significant digit integer label node depth d consecutively devise formula transforms path address address formula used store quadtree array data compression representation image quadtree compact representation bit map condition hold true image fairly large typically hundred pixel image large area constant value color quadtree quarter circle example node bit map image requires bit representation requires storage certainly quadtree store list node able hold pointer say byte pointer value indicating quadrant need refinement need bit indicate color quadrant white black total bit store quadtree pointer needed node relationship expressed address computation node reduced field conveniently stored bit byte implicit data structure leave unused hole memory quadtrees achieve data compression small image octtrees exactly idea space quadtrees space cube recursively partitioned octant using orthogonal plane spatial data structure objective constraint metric data structure used primarily storing spatial data point simple geometric object embedded multidimensional space important objective spatial data structure meet include handling large dynamically varying data set interactive application access object identified fully specified query processing proximity query region query arbitrary shape uniformly high memory utilization achieving objective subject constraint result managing disk large data set mean stored disk small fraction data kept central memory time data structure used central memory choice restricted come managing disk memory speed gap book licensed creative common attribution license phenomenon central memory organized smal l physical unit byte word access time approximately microsecond second disk organize large physical block byte access time ranging millisecond second compared central memory disk delivers data block typically time larger delay time greater term data rate delivered central processing unit disk storage device effectiveness order magnitude central memory large size physical disk block potential source inefficiency easily reduce useful data rate disk hundredfold thousandfold accessing couple byte disk say pointer needed traverse list take long accessing entire disk block game managing disk minimizing number disk access dynamically varying data majority computer application today interactive mean insertion deletion modification data frequent operation merely process fixed data data structure entail systematic degradation performance continued use overflow chain number cell marked deleted conventional hash table unsuitable structure automatically adapt shape accommodate content provide uniform response time instantaneous response interactive use computer set major challenge data management goal providing instantaneous response fully specified query fully specified mean attribute relevant search provided element satisfies query imagine user clicking icon screen object represented icon appears instantaneously human term instantaneous physiological quantity second limit human time resolution ideally interactive retrieves single element fully specified query second principle stated today technology disk access typically take ten millisecond goal retrieving single element second translates retrieve element disk access fortunately turn useful data structure designed access data process access correct portion directory access correct data bucket assumption data directory large stored disk principle proximity query region query arbitrary shape simplest example proximity query operation encountered data structure traversal given pointer element element successor predecessor accor ding order defined domain simple example interval range query x generalizes directly orthogonal range query query x geometric computation example instance proximity query important nearest neighbor direction intersection query object region query arbitrary shape just rectangular able express variety geometric condition algorithm data structure global metric data structure uniformly high memory utilization data structure adapts shape dynamically changing content likely leave unused hole storage space space currently unused conveniently used purpose fragmented encountered phenomenon multiway tree hash table practically unavoidable dynamic data structure use allocated space average space utilization tolerable danger avoid bias drive space utilization file deleted space relinquished grid file discussed achieves average memory utilization regardless mix insertion deletion grid file grid file metric data structure designed store point simple geometric object multidimensional space achieve objective stated section describes architecture access update algorithm property detail nh hin scale directory bucket consider example domain cartesian product subrange integer x z ordered set character english alphabet pair form w element domain bit map natural data structure storing set s element declared var t array boolean convention t true basic set operation performed direct access array element corresponding element x simply boolean expression t x insert equivalent t x delete equivalent t bit map small domain requires affordable bit bit map realistic example rarely affordable following reasoning show consider x y just key record hold additional data space reserved array additional data array element bit byte needed absent record element x s waste lot storage second domain larger example euclidean space example element x y z taken triple integer number requires bit map bit respectively comparison sake large disk bit large bit map extremely sparsely populated amenable data compression grid file best understood practical data compression technique store huge sparsely populated bit map support direct access returning example imagine historical database indexed year birth letter scientist von neumann v database pictured cloud point domain shown exhibit scientist record recent year density increase right storing database implies packing record bucket fixed capacity hold c c record figure show domain partitioned orthogonal hyperplanes grid cell contains c point book licensed creative common attribution license exhibit cell grid partition adapt size cell populated c point grid file database contains following component scale domain currently partitioned directory array element correspondence grid cell entry point data bucket hold record corresponding grid cell access record v proceeds step transform key value array index v scale contain small amount data kept central memory step requires disk access index tuple provides direct access correct element directory directory large occupy page disk compute address correct directory page disk access retrieve correct directory element directory element contains pointer disk address correct data bucket v second disk access retrieves correct record v john von neumann disk utilization grid file doe allocate separate bucket grid cell lead unacceptably low disk utilization exhibit suggests example grid cell right directory share bucket bucket sharing come maintained splitting overflowing bucket merging sparsely populated bucket shown following algorithm data structure global text metric data structure exhibit search record key value v start scale proceeds directory correct data bucket disk dynamic splitting merging dynamic behavior grid file best explained tracing example effect repeated insertion file instead showing grid directory element correspondence grid block draw bucket pointer originating directly grid block initially single bucket capacity c example assigned entire domain exhibit bucket overflow domain split new bucket b available record lie half space moved old bucket new exhibit bucket overflow grid block left half space split according splitting policy assume simplest splitting policy alternating direction record lie grid block exhibit moved new bucket notice bucket b did overflow left region consists grid block effective memory utilization essential process refining grid partition need necessarily split bucket region split exhibit growing grid file start single bucket allocated entire key space book licensed creative common attribution license exhibit overflowing bucket trigger refinement space partition exhibit bucket split c content b remain unchanged assuming record arriving corner space bucket c overflow trigger refinement grid partition shown exhibit splitting bucket c c history repeated splitting represented form binary tree imposes set bucket currently use set region bucket twin called buddy bucket region unique twin split exhibit c d twin pair c d twin pair c d b twin exhibit bucket region span cell ensure high disk utilization deletion trigger merging operation contrast storage sufficient merge bucket split earlier merging policy multidimensional grid file need general order maintain high occupancy algorithm data structure global text metric data structure simple geometric object parameter space consider class simple spatial object aligned rectangle plane side parallel ax class object defined small number parameter example aligned rectangle determined center cx cy dx dy object defined class k parameter considered point parameter space example aligned rectangle point space geometric topological property object deduced class belongs coordinate corresponding point parameter space different choice parameter space class object appropriate depending characteristic data processed consideration determine choice parameter location parameter extension parameter class simple object reasonable distinguish location parameter center cx cy aligned rectangle extension parameter dx dy distinction possible object described cartesian product sphere various dimension example rectangle product sphere cylinder product dimensional sphere distinction search region generated proximity query described section simple intuitive interpretation subspace location parameter act mirror reflects query parameter uniform distribution example consider class interval straight line interval represented left right endpoint lx rx constraint lx rx restricts representation interval point lx rx triangle diagonal data structure organizes embedding space data point opposed particular set point stored pay overhead representing unpopulated half embedding space coordinate transformation distributes data embedding space lead efficient storage phenomenon nonuniform data distribution worse application building block complex object built smaller space embedded size brick small compared size house parameter lx rx locate boundary object highly dependent exhibit show short interval long line clustering diagonal leaving large region large embedding space unpopulated set interval represented location parameter cx extension parameter dx fill smaller embedding space uniform way assumption bounded dx data distribution easier handle book licensed creative common attribution license exhibit set interval represented different parameter space region query arbitrary shape intersection basic component proximity query deserves special attention cad design rule example require different object separated minimal distance equivalent requiring object surrounded rim intersect given subset γ class simple spatial object parameter space h consider type query query given query point q object γ q set query given query set q point object γ intersect point query query point q compute region h contains point representing object γ overlap q class interval straight line interval given center cx half length dx overlap point q coordinate qx cx dx qx cx dx class aligned rectangle plane parameter cx cy dx dy treated cartesian product class interval exhibit rectangle contain given point q represented point space lie cartesian product query region region shown projection dx plane plane algorithm data structure global text metric data structure exhibit set aligned rectangle represented set point parameter space point query transformed region query class circle plane represent circle point space coordinate center cx cy radius r parameter circle overlap point q represented corresponding space point lie cone vertex q shown exhibit axis cone parallel extension parameter vertex q considered point plane subspace location parameter exhibit search cone point query circle plane point set query given query set q point region h contains point representing object γ intersect q union region h result point query point q union cone particularly simple region h query set q simple spatial object book licensed creative common attribution license class interval straight line interval cx dx intersects query interval q cq dq representing point lie shaded region shown exhibit region given inequality cx dx cq dq cx dx cq dq exhibit interval query union point query get transformed search cone class aligned rectangle plane treated cartesian product class interval q aligned rectangle rectangle intersect q represented point space lying cartesian product interval intersection query region class circle plane circle intersect line segment l represented point lying solid shown exhibit solid obtained embedding l plane subspace location parameter moving cone vertex q algorithm data structure global text metric data structure exhibit search region union cone evaluating region query grid file seen proximity query spatial object lead search region significantly complex orthogonal range query grid file allows evaluation irregularly shaped search region way complexity region affect cpu time disk access limit performance data base implementation query region q matched scale converted set index tuples refer entry directory preprocessing access disk retrieve correct page directory correct data bucket region intersect q exhibit exhibit cell grid partition overlap arbitrary query region q determined merely looking scale interaction query processing data access point preceding section metric data structure intricate computation triggered proximity query preprocessed remarkable extent object involved retrieved book licensed creative common attribution license query preprocessing involve significant computation based small amount auxiliary data scale query kept central memory final access data disk highly selective data retrieved high chance answer contrast approach object accessed number geometric information location space included record object accessing mechanism database object retrieved order determine one answer query given disk access bottleneck database application pay preprocess query possible order save disk access integration query processing accessing mechanism developed preceding section possible assumption simple object instance described small number parameter faced large number irregularly shaped object complex irregularly shaped spatial object represented approximated simpler one variety way example decomposition quad tree tessellation figure disjoint raster square representation cover overlapping simple shape enclosing object container chosen class simple shape container technique allows efficient processing proximity query preserve important property access spatial object particular doe break object component processed separately eliminates potential test unnecessary container intersect object wo example consider finding polygon intersect given query polygon given enclosed simple container circle aligned rectangle testing polygon intersection expensive operation compared testing container intersection cheap container test excludes polygon expensive detailed intersection check approximation technique limit primitive shape stored type example aligned rectangle box instance type determined parameter coordinate center extension considered point parameter space transformation reduces object storage point storage increasing dimensionality problem loss information combined efficient data structure point storage basis effective implementation database spatial object exercise quadtrees pixel rectangle b c outlined exhibit algorithm data structure global metric data structure exhibit location congruent object greatly affect complexity quadtree representation grid file store point lying domain cartesian product subranges integer bucket capacity point insert point initially grid file state scale directory bucket insert operation bucket split shape remain quadratic possible b delete point grid file obtained state scale directory bucket delete operation assume deleting point bucket bucket merged neighbor bucket joint occupancy doe exceed point boundary removed scale longer bucket split respect boundary c imposing restriction deadlock situation occur sequence delete operation bucket merge neighbor resulting bucket region longer rectangular example shown exhibit shaded oval represent bucket region devise merging policy prevents deadlock occurring grid file book licensed creative common attribution license exhibit example show bucket region merged pairwise class circle plane represented point parameter space proposed chapter section region query arbitrary shape search region parameter space circle intersecting given circle c b circle contained c c circle enclosing algorithm data structure global text book licensed creative common attribution license vi interaction algorithm data structure case study geometric computation organizing processing euclidean space iii presented varied sample algorithm use simple static data structure v dedicated dynamic data structure presented corresponding access update algorithm final illustrate use dynamic data structure presenting algorithm efficiency depends crucially particular priority queue dictionary choose algorithm computational geometry recently developed discipline great practical importance application computer graphic design geographic database data structure tool organizing set data relationship geometric data processing pose challenging test ability organize data embedded euclidean space way reflect rich relationship location touching intersecting contained distance utmost importance efficiency algorithm processing spatial data data structure developed traditional commercial data processing based concept primary key subordinate secondary key asymmetry fails support equal role played cartesian coordinate ax x y z euclidean space spatial axis say x identified primary key danger query involving ax say y z inordinately cumbersome process slow sake simplicity concentrate geometric problem particular highly successful class sweep algorithm sweep algorithm remarkably good job processing space efficiently using distinct data structure organizing algorithm data structure global textthis book licensed creative common attribution license sample problem algorithm learning objective nature geometric computation problem algorithm chosen illustrate variety issue encountered hull yield simple efficient algorithm straightforward implement analyze special property convexity simpler process general object problem surprisingly complex complexity doe design algorithm sneak analysis geometry geometric computation classical geometry shaped ancient greek axiomatic constructive emphasizes axiom theorem proof algorit hm typical statement euclidean geometry assertion geometric configuration certain property theorem pythagoras triangle square hypotenuse c equal sum square catheti b assertion existence parallel axiom given line l point p l exactly line parallel l passing p constructive solution problem occur theorem impossibility constructive solution steal glory trisect arbitrary angle using ruler compass proverbial impossible square circle computational geometry hand start problem construction simple dismissed trivial given n line segment plane free intersection compute construct intersection problem trivial respect existence constructive solution soon question far trivial interpreted efficiently obtain answer computational geometry appealing feature make ideal learning algorithm data structure problem statement easily understood intuitively meaningful mathematically rigorous right away student try hand t solving having worry hidden subtlety lot required background knowledge b problem statement solution step construction natural visual representation support abstract thinking help detecting error reasoning c algorithm practical easy come example applied appealing geometric computation writing geometric program demanding task trap lie hiding obvious combinatorial intricacy mastered particularly dangerous occur degenerate configuration b pitfall numerical computation discretization rounding error degenerate configuration discussed straight line circle algorithm data structure global sample problem algorithm intersecting line segment special case require special code easy envision kind degeneracy occur given problem configuration degenerate specific algorithm nondegenerate different algorithm solving problem rounding error tend cause obviously disastrous consequence geometric computation say linear algebra differential equation traditional analysis rounding error focus bounding cumulative value geometry concerned primarily stringent question error impaired topological consistency data remember pathology braided straight line vi aim introduce reader central idea technique computational geometry simplicity sake limit coverage euclidean geometry problem lot complicated configuration focus type algorithm remarkably suited solving problem efficiently sweep algorithm illustrate generality effectiveness use solve distinct problem sweep algorithm different problem assembled building block skeleton sweep program sweep line plane based queue event processed transition procedure update data structure dictionary table structure event maintain geometric invariant sweep convincingly dynamic data structure v essential efficiency problem algorithm discus deal simple object point line segment application geometric computation cad hand typically deal complex object thousand polygon simplicity algorithm doe deter utility complex object processed broken primitive part point line segment triangle algorithm present basic subroutine geometric computation play role analogous square root routine numerical computation called untold time correct efficient convex hull multitude algorithm problem computing convex hull h s set s consisting n point plane serf example demonstrate technique computational geometry yield concise elegant solution presented algorithm animation convex hull set s point plane smallest convex polygon contains point s interior boundary imagine nail sticking point tight rubber band surrounding set nail different algorithm solve simple problem present algorithm form basis program chapter briefly illustrate main idea convex hull algorithm initialization step us fact easily identify point s lie convex hull h s example point p min pmax minimal maximal respectively algorithm grow convex hull increasing subset use segment degenerate convex hull start algorithm use segment partition s upper lower subset compute upper lower hull h s separately jarvis march jar start point h s say p min computing point p tangent s characterized property point s lie pq book licensed creative common attribution license exhibit approach building convex hull come mind sort point s according use median coordinate partition s left half s l right half sr apply convex hull algorithm recursively half merge solution h s l h sr computing common exterior tangent h sl h sr exhibit terminate recursion set point exhibit applies problem spatial data quickhull byk edd g us different way start point convex hull h s say p min pmax general know point h s say p q r exhibit define convex polygon contained h s draw appropriate picture just point pmin pmax convex hull point s shaded sector extend outward vertex current polygon pqr example point s lie polygon pqr region extending outward s ides exhibit point known lie convex hull identify region devoid point pq exhibit let t point farthest pq region extending outward pq t lie convex hull easily seen considering algorithm data structure global text sample problem algorithm parallel pq pass having processed pq extend convex polygon include t process additional side pt tq reader observe formal analogy quicksort sorting complexity quickhull given exhibit point t farthest identifies new region exclusion shaded incremental scan sweep sort point s according use segment pminpmax partition s upper subset lower subset shown exhibit simplicity presentation reduce problem computing h s separate problem computing upper hull u s upper h s shown bold lower hull l s drawn line notation picture chosen u s exhibit separate computation upper hull lower hull let pn point s sorted let u u pi upper hull point serve initialization n compute u exhibit show starting tentative tangent shown dashed line retrace upper hull u reach actual tangent example bold dashed line tangent characterized fact j minimizes angle j pipj vertical book licensed creative common attribution license exhibit extending partial upper hull u p point pi program presented algorithm animation example algorithm animation written algorithm reading data starting computation accepts point time lie right previous one immediately extends hull u obtain ui thanks input restriction point entered sorted order simpler run linear time explains main body pointzero set point initializes necessary variable nextright computetangent remain programming detail best explained relating fig declaration varx y dx dy array nmax integer b array nmax integer backpointer n integer number point entered far px py integer new point coordinate point pi stored array x storing angle j store quantity proportional co j sin ai j array dx dy array b hold pointer retracing upper hull left b j implies p j predecessor p ui explains key procedure program procedure computetangent pn px py var integer begin b n dy n dx dy dx n begin dy n n dy b algorithm data structure global text sample problem algorithm dx n x n x dy n y n y moveto px py line n n b n end moveto px py pensize line n n pennormal end computetangent algorithm implemented based graham scan gra point ordered according angle seen fixed internal point us convexity basic operation polygon convex hull set point object smallest convex set contains object model problem geometric computation algorithm application stated introductory section application geometric computation tend deal complex object consist thousand primitive part point line segment triangle effective approximate complex configuration simpler particular package container simple shape proximity query answered processing container frequent query computer graphic example asks object struck given ray ray miss container infer miss object looking ray hit container start costly analysis object convex hull effective container simple rectangular box say convexity strong geometric property algorithm time o n arbitrary polygon n vertex require time o log n convex polygon let list example assume polygon g given cyclic sequence n vertex n edge trace closed path plane polygon intersecting simple polygon simple polygon partition plane region interior simply connected exterior hole test given simple polygon g query point p g determine p lie inside outside polygon closely related algorithm walk polygon solve problem time o n computes winding number g imagine observer p looking vertex say v walk start turning heel watching walker exhibit observer make positive turn α followed negative turn β followed walker return starting vertex sum α β turning angle complete tour g π p inside g p outside book licensed creative common attribution license exhibit polygon test adding turning angle second algorithm computes crossing number g respect draw ray r p direction exhibit walk polygon g arbitrary starting vertex v v track current oriented edge intersects r edge cross r sum number p inside g p outside exhibit polygon test adding crossing number test convex polygon q use binary search perform test time o log n consider hierarchical decomposition q illustrated convex shown exhibit choose approximately equidistant vertex vertex innermost core triangle painted black equidistant refers euclidean distance number vertex traversed traveling perimeter query point p ask time o seven region defined extended edge triangular core contains seven region shown exhibit triangle albeit extend infinity sense defined intersection region provide definite answer query p inside q outside q region shown hatched exhibit provides answer answer remaining region labeled lead recursively new test query point p new convex polygon q algorithm data structure global text sample problem algorithm intersection q uncertain region q n vertex depth recursion o log n actually comparison innermost triangular core q longer general problem additional information make test step binary search exhibit hierarchical approximation convex tree triangle root black child dark grey grandchild light grey exhibit plane partitioned region certainty uncertainty processed recursively visibility plane simple algorithm analysis computer graphic program dominated visibility problem given configuration object space given point view visible dozen algorithm surface elimination developed solve everyday problem visual performs glance contrast problem discussed visibility surprisingly complex hint complexity describing detail buried smooth surface simple version computing visibility line segment plane problem given n line segment plane compute sequence sub segment seen observer infinity say y book licensed creative common attribution license complexity problem unexpected discovered w fortunately complexity revealed requiring complicated algorithm analysis inherent complexity geometric problem example shown exhibit illustrates input data endpoint p line segment labeled given point computed algorithm required result list visible segment segment described endpoint identifier line exhibit example line segment seen generate seven visible subsegments search algorithm reader encouraged work detail idea come mind ordered pair li lj line segment remove l subsegment occluded l li cut n piece managed sequence subsegments finding endpoint lj sequence time o log n leading overall algorithm time complexity o log n reader mastered sweep algorithm line intersection presented purpose algorithm problem illustrated using line segment intersection straightforward application line visibility problem requires time o n k log n k o number intersection appears work algorithm doe organized systematic fashion keep track intersection invisible potential work time o n log n realistic data configuration characterized k o n worst case yield simple visibility algorithm better performance n problem trivial n partition set n line segment approximate half solve subproblems merge result constraint set halved divide step easy conquer step taken care recursion merging amount computing minimum piecewise necessarily continuous linear function time linear number piece example n shown exhibit illustrates algorithm f visible segment f segment min f segment exhibit algorithm data structure global text sample problem algorithm exhibit line segment partitioned subset exhibit min operation merges solution algorithm time complexity algorithm obtained follows given level recursion relevant set line segment partitioned approximate half depth recursion o log n merge step process v visible subsegments take linear time o v merge step book licensed creative common attribution license given depth process v subsegments v total number visible subsegments total time bounded o v log n large v surprising theoretical result let v n number visible subsegments given configuration n line size output visibility computation tiny n worst case v v shown exhibit attempt configuration general n lead example shown figure v n exhibit configuration largest number visible subsegments figure family configuration visible subsegments difficult come class configuration v n grows faster tempting conjecture v n o n conjecture hard prove good reason false discovered w turn v n θ n α n α n inverse ackermann function computability complexity exercise monotonically increasing function grows slowly practical purpose treated constant let present step surprising result arrived occasionally simple geometric problem tied deep result branch mathematics transform visibility problem combinatorial string problem numbering given line segment walking algorithm data structure global text sample problem algorithm left right writing number line segment currently visible obtain sequence number exhibit exhibit sequence associated configuration segment geometric configura tion give rise sequence um following property ui n m number identify line segment m consecutive number equal index b c d e m ua uc ue r ub ud s r condition capture geometric property intersecting straight line r s r s possibly separated r imply r s intersect mo exhibit exhibit subsequence r s r s excludes occurrence example sequence example show m n n n n n n book licensed creative common attribution license sequence property called sequence studied context linear differential equation maximal length sequence k n α n k constant α n inverse ackermann function computability complexity exercise h increasing n α n approach infinity albeit slowly dampens hope linear upper bound visibility problem doe disprove conjecture need inverse given sequence exists corresponding geometric configuration yield sequence explicit construction given w establishes isomorphism visibility problem sequence show size output visibility problem superlinear result challenge geometric intuition exercise set point s prove pair point farthest vertex convex hull h s model computation operation addition multiplication comparison available unit cost prove model ω n log n lower bound computing order vertex convex hull h s set s n point hint algorithm computes convex hull n given point used sort n number second algorithm test chapter section us convexity basic operation polygon computes crossing number polygon g point p addressing special case arise ray r emanating p intersects vertex g overlap edge arbitrary necessarily simple polygon g exhibit provide interpretation winding number w g p g arbitrary point p g prove w g p p equal crossing number p respect ray r emanating exhibit winding number crossing number polygon g respect algorithm computes area simple necessarily convex polygon θ n time consider problem computing intersection convex polygon given list vertex cyclic order intersection convex polygon b design algorithm computes intersection time complexity algorithm algorithm data structure global text sample problem algorithm test line l convex polygon q infinitely extended line l intersects polygon q intersect q edge test intersection given line l polygon reduced repeated test l intersection q edge prove general test intersection check n q edge hint use adversary argument edge remain unchecked moved invalidate answer b design test work time o log n decoding line l intersects convex polygon q algorithm divide space data embedded set data set line algorithm computing sequence visible segment partition space recursively vertical stripe stripe simple choose boundary stripe state advantage disadvantage algorithm compared described chapter section visibility plane simple algorithm analysis analyze asymptotic time complexity algorithm book licensed creative common attribution license purpose algorithm dimensional problem illustrated using line segment intersection learning objective segment intersection test space dimension time dimension y table detecting intersection intersection algorithm schema geometry great generality effectiveness algorithm designer advised try work surprisingly large set problem work tends efficient easiest understand assumption nondegenerate configuration explaining assumption remark degenerate case handled line segment intersection test present algorithm sh line segment intersection test given n line segment plane determine intersect compute witness pair segment intersect bound complexity problem easily obtained literature computational geometry p prof lower bound ω n log n obvious brute force approach testing n n pair line segment requires θ time wide gap n log n challenge algorithm designer strives optimal algorithm asymptotic running time o n log n match lower bound attempt design algorithm nd come variant illustrated fig divide data case set line segment subset approximately equal size n line segment divide embedding space easily cut exact half algorithm data structure global algorithm problem illustrated using line segment intersection exhibit way applying set object embedded plane case hope se paration subset s permit efficient test line segment intersects line segment s exhibit show ideal case s interact course achieved nontrivial way s separated figure suggests finding separating line look like formidable problem original intersection problem general test line segment s line segment s test θ time second approach dividing embedding space unfortunate consequence effectively increasing data set segment straddle dividing line get cut processed twice half space resulting subproblems size n n respectively n n n worst case n n recursion depth d n subsegments process optimal algorithm known us technique key idea designing optimal algorithm observation line segment intersect vertical line l abscissa x totally ordered segment s lie segment t written s l t intersect l current position x intersection s l lie intersection t respect order line segment upper lower neighbor exhibit show s t neighbor exhibit sweep line l totally order segment intersect intersection test algorithm assumption configuration nondegenerate segment intersect point simplicity sake assume segment vertical segment left endpoint right endpoint assumption entail loss generality vertical segment arbitrarily define lower endpoint left endpoint imposing lexicographic x y refine important assumption line segment s t ca n intersect exists abscissa x s t neighbor book licensed creative common attribution license suffices test segment pair neighbor time sweep l number usually significantly smaller n n sweep line l move left right configuration order l line segment intersecting l change endpoint segment intersection segment intend stop sweep soon discover intersection need perform intersection test left right endpoint segment segment t tested left endpoint intersection lower upper neighbor right endpoint t test lower upper neighbor intersection exhibit algorithm terminates soon discover intersecting pair segment given n segment exhibit pairwise intersection test charged segment generate intersection test shown exhibit left right endpoint perform o pairwise segment intersection test n time linear bound number pair tested intersection raise hope finding algorithm far counted geometric primitive doe pair segment intersect yes hiding background bookkeeping operation upper lower neighbor given segment turn costlier geometric one neighbor efficiently maintaining order l data structure called table entire sweep skeleton turning space dimension time dimension derived image sweeping plane left right vertical line cross section stopping transition point event geometric configuration update cross section processing moving backtracking point event stored current cross section maintained skeleton algorithm follows initx inity emptyx e nextx transition e procedure initialize return event queue tell procedure advancing mechanism sweep embodies work new event encountered move slice left event e slice immediately right data structure line segment intersection test store left right endpoint given line segment ordered rdinate event processed updating vertical cross section endpoint store reference corresponding line segment compare point building algorithm data structure global text algorithm problem illustrated using line segment intersection simplicity presentation assume endpoint line segment equal coordinate operation performed return event left right endpoint line segment processed cost initializing o n log n cost performing operation o contains line segment currently intersected sweep line ordered according l slice event order doe change need updating exhibit dictionary support operation entering left endpoint line segment s place s inserted ordering comparing s line segment t stored determine s l t t l s determining t left endpoint s lie seen chapter section intersection tends efficient computing comparing intersection point s t sweep line implement dictionary balanced tree avl tree operation performed o log n time performed o t ime additional pointer node tree point successor predecessor line segment stored node n event n line segment space complexity algorithm o n exhibit record varying state sweep line updating detecting intersection procedure maintains order l line segment intersecting sweep line performs intersection test left endpoint segment t t inserted tested intersection lower upper neighbor right endpoint t t deleted neighbor tested algorithm terminates intersect ion event processed finding intersection procedure transition e event begin s segment e leftpoint e begin inserty s book licensed creative common attribution license intersect predy s s intersect s succy s terminate end e right endpoint s begin intersect predy s succy s terminate deletey s end end n event costing time o log n algorithm need o n log n time perform line segment intersection test sweeping intersection algorithm line segment intersection test easily adapted following general problem bo given n line segment report intersection addition left right endpoint store intersection point event intersection detected inserted event processed sweep line reach intersection event participating line segment swapped exhibit major increase complexity compared segment intersection test process n event n k event k number intersection discovered sweep plane configuration n segment vertical n horizontal show worst case k θ lead o log n algorithm certainly improvement comparison pair realistic configuration say engineering drawing number intersection o informative introduce parameter k order bound com plexity algorithm bound adapts data needed report result computation exhibit sweeping intersection change comparatively minor priority queue support operation implemented heap cost initializing remains o n log n analysis presume storage requirement o n k implies cost calling remains o log n k o detailed analysis p show size exceeds o n log n slight modification algorithm bro algorithm data structure global text algorithm problem illustrated using line segment intersection guaranteed size exceeds o n cost exchanging intersecting line segment o log n cost operation remain n left right endpoint k intersection event total cost algorithm o n k log n realistic application characterized k o n reporting intersection remains o n log n algorithm practice algorithm find int ersecting pair line segment o n log n k time using o n k storage space described ce degenerate configuration numerical error robustness discussion based assumption nondegeneracy minor major importance let examine type access used implicit assumption event endpoint intersection equal order processing event equal irrelevant assuming event coincide point plane lexicographic x y convenient systematic way define form degeneracy arise event coincide plane segment intersecting point type degeneracy particularly difficult handle presence numerical error rounding error configuration shown exhibit endpoint u lie exactly nearly segment care intersection routine answer question s u intersect certainly expect asking t u intersect example show slightest numerical inaccuracy cause error algorithm fail report intersection t u clearly bothered look algorithm look way asks question t u intersect exhibit degenerate configuration lead inconsistent result trace reporting intersection look follows inserted inserted s s t tested intersection intersection inserted s evaluation function s x conclude left endpoint u lie s s u tested intersection intersection routine conclude s u intersect u remains s book licensed creative common attribution license u s t notice calamity struck critical step evaluation linear expression s x intersection routine segment arrived result isolation reasonable tolerance underlying arithmetic result inconsistent evaluation s x concludes left endpoint u lie s intersection routine conclude s u intersect geometric primitive fail coordinate answer catastrophe strike example u t neighbor intersection get lost exercise θ intersection set n line segment algorithm determines o n log n time simple polygon total n vertex intersect algorithm determines o n log n time disk set n disk intersect algorithm solves line visibility problem discussed chapter section visibility plane simple algorithm analysis time o n k log n k o number intersection line segment configuration smallest possible number line segment intersection point reported algorithm chapter section sweeping intersection leftmost intersection point algorithm presented chapter section sweeping intersection detect intersection given set n horizontal vertical line segment assume line segment overlap time complexity algorithm horizontal vertical line segment intersect k point algorithm find intersection given set n rectangle side parallel coordinate ax time complexity algo rithm algorithm data structure global closest pair closest pair learning objective implementing analyzing plane sweep plane sweep dimension sweep algorithm solve kind proximity problem efficiently present simple sweep solves closest pair problem elegantly asymptotically optimal time explain sweeping generalizes easily efficiently multidimensional closest pair problem problem consider closest pair problem given set s n point plane pair point distance δ smallest exhibit measure distance using metric d k k defined exhibit identify closest pair n point plane special case include manhattan metric d euclidean metric d maximum metric exhibit show circle radius centered point p metric exhibit result chapter remain valid distance measured various metric closest pair problem lower bound ω n log n algebraic decision tree model computation p solution obtained asymptotically optimal time o n log n special case general problem hn point nearest neighbor constructing voronoi diagram sh general approach powerful technique make resulting algorithm harder understand expect simply stated problem closest pair algorithm presented b solves closest pair problem directly optimal time complexity θ n log n using euclidean metric d recursive algorithm book licensed creative common attribution license involves intricate argument combining solution equally sized subset iterative algorithm hn us simple incremental update starting set point adding single point final solution entire set obtained similar algorithm solves closest pair problem set convex object bh applied closest pair problem skeleton general sweep algorithm presented chapter section skeleton turning space dimension time dimension data structure adapted closest pair problem shown exhibit store point set s ordered event processed updating vertical cross section pointer partition s disjoint subset discarded point left accessed longer active point inclusive exclusive queried current transition point p processed future point looked store active point ordered exhibit updating invariant point p processed need compare point building sweeping simplicity presentation assume point equal point equal handled imposing arbitrary consistent total order set point achieve defining lexicographic order x used y algorithm data structure global text closest pair program following section initializes leftmost point active δ equal distance start sweep point distinction discarded active point motivated following argument new point p encountered wish answer question point form closest pair point left pair closest point seen far corresponding minimal distance candidate form new closest pair point p sweep line lie half circle centered p radius key question answered striving efficiency retrieve quickly point seen far lie inside half circle left p order compare distance p minimal distance δ seen far use helpful data structure organizes point seen far long update data structure efficiently transition circle query complex embedded algorithm organizes data according orthogonal coordinate rectangle query answered efficiently replace query bounding rectangle query accepting fact include extraneous point rectangle query exhibit implemented step cut point left distance δ sweep line point lie discarded easily advancing removing second consider point q vertical distance p δ point looking successor predecessor starting word maintain following invariant transition minimal distance pair point seen far discarded active active point stored ordered coordinate exactly lie interior left sweep line processing transition point p involves step point q qx px δfrom advancing right p point q δ looking successor predecessor point q distance p smaller δ update δ closest pair far implementation following implementation realized array contains point sorted coordinate pair closest point far n number point consideration t c determine position xqueue array maxn point closestleft closestright point t c n maxn book licensed creative common attribution license initialized procedure initx store point ordered coordinate created procedure inity new point inserted procedure inserty p point point deleted procedure deletey p point successor point returned function succy p point point predecessor point returned function predy p point point initialization follows initx inity closestleft xqueue closestright xqueue delta distance closestleft closestright inserty closestleft inserty closestright c event processed loop c n begin transition c c event end procedure encompasses work new point procedure transition begin step remove point outside current xqueue c xqueue t delta begin deletey xqueue t t t end step insert new point inserty current step check successor new point check current repeat check succy check newdelta distance current check newdelta delta begin delta newdelta closestleft check closestright current end delta step check predecessor new point table check current repeat check predy check newdelta distance current check algorithm data structure global closest pair newdelta delta begin delta newdelta closestleft check closestright current end delta end transition analysis algorithm described implemented run time o n log n space o n implemented balanced binary tree operation performed time o log n space required o n build sorted time o n log n using space o n procedure called point accumulates o n log n point inserted call accumulate o n log n remains problem analyzing step loop step call number point upper half bounding box similarly loop step call number point lower half bounding box standard counting technique show bounding box sparsely populated metric d k box contains small constant number c k point k ck called time step cost time o log n key counting fact point closer δ packed bounding box side δ partition box pairwise disjoint mutually exhaustive region shown exhibit region half circle diameter δ manhattan metric argue case distance measured metric contain point contained point distance δ opposite end unique diameter se endpoint lie left right boundary bounding box boundary line contain point following reason active point located left boundary bounding box point thrown updated active point exist right boundary preempted transition point p processed remember assumption unequal book licensed creative common attribution license exhibit point pairwise distance δ populate box size δ shown bounding box hold point pairwise distance δ using manhattan metric d known point p q k d p q dk p q p q bounding box hold point pairwise distance δ using distance d k calculation predecessor successor transition point cost time o log n accumulates total o n log n transition summing cost result o n log n time o n space complexity algorithm ω n log n lower bound closest pair problem know algorithm optimal sweeping dimension gain insight power limitation sweep algorithm let explore algorithm presented generalizes space illustrate reasoning space conclusion hold number dimension following step generalize easily sort point according sweep space plane processing current transition point p assume know closest pair point left p distance determine p form new closest pair look point inside sphere radius δ centered p extending left hope implementing sphere query efficiently enclose half sphere bounding box length δ δ dimension inside box small constant number c k point pairwise distance δ using distance dk implement box query step cutting point farther left p δ advancing performing square query point currently table lie left sweep plane shown exhibit reached place ensional algorithm differs substantially case corresponding interval query implemented efficiently time o log n using predecessor successor operat ion balanced tree using knowledge size answer set algorithm data structure global text closest pair bounded constant case corresponding orthogonal range query general answered time o log n retrieved point using known data structure straightforward search requires time o n resulting overall time o space sweep interesting result problem admits trivial o algorithm comparing pair exhibit sweeping plane space idea generalize efficiency doe sweeping reduces dimensionality geometric problem replacing space dimension time dimension reducing problem sequence problem efficient total order defined dimension allows logarithmic search time contrast reducing problem sequence problem rarely result gain efficiency exercise following modification algorithm solving closest pair problem bh encountering transition point p process point q y δ test distance p successor predecessor smaller deleting point q q x px δ test successor predecessor q table closer pair point smaller distance current δ update δ closest pair far prove modified algorithm find closest pair time complexity algorithm algorithm solves closest pair problem time complexity algorithm hint partition set n point vertical line subset approximately n point solve closest pair problem recursively subset conquer step use fact δ smallest distance pair point belonging subset point left subset distance smaller δ point right subset point lie left right partitioning line match point lying left point lying right