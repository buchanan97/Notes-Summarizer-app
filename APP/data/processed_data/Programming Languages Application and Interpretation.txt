programming language application interpretation version second edition shriram krishnamurthi april introduction philosophy structure book language book say parsing lightweight half parser convenient shortcut type parsing completing parser coda look interpretation representing arithmetic writing interpreter did notice growing language taste desugaring extension binary subtraction extension unary negation adding function language deﬁning data representation growing interpreter substitution interpreter resumed oh wait s substitution environment introducing environment interpreting environment deferring correctly scope bad scope exposing environment function function expression value nested implementing closure substitution sugaring anonymity mutation structure variable mutable structure simple model mutable structure scaffolding interaction closure understanding interpretation box environment help introducing store interpreting box bigger picture variable terminology syntax interpreting variable design stateful language operation parameter passing recursion cycle procedure data recursive cyclic data recursive function premature observation explicit state object object inheritance object core object desugaring object named collection constructor state private member static member object dynamic dispatch member access design space go class prototype multiple inheritance mixins trait memory management garbage correct garbage recovery manual reclamation cost reclamation reference counting automated reclamation garbage collection overview truth provability central assumption convervative garbage collection precise garbage collection representation decision changing representation error changing meaning example desugaring language feature example syntax transformer function guard simple macro feature attempt guarding evaluation hygiene identiﬁer capture inﬂuence compiler design desugaring language control operation control web program decomposition later partial solution achieving statelessness interaction state style implementation desugaring converting example implementation core generator design variation implementing generator continuation stack tail call continuation language feature presentation language deﬁning generator deﬁning thread better primitive web programming checking program invariant statically type type static discipline classical view type simple type checker conditionals recursion code recursion data type time space type mutation central theorem type soundness extension core explicit parametric polymorphism type inference union type nominal versus structural system intersection type recursive type subtyping object type checking program invariant dynamically contract contract predicate tag type observation value contract syntactic convenience extending compound data structure contract observation contract mutation combining contract blame alternate application semantics lazy application lazy application example value cause evaluation interpreter laziness mutation caching computation reactive application motivating example timer callback type word alternative reactive language implementing transparent reactivity backtracking application searching satisfaction introduction philosophy watch video youtube someday textual description instead structure book unlike textbook doe follow narrative ﬂow conversation backtracking build program incrementally just pair programmer include mistake don t know answer best way learn including mistake make impossible read passively instead engage material sure veracity reading end ll right answer path frustrating short term tempted say just tell answer make book poor reference guide t open random page sure say correct feeling frustration sensation learning don t know way various point encounter exercise exercise try traditional textbook exercise s need using book course assigned homework contrast ﬁnd question look like s activity stop read think formulate answer proceed actually exercise answer text immediately following reading right determine running program just read ll answer having thought instruction run program test knowledge b improve intuition word additional explicit attempt encourage active learning ultimately encourage s practice language book main programming language used book racket like operating system racket actually support host programming language tell racket language programming inform unix shell writing line like script inform browser writing say doctype html public html similarly racket asks declare language using racket guages parenthetical syntax racket different semantics semantics different syntax different syntax semantics ery racket program begin lang followed language default s racket written racket book ll use drracket language choose language select use language declared source deviate ll say explicitly unless indicated lang ﬁle assume ve thetyped plai language differs traditional racket importantly ing statically typed give useful new construct test s example use introduce new additional command controlling output testing instance sure read documentation language drracket help help desk help desk search bar type misspelledanimal caml hump number yacc height number roughly think analogous following java abstract class misspelledanimal concrete caml andyacc numeric constructor argument named hump andheight respectively language construct instance follows caml yacc suggests creates type given use instance binding instance name define misspelledanimal caml define misspelledanimal yacc fact don t need particular type declaration typed plai infer type case just written define caml define yacc prefer write explicit type declaration matter discipline comprehensibility return program later type name used recursively repeatedly book instance section language provides use writing expression function s body define good ma misspelledanimal boolean misspelledanimal ma caml hump hump yacc height height expression hump instance hump given value given argument constructor caml finally write test case ideally ve deﬁned function protect accidental change test good t test good f run program language verbose output telling test passed read documentation learn suppress message s important obscured ve used hump height datatype deﬁnition ﬁelds match absolutely unnecessary related position written function define good ma misspelledanimal boolean misspelledanimal ma caml h h yacc h h visible case branch introduced h fact clash use convention readability dictate choice general make sense provide long descriptive deﬁning datatype probably won t use shorter name likely use use name time did just say unlikely use ﬁeld descriptor introduced datatype deﬁnition language provides selector extract ﬁelds need s easier use selector directly isn t deﬁning good just clear let s write define good ma misspelledanimal boolean cond caml ma ma yacc ma ma happens function wrong kind value instance caml constructor string send number version good say parsing parsing act turning input character stream structured internal representation common internal representation tree program recursively process instance given stream want tree representing addition left node represents number right node represents subtraction aparser responsible performing transformation parsing large complex problem far solved difﬁculties ambiguity instance alternate parse tree input expression subtraction addition want consider addition operation commutative order argument switched get worse programming language say natural language lightweight half parser problem make parsing worthy topic right entire book tool course devoted perspective parsing traction want study part programming language parsing exploit handy feature racket manage mation input stream tree read tied parenthetical form language parses fully unambiguously parenthesized term tree form instance running read parenthesized form produce list ﬁrst element symbol second element number element list list s ﬁrst element symbol second element number element number convenient shortcut know need test program extensively hard manually type term fortunately expect parenthetical syntax integrated deeply racket mechanism tion expr saw moment ago run read typed expr prompt course evaluates value read type parsing actually ve lied little said read equivalently using produce list s true regular racket typed plai type return distinct type called written typed plai read type racket rich language notation represent cyclic structure use simple fragment typed language treated distinctly type number list underneath large recursive datatype consists base printable string symbol printable collection list vector result base type like number symbol string type instance typing data fairly problematic discus later ref typed plai take simple approach written value like bers respective type written inside complex particular created read type cast native type instance symbol define l l l typecheck failed listof v quote l define f list l f similar casting java programmer insert study casting later ref observe ﬁrst element list treated type checker symbol list string f typecheck failed symbol v string f string f list l list casting doe trick string symbol f string need cast bit nuisance complexity able trying accomplish convert untyped input stream typed output stream robustly typed mean make explicit assumption input stream fortunately use parser goal away parsing quickly possible inducement away quicker completing parser principle think read complete parser output generic represents token structure offering comment intent instead prefer representation tell intended ingof term language just wrote beginning representing addition represents number ﬁrst introduce datatype capture representation separately discus section obtained datatype let s say s given arithc numc n number plusc l arithc r arithc multc l arithc r arithc need function convert instance datatype half parser define parse s arithc cond s numc number s s let sl list s case symbol sl plusc parse second sl parse sl multc parse second sl parse sl error invalid list input error invalid input parse arithc plusc multc numc numc plusc numc numc congratulation just completed ﬁrst representation program focus entirely program represented recursive tree ignoring vagary surface syntax tree form ﬁnally ready start studying programming language exercise happens forget quote argument parser coda racket s syntax inherits scheme lisp controversial observe deeply valuable parsing traditional guages complex parsing syntax virtually trivial given sequence token corresponding input absolutely straightforward turn parenthesized sequence equally straightforward turn expression proper syntax tree like language bicameral loose analogy government legislative house doe rudimentary checking doe deeper validity checking haven t ref virtue syntax manifold code requires small easily embedded context integrating syntax language easy program manipulate representation program ref s surprise syntax wildly different semantics share syntactic legacy course just use xml instead better json wouldn t like look interpretation representation program way want manipulate want display program attractive way convert code format compilation ask obeys certain property veriﬁcation going focus asking value corresponds evaluation reduction program value let s write evaluator form interpreter arithmetic language choose arithmetic ﬁrst reason know work focus mechanic writing evaluator b s contained language encounter later build upwards outwards c s small big illustrate point d like representing arithmetic let s ﬁrst agree represent arithmetic expression let s say want support addition primitive number need represent arithmetic expression rule govern nesting arithmetic expression actually free nest expression inside did include division impact doe remark ve ignored division force discussion expression consider legal clearly representation legal tation debatable versial d like sidestep controversy return later ref want representation number arbitrarily nestable addition multiplication s use arithc numc n number plusc l arithc r arithc multc l arithc r arithc writing interpreter let s write interpreter arithmetic language think type clearly consumes arithc value doe produce interpreter kind value arithmetic expression reduce number course interpreter going function arithmetic expression number exercise write test case interpreter recursive datatype natural structure interpreter recursive function s ﬁrst template template explained great design program define interp arithc number arithc numc n n plusc l r multc l r probably tempted jump straight code define interp arithc number arithc numc n n plusc l r l r multc l r l r spot error instead let s expand template step define interp arithc number arithc numc n n plusc l r interp l interp r multc l r interp l interp r ﬁll blank define interp arithc number arithc numc n n plusc l r interp l interp r multc l r interp l interp r later ref going wish returned complex datatype just number congratulation ve written ﬁrst interpreter know s nearly anticlimax ll soon promise did notice just slipped meaning addition multiplication new guage s pretty abstract question isn t let s make concrete kind addition computer science s different kind number bit integer signed plus integer arbitrary precision integer language rational various format number language complex number number chosen addition support combination addition language permit addition datatypes matrix furthermore language support addition string use don t really mean mathematical concept addition operation performed operator syntax language mean concatenation result numeric result number stored string different meaning addition semantics mapping syntax meaning brings ﬁrst game return question semantics ve adopted semantics racket provides map racket s fact s quite true racket know enable apply string ve chosen restriction racket s semantics number fact racket s t tolerate string wanted different semantics d implement explicitly exercise change number arithmetic general careful readily borrowing host guage ll return topic later ref growing language ve picked restricted ﬁrst language way grow representing data structure function clearly force add new feature interpreter assuming don t want use gödel numbering adding arithmetic disturbing core language interpreter ll examine section taste desugaring ve begun spartan arithmetic language let s look extend arithmetic operation expressed term existing one ll add just sufﬁce illustrate point extension binary subtraction ll add subtraction language number addition multiplication s easy deﬁne subtraction okay easy turn concrete code face decision doe new subtraction operator reside tempting natural just add rule existing arithc datatype negative consequence modifying arithc creates problem ﬁrst obvious modify program process arithc far s interpreter pretty simple complex implementation concern ond trying add new construct deﬁne term existing one feel slightly way isn t modular subtly s conceptually wrong modifying arithc s arithc represents core language contrast subtraction ditions represent surface language s wise record conceptually different idea distinct datatypes shoehorn tion look little unwieldy make program easier future developer read maintain different purpose want layer different extension separating core surface enables ll deﬁne new datatype reﬂect intended surface syntax term ariths nums n number plus l ariths r ariths bminuss l ariths r ariths mults l ariths r ariths look exactly like arithc added case follows familiar recursive pattern given datatype thing modify parser parse construct ariths term arithc one second implement desugar function translates ariths value intoarithc one let s write obvious desugar define desugar ariths arithc ariths nums n numc n plus l r plusc desugar l desugar r mults l r multc desugar l desugar r let s convert mathematical description subtraction code bminuss l r plusc desugar l multc numc desugar r s common mistake forget recursive call desugar onland happens forget try extension unary negation let s consider extension little interesting unary negation force little work parser depending surface syntax need look ahead determine unary binary case s interesting way desugar unary negation deﬁne naturally abstract desugaring binary subtraction expansion prefer s tempting pick ﬁrst expansion s simpler imagine ve extended ariths datatype representation unary negation uminuss e ariths implementation desugar straightforward uminuss e desugar bminuss nums e let s make sure type match observe eis aariths term valid use argument bminuss entire term legally passed desugar important notdesugar ebut embed directly generated term embedding input term recursively calling desugar common pattern desugaring tool called macro speciﬁcally macro deﬁnition uminuss problem deﬁnition ﬁrst recursion generative force extra care haven t heard generative recursion read section inhow design program essentially generative recursion computed function input structural piece especially simple case generative recursion function simple s just bminuss tempted ﬁx using different rewrite uminuss e bminuss nums desugar e doe eliminate generativity desugaring transformation won t work don t try run second implicitly depending exactly bminuss mean meaning change uminuss don t want contrast deﬁning functional abstraction consumes term generates representing addition ﬁrst time second using deﬁne desugaring uminuss andbminuss little tolerant say meaning subtraction going change bother yes yes s meaning unlikely change mentation instance developer decide log us binary subtraction macro expansion us unary negation logged second expansion fortunately particular case simpler option expansion work primitive follows structural recursion reason took detour alert problem warn fortunate adding function language let s start turning real programming language add intermediate feature conditionals interesting going need function moral equivalent let s exercise add conditionals language add boolean datatypes want quicker add conditional treat false true important test case write imagine modeling like drracket developer deﬁnes function deﬁnitions window us interaction window let s assume deﬁnitions deﬁnitions window ll relax soon ref expression interaction window running gram simply load deﬁnitions interpreter corresponds interaction window prompt ll assume supplied set deﬁnitions asetof deﬁnitions suggests ordering mean presumably deﬁnition refer s intend designing language sure think deﬁning data representation thing simple let s just consider function argument racket example define double x x x define quadruple x double double x define exercise function multiple argument simple important rion governs name argument part function deﬁnition double ple ll represent symbol double formal rameter orargument x model symbol x body ll determine body s representation stage let s start lay datatype function deﬁnitions fundefc fdc symbol arg symbol body exprc body clearly form arithmetic expression time represented using existing arithc language instance body represented numc representing body blerequires just addition x probably used calling variable notuse term instead identiﬁer promise ll return issue nomenclature later ref finally let s look body quadruple new construct function application careful distinguish function deﬁnition describes function application us us argument oractual parameter inner application double isx argument outer application double x argument complex expression let s commit crisp datatype clearly extending want arithmetic ll new datatype signify s growing exprc numc n number plusc l exprc r exprc multc l exprc r exprc identiﬁers closely related formal parameter apply function giving value parameter effect asking replace instance formal parameter identiﬁers formal value simplify process observe coy issue kind value ref replace ref use datatype represent ve chosen symbol represent formal parameter idc s symbol finally application part function s argument ve agreed argument expression including identiﬁers application function make sense use datatype did giving function function deﬁnition appc fun symbol arg exprc identifying function apply providing argument using deﬁnitions s instructive write representation ples deﬁned fdc double x plusc idc x idc x fdc quadruple x appc double appc double idc x fdc numc need choose representation set function deﬁnitions s convenient represent list look did notice spoke setof function deﬁnitions chose list representation mean using ordered collection data represent unordered entity testing use permutation deﬁnitions ensure haven t subtly built dependence growing interpreter ready tackle interpreter proper let s remind need consume previously consumed expression evaluate need list function deﬁnitions define interp e exprc fds listof fundefc number let s revisit old interpreter section case number clearly return number answer addition multiplication case need recur complex set function deﬁnitions use act evaluating expression add remove function deﬁnitions set deﬁnitions remains just passed unchanged recursive call exprc e numc n n plusc l r interp l fds interp r fds multc l r interp l fds interp r fds let s tackle application look function deﬁnition ll assume helper function type available symbol listof fundefc fundefc assuming ﬁnd function given need evaluate body remember said identiﬁers parameter replace process seen school algebra called substitution sufﬁciently important talk ﬁrst substitution returning interpreter section substitution substitution act replacing case formal parameter expression case body function expression case actual parameter let s deﬁne type subst exprc symbol exprc exprc help parameter informative name define subst exprc symbol exprc exprc ﬁrst argument want replace second want perform substitution expression want suppose want substitute identiﬁer xin body example function produce indouble produce inquadruple produce ble double produce substitution happens instance xin body common mistake assume result substituting forxindouble define double x incorrect substitute point apply function point function s invocation replaced body header enables ﬁnd function ascertain parameter body remains evaluation examine substitution used notice type error result returning function example tell case given number s substitute s identiﬁer haven t seen example different identiﬁer ve guessed happen stay unchanged case descend performing substitution turn code s important case consider suppose substituting happens function happen happen way approach question design perspective function name live world distinct ordinary program identiﬁers language c common lisp slightly different way perspective partition identiﬁers different namespaces depending used language distinction examine language soon ref pragmatic viewpoint expression evaluate number mean function turn number number function symbol make sense substitute position leave function unmolested irrespective relationship variable substituted function parameter named xas refer function called x kept distinct ve decision provide body code exprc numc n idc s cond s appc f appc f subst plusc l r plusc subst l subst r multc l r multc subst l subst r exercise observe numc case interpreter returned n tution return original expression equivalent point writing numc n interpreter resumed phew ve completed deﬁnition substitution think let s complete interpreter substitution heavyweight step doe work involved applying function tempting write appc f local define fd f fds subst fd fd tempting wrong reason type doe interpreter return number doe substitution return oh s right expression instance substituted body double got representation valid answer interpreter instead reduced answer course precisely interpreter doe appc f local define fd f fds interp subst fd fd fds okay leaf case identiﬁers possibly complicated just simple number ve end suggesting subtle complex afoot work example understand interpreter identiﬁer case let s suppose deﬁned double follows define double x x y substitute produce expression y far good left substitute y matter fact clear outset deﬁnition double iserroneous identiﬁer yi said free adjective setting negative connotation word interpreter confront identiﬁer identiﬁers ought parameter substituted known bound positive connotation interpreter see result possible response given identiﬁer idc error shouldn s finally complete interpreter deﬁne define n symbol fds listof fundefc fundefc cond fds error reference undefined function con fds cond equal n fds fds n rest fds oh wait s earlier gave following type subst subst exprc symbol exprc exprc sticking surface syntax brevity suppose apply double substitute x resulting following interpretation necessarily want learned algebra school taught ently ﬁrst reduce argument answer case substitute answer parameter notion substitution following type instead subst number symbol exprc exprc careful t raw number inside expression d stantly wrap number invocation numc make sense subst helper invokes wrapping ﬁrst parameter fact existing subst perfectly good candidate accepts exprc ﬁrst parameter certainly work just ﬁne numc fact don t substitution quite right version substitution doesn t scale past language subtle problem known capture fixing substitution complex subtle exciting intellectual endeavor s direction want ll instead sidestep problem book interested read lambda calculus provides tool deﬁning substitution modify interpreter substitute name answer expression ve actually stumbled profound distinction programming language act evaluating argument substituting function called eager cation deferring evaluation called variation actually prefer eager semantics mainstream language adopt later ref return talking lazy application semantics implication substitution environment working deﬁnition function feel slight unease interpreter see identiﬁer sense need look did look deﬁned behavior error absolutely correct little surprising importantly write interpreter understand andexplain language implementation strike doing doesn t match intuition s difﬁculty using substitution number time traverse source program nice traverse part program actually evaluated necessary substitution traverse branch conditionals force program traversed substitution interpretation exercise doe substitution implication time complexity evaluation s problem substitution deﬁned term representation program source obviously interpreter need access source interpret need store purpose nice employ mechanism compiler store version information source reason reporting runtime error jits need portable implementation strategy introducing environment intuition address ﬁrst concern interpreter look identiﬁer sort directory intuition address second concern todefer substitution fortunately converge nicely way address directory record intent substitute actually rewriting program source recording intent substituting immediately defer substitution resulting data structure called environment avoids need rewriting map nicely machine representation association environment called binding observe carefully changing implementation strategy programming language language datatypes representing program change answer interpreter provides result think previous interpreter reference mentation write match create generator creates lot test run interpreter make sure answer ideally prove interpreter behave good topic advanced study subtlety deﬁning precisely mean especially regard s ﬁrst deﬁne environment data structure environment list pair name associated natural question ask environment map name better fundamental question determine answer natural question remember environment created defer substitution answer lie substitution discussed earlier section want tion map name answer corresponding eager function application strategy environment map name answer binding bind symbol val number env listof binding define define con interpreting environment tackle interpreter case easy revisit define interp expr exprc env env fds listof fundefc number exprc expr numc n n arithmetic operation easiest recall interpreter recurred performing new substitution result new deferred stitutions perform mean environment doe change plusc l r interp l env fds interp r env fds multc l r interp l env fds interp r env fds let s handle identiﬁers clearly encountering identiﬁer longer error motivation change instead look value directory idc n lookup n env implement lookup finally application observe substitution interpreter case caused new substitution occur application case construct binding let s ﬁrst extract function deﬁnition just appc f local define fd f fds previously substituted interpreted substitution step proceed interpretation long record deferral substitution interp fd fds set function deﬁnitions remains unchanged interpreting body function environment bind formal parameter let s deﬁne binding process bind fd interp env fds env bound formal parameter substituted bound result interpreting argument ve decided eager application semantics ﬁnally extends environment help make sure got little piece right deﬁnition lookup d interpreter s define lookup symbol env env number cond env error cond env env lookup rest env observe looking free identiﬁer produce error moved unable determine identiﬁer lookup determines based content environment interpreter course test make sure work d expect instance test pas test interp plusc numc appc numc list fdc numc test interp plusc numc appc plusc numc numc list fdc x plusc idc x idc x test interp plusc numc appc plusc numc numc list fdc x appc appc idc x fdc x plusc idc x idc x right spot bug deferring correctly s test interp appc numc list fdc x appc numc fdc y plusc idc x idc y interpreter evaluates translated racket test corresponds following deﬁnitions expression define x define y x y produce substitute xwith body invokes notably identiﬁer xisnot bound sure racket produce error fact interpreter doe substitution process result error s replace representation xwith representation representation obviously s parameter function parameter representation getting little annoying isn t ll stop saying make sure understand say s important bit x s different x evaluating body itsx hasn t substituted resulting error went wrong switched environment watch carefully subtle focus application affect environment substituted formal value actual did extending current environment term example asked interpreter substitute s substitution s body current one caller past one environment grows shrink agreed environment alternate implementation strategy particular language s meaning alter interpreter concretely ask carry past deferred substitution request instead make start afresh new function just interpreter doe easy change bind fd interp env fds truly reproduced behavior substitution interpreter case wondering write test case catch error look scope broken environment interpreter implement known dynamic scope mean environment accumulates binding program executes sult identiﬁer bound depends history program execution regard unambiguously ﬂaw programming language design adversely affect tool read process program compiler ides man contrast environment lexical scope orstatic scope lexical context mean determined source gram static computer science mean running program appealing intuition examine identiﬁer want know thing bound mean multiple binding governs identiﬁer differently s substitution value identiﬁer general question answered statically language ide stance overlay arrow information drracket doe different way think language answer question identiﬁers simply refers dynamic environment word provides useful rule scope complex space name richer object thread strive preserve spirit static scoping bad look running example wonder creating tempest teapot return consider situation understand binding structure program need look program matter ve decomposed program small understandable fragment doesn t matter free identiﬁer understanding binding structure function sizeof gram complexity control ﬂow imagine interactive gram numerous callback d track know binding governs identiﬁer need little nudge let s replace expression example program suppose function presumably evaluates false night true time program evaluate answer night fail unbound identiﬁer error exercise happens cloudy night scope matter complex contemplate deﬁnitions guages instance version scheme paragon lexical scoping allow write define y define f x x y pretty clearly suggest yin body fwill come define y define f x x y define y legal f produce wait think define y define f let z y lambda x x y z define y zis bound ﬁrst value ywhereas inner yi bound second value actually valid explanation behavior term lexical scope scripting language exhibit similar problem result web ﬁnd enormous confusion certain language scoped fact reader comparing behavior inside function static usually dynamic beware convoluted sensible option prevent redeﬁnition racket doe precisely offering convenience pain exposing environment building implementation use wise tesy exported interpreter expression list function tions invoke deﬁned interp environment spare user implementation avoids use interpreter incorrect environment context useful expose environment parameter instance environment represent set binding language wish provide piautomatically bound indiana function introduction scheme programming language deﬁnition establishes sign principle programming language designed piling feature feature removing weakness restriction make ditional feature appear necessary ref design principle hard argue restriction course good reason exist principle force argue admit default let s apply function thing stayed coy introducing function section exactly function suggested following model idealized drracket deﬁnitions us kept separate inspired scheme design principle let s examine necessary t function deﬁnitions expression current language face uncomfortable question value doe function deﬁnition represent don t really good answer real programming language obviously computes number longer need confront question form answer just function value let s work function value clearly function distinct kind value number instance add evident thing apply argument allow function value appear function position application behavior naturally apply function proposing language following valid program ve used bracket easily identify function define f x x evaluate did just used tion function expression value let s ﬁrst deﬁne core language include function deﬁnitions exprc numc n number idc s symbol plusc l exprc r exprc multc l exprc r exprc ll simply copy function deﬁnitions expression language free change necessary allows reuse existing test case fdc symbol arg symbol body exprc need determine application look like go function position application want allow entire function deﬁnition just ve lumped function deﬁnitions expression let s allow arbitrary expression understanding want function deﬁnition expression consider reﬁned datatypes split function deﬁnitions apart kind expression amount trying classify different kind expression return study type ref appc fun exprc arg exprc deﬁnition application longer look function interpreter rid list function deﬁnitions need restore later let s just explore happens function deﬁnitions written point application immediate function let s tackle interp need add case interpreter function deﬁnitions good candidate fdc n b expr happens add immediately problem interpreter longer return number type error ve alluded periodically answer computed interpreter bothered gracing type s time value numv n number funv symbol arg symbol body exprc using sufﬁx vto stand value result evaluation piece funv precisely fdc input output keeping distinct allow evolve independently needed rewrite interpreter let s start type define interp expr exprc env env value exprc expr change naturally force corresponding type change binding datatype lookup exercise modify binding andlookup appropriately numc n numv n idc n lookup n env clearly numeric answer need wrapped appropriate numeric answer constructor identiﬁer lookup unchanged slightly modify addition multiplication deal fact interpreter return value s number plusc l r interp l env interp r env multc l r num interp l env interp r env s worth examining deﬁnition helper function define l value r value value cond numv l numv r numv l r error argument number observe check argument number performing addition instance safe ll discus topic type ref case cover function deﬁnitions ve agreed kind value fdc n b funv n b leaf case application longer need look tion deﬁnition ll leave code structured similarly possible appc f local define fd f interp fd bind fd interp env place lookup reference fwhich function deﬁnition sitting right note expression function deﬁnition position really ought harden code check function doe ismean want check function inition position syntactically function deﬁnition fdc evaluates funv difference write program satisﬁes condition choice check syntactically fdcand isn t reject error evaluate check resulting value function signal error approach give ﬂexible language particular t immediately imagine case human need come handy program need generate code writing precisely program desugarer section result ll modify application case evaluate function position appc f local define fd interp f env interp fd bind fd interp env exercise modify code perform version check complete interpreter instance old test test interp plusc numc appc fdc numc numc numv interp appc fdc x appc fdc y plusc idc x idc y numc numc nested body function deﬁnition arbitrary expression function deﬁnition self expression mean function deﬁnition contain function deﬁnition instance fdc x fdc x plusc idc x idc x evaluating isn t interesting funv x fdc x plusc idc x idc x suppose apply function appc numc answer interesting funv x plusc idc x idc x s applying outer function impact inner function outer function introduces identiﬁer promptly masked inner function introducing masking outer deﬁnition obey static scope suggests different program appc fdc x fdc y plusc idc x idc y numc evaluates funv y plusc idc x idc y hmm s interesting s interesting s interesting let s apply appc appc fdc x fdc y plusc idc x idc y numc numc produce error indicating identiﬁer representing xisn t bound s bound function named isn t clarity let s switch senting hypothetical racket syntax define x define y x y applying outer function expect xto substituted resulting define y y application substitution yield error word failing faithfully capture substitution function value need remember substitution hand observe substitution ve deﬁned replacing xwith numv resulting function body plusc numv idc y doe type substitution predicated assumption type answer form syntax actually possible carry study advanced programming construct assumption won t path applied representing substitution using environment function value need bundled environment resulting data structure called closure observe appc case us body come think did function need ﬁnd using interpreter ﬁnd function s ﬁnd fetch merely descriptive comment word function need immediate constant don t use instance use function function inherently anonymous separate deﬁnition naming say argument make sense function written want won t need name ll return section implementing closure need change representation value record closure raw function text value numv n number closv arg symbol body exprc env env alter syntax deﬁning function drop useless construct historically called lambda lamc arg symbol body exprc encountering function deﬁnition interpreter remember save substitution applied far save environment create closure today flanagan lamc b closv b env saved set environment used applying function appc f local define interp f env interp bind interp env s actually possibility use environment present point application appc f local define interp f env interp bind interp env env exercise happens extend dynamic environment instead retrospect clear interpreted body function environment function deﬁned closed identiﬁers previous function application special case form application substitution seen substitution instructive thinking implement lambda function careful substitution suppose following expression lambda function proper racket syntax lambda f lambda x f suppose substitute fthe following expression lambda y x y observe free identiﬁer x evaluated expect unbound identiﬁer error substitution appear lambda x lambda y x y observe program free identiﬁers s naive version substitution prevent unexpected behavior like form dynamic binding need deﬁne free substitution work roughly follows ﬁrst consistently rename bound identiﬁers entirely previously unused known fresh name imagine identiﬁer numeric sufﬁx attain freshness original expression lambda lambda observe renamed binding bound location let s expression substituting lambda x let s substitute didn t rename x xmay reference binding renamed simply application consistent renaming principle current setting distinction irrelevant lambda lambda x xi free good form substitution moment happens try example based interpreter try observe work correctly report unbound identiﬁer error ments automatically implement substitution exercise way doe using environment avoid capture problem stitution sugaring anonymity let s idea naming function evident value program understanding observe dohave way naming thing passing function acquire local formal parameter function s body refer entity using formal parameter collection function deﬁnitions using function instance racket code define double x x x double ﬁrst rewritten equivalent define double lambda x x x double course just inline deﬁnition double preserve write lambda double double lambda x x x pronounce local ing mechanism useful racket special syntax let double lambda x x x double letcan deﬁned desugaring shown s complex example define double x x x define quadruple x double double x quadruple rewritten let double lambda x x x let quadruple lambda x double double x quadruple work just d expect change order longer let quadruple lambda x double double x let double lambda x x x quadruple quadruple t double binding different local binding essentially inﬁnite scope source power problem subtler problem recursion consider plest inﬁnite loop define x x let s convert let let lambda x x ﬁne right rewrite term lambda lambda lambda x x clearly line isn t bound feature free eliminate ical force need understand recursion explicitly soon ref mutation structure variable s time assuming java ﬁrst behave exactly like exactly like second depends fis local identiﬁer parameter ﬁeld object code really case asking evaluator permanently change value bound tof important implication observer given set input computation returned value answer depends invoked depends invoked value fwas changed introduction time profound effect reasoning program really quite different notion change buried form syntax changing value ﬁeld tremely different changing identiﬁer f fis bound inside method object explore turn ll tackle ﬁelds return identiﬁers section mutable structure simple model mutable structure object generalization structure soon ref ﬁelds object generalization ﬁelds structure understand mutation entirely ref sufﬁcient understand mutable object reductionist don t need structure ﬁelds single sufﬁce box racket box support just operation box boxof unbox boxof boxof void boxtakes value wrap mutable container unbox extract current value inside container finally change value container typed language new value expected think box equivalent java container class parameterized type single member ﬁeld getter setter box constructor unbox getter setter ﬁeld irrelevant class box t private t box t v v t return void set t v v mutate group removing money bank account depositing useful able sequence group mutable operation racket begin let write sequence operation evaluates order return value exercise deﬁne begin desugaring let lambda excellent illustration nature desugaring ve chosen add core construct certainly necessary goal shrink size cost size input make choice goal book study pedagogic interpreter choose larger language possible eliminate begin syntactic sugar prove tremely useful understanding mutation work add simple version sequencing core scaffolding let s extend core language datatype exprc numc n number idc s symbol appc fun exprc arg exprc plusc l exprc r exprc multc l exprc r exprc lamc arg symbol body exprc boxc arg exprc unboxc arg exprc setboxc b exprc v exprc seqc exprc exprc setboxc expression box position new value expression unsurprising mean write program corresponding racket let box box let l list begin l second l l evaluates list box ﬁrst containing second observe output look like notation racket s abbreviated syntactic preﬁx box ﬁrst argument ﬁrst instruction l expression evaluated box just literal box identiﬁer precisely analogous language like java taking type liberty write public static void main string args box integer new box integer box integer new box integer arraylist box integer l new arraylist box integer observe compound expression used ﬁnd appropriate box evaluates box object setis invoked convenience assume implemented desugaring provide let b necessary term sequence desugared nested sequence write expression original racket syntax brevity core language term grow quite large unwieldy run term racket observe answer produce implies taking behavior similar behavior just mainstream language mutable object reference behavior interaction closure consider simple counter define let n box lambda begin n unbox n unbox n time invoked produce integer number number doe work s box created bound n closed subsequent mutation affect box contrast swapping line make big difference define lambda let n box begin n unbox n unbox n observe number number case new box allocated invocation function answer time despite mutation inside procedure implementation box certain preserve distinction example hint implementation necessity clearly vironment close refer box time need make sure value box different time look carefully lexically dynamically different distinction heart implementation understanding interpretation box let s begin reproducing current interpreter define interp expr exprc env env value exprc expr numc n numv n idc n lookup n env appc f local define interp f env interp bind interp env plusc l r interp l env interp r env multc l r num interp l env interp r env lamc b closv b env ve introduced new kind value box update set value value numv n number closv arg symbol body exprc env env boxv v value case easy given boxexpression simply evaluate return wrapped boxv boxc boxv interp env similarly extracting value box easy unboxc interp env constructing healthy set test case make sure behave d expect course haven t hard work interesting behavior presumably hidden treatment setboxc surprise going look seqc ﬁrst instead ll included core let s natural implementation sequence instruction seqc let v interp env interp env evaluate ﬁrst term second return result second immediately spot troubling bound result ing ﬁrst term didn t subsequently s okay presumably ﬁrst term contained mutation expression sort value ing note return void value implementation seqc begin interp env interp env slightly dissatisfying just us analogous racket quencing construct t possibly right work result mutation stored interpreter computes value doe perform mutation mutation interp env completely lost obviously want environment help example help let b box begin begin b unbox b b unbox b unbox b racket evaluates exercise represent expression exprc let s consider evaluation inner sequence case expression representation exactly identical ing underneath cause value box clearly instead evaluate let b box begin b unbox b unbox b begin b unbox b unbox b evaluates call interp rule addition sending exactly textual expression case effect left branch addition felt right branch rule spukhafte fernwirkung interpreter given precisely expression possibly avoid producing precisely answer obvious way preter s parameter environment different environment sent branch sequence arm addition produce output time given possibly produce answer want know far make sure interpreter fed different argument call expected potentially produce different result return interpreter record mutation evaluating argument expression expression ﬁrst point suggests try use environment reﬂect difference invocation turn second point suggests invocation interpreter return environment passed invocation roughly type interpreter interp exprc env value env interpreter consumes expression environment evaluates environment updating proceeds expression evaluating interpreter return answer did updated environment turn sent invocation interpreter treatment setboxc impact environment reﬂect mutation dive implementation consider quences change environment serf important purpose hold deferred substitution respect precise careful alter consequence tie substitution repository lexical scope information allow extended environment escape branch addition used instance consider impact equivalent following program let b box b evident program error bin right branch addition unbound scope bin left branch end closing evident desugar expression use function extended environment end interpreting letclearly bbound exercise work problem make sure understand try various related proposal likely similar failing instance decide problem tional binding environment instead remove added binding returned environment sound attractive did remember closure exercise representation following program let box let f lambda x x unbox begin f problem doe example cause note constraint described valid solution proposed require condition enumerated observe actually requires environment responsible agent quite evident environment principal agent introducing store preceding discussion tell need tworepositories accompany pression environment continues responsible taining lexical scope environment directly map identiﬁers value value change instead need responsible maintaining dynamic state mutated box data structure called store like environment store partial map domain abstract set name natural think number meant stand memory location store semantics map directly abstracted physical memory machine traditionally addressed number environment map name location store map location value location number binding bind symbol val location env listof binding define define con storage cell location location val value store listof storage define define con ll equip function look value store just environment return location instead define lookup symbol env env location define fetch loc location sto store value reﬁne notion value correct value numv n number closv arg symbol body exprc env env boxv l location exercise body lookup andfetch interpreting box environment return updated reﬂecting mutation evaluation expression having change environment way function return value let s deﬁne data structure hold new result interpreter result v s v value s store interpreter s type define interp expr exprc env env sto store result easiest dispatch number remember return store reﬂecting mutation happened evaluating given expression number constant mutation happened returned store passed numc n v s numv n sto similar argument applies closure creation observe speaking creation use closure lamc b v s closv b env sto identiﬁers straightforward simplistic ll type error alert obtain value look environment store idc n v s fetch lookup n env sto sto notice lookup andfetch compose produce result lookup produced thing interesting let s sequencing clearly need interpret term interp env sto interp env sto oh wait point evaluate second term store returned ﬁrst point change instead evaluate ﬁrst term capture resulting store use evaluate second evaluating ﬁrst term yield value sequencing ignores value assumes ﬁrst time run purely potential mutation write stylized manner seqc result interp env sto v s interp env say interp env sto resulting value store respectively evaluate second term store ﬁrst interp env result value store returned second term expect fact ﬁrst term s effect store read code bind subsequently use spend moment contemplating code ll soon need adjust eye read pattern ﬂuently let s binary arithmetic primitive similar quencing case really care value branch usual ll look plusc multc virtually identical plusc l r result interp l env sto v s result interp r env v s v s observe ve unfolded sequencing pattern level hold result supply s important distinction evaluate term usually use environment accordance scoping rule language environment ﬂows pattern contrast store threaded using store branch store branch pas result send pattern called style penny drop style secret ingredient enables environment preserve lexical scope giving binding structure reﬂect change intution told environment participate obtaining different result expression doe directly changing indirectly referring store update need store change let s begin boxing store value box ﬁrst allocate new place store value reside value corresponding box remember location use box mutation boxc result interp env sto v s let v s boxv cell observe relied mented term box outright cheating ify interpreter longer need mutating implementation eliminate style simplest option add parameter return value interpreter represents largest address used far operation allocates store return incremented address return unchanged word precisely application pattern writing interpreter way make extremely unwieldy obscure important use store important make sure s tell reliant box add box language box recording location memory getting value ing easy unboxc result interp env sto v s v s fetch s pattern saw use fetch obtain actual value residing location note relying racket halt error underlying value isn t actually boxv dangerous check tantamount dereferencing arbitrary memory c program disastrous consequence let s update value held box evaluate box expression obtain box value expression obtain new value store box s value going boxv holding location principle want change override value location store way traverse store ﬁnd old binding location replace new copying store binding unchanged lazier option simply extend store new binding location work provided obtain recent binding location lookup work environment fetch presumably doe store code written independent option setboxc b v result interp b env sto v s result interp v env v s v s cell b ve implemented ascons ve actually taken lazier slightly riskier dependence mentation fetch option exercise implement version store alteration update existing binding avoid multiple binding location store look location override value stored location fail present write program demonstrates explain invariant interpreter prevents happening alright application tion familiar evaluate function position evaluate argument position interpret closure body extension closure s environment store interact appc f result interp f env sto v s result interp env v s let s start thinking extending closure environment extending obviously function s formal parameter location bind avoid confusion location fusion explicitly introduce later ref let s just allocate new location location used environment value argument resides location store let interp bind cell said function parameter mutable real need implemented procedure call way instead followed strategy observe mutability location used setboxc change s existing store location store technically store initialization referred boxv s box allocated chosen useless app application way uniformity reduce number case d handle exercise s useful exercise try limit use store location box change need make bigger picture ve ﬁnished implementation subtlety insight discus implicit implementation subtle important decision order evaluation instance did implement addition plusc l r result interp r env sto v s result interp l env v s v s perfectly consistent similarly embodied pattern decision evaluate function position argument observe previously delegated decision underlying language mentation forced sequentialize tation make decision realized b importantly decision semantic mutation branch addition instance affect value produced branch branch effect halting error failing sure certainly observable effect gross level program terminate different answer depending order impact value choose order programmer predict program going forced write interpreter clear observe application rule passing dynamic store resulting evaluating function argument precisely opposite said environment distinction critical store effect dynamically scoped reﬂects history computation lexical shape using term scope refer binding identiﬁers confusing say dynamically scoped refer store instead simply say persistent language dangerously conﬂate c instance value bound local identiﬁers allocated default stack stack match environment disappears completion returned reference value ences pointing unused overridden memory genuine source error c program problem value sist identiﬁers refer lexical scope discussed strategy overriding store simply extend rely fetch extract newest strategy virtue holding useless store binding obtained doe cover wasted memory time cease able access box entirely bound ﬁer identiﬁer longer scope location called garbage thinking conceptually garbage location elimination doe impact value produced program gy identifying reclaiming garbage location usually called garbage collection ref s important evaluate expression position thread store result consider instance implementation unboxc unboxc result interp env sto v s v s fetch sto did notice fetch ed location sto storeﬂects mutation evaluation unboxc expression possibly mais oui let b box unbox begin b b incorrect code evaluate s similar error unboxc result interp env sto v s v s fetch sto break returning old store mutation unboxc happened just need outside context depend let b box unbox begin b b unbox b evaluate store returned b s location bound representation result combined bug using stotwice line instead expression evaluate exercise interpreter replace reference updated store reference update make sure test case catch introduced error observe us old store enable perform kind time travel mutation introduces notion time enable time mutation occurred sound interesting perverse doe use doe imagine instead directly mutating store introduce idea journal intended update store journal ﬂows threaded manner just like real store instruction creates new journal lookup ﬁrst check journal journal ﬁnd binding location looked actual store new instruction discard journal perform time travel tocommit edits applied real store essence software transactional memory thread maintains journal thread doe edits committing thread see journal global store journal thread time thread get consistent view world see edits recorded journal transaction end successfully thread atomically updated global store transaction abort discarded journal take change state thread reverts modulo global change committed thread software transactional memory offer sensible approach tackling difﬁculties programming insist ming shared mutable state computer global store maintaining journal expensive effort go optimizing alternative hardware architecture gun provide direct support transactional memory making creation maintenance commitment journal efﬁcient using global store removing important barrier adoption idea exercise augment language journal feature software tional memory journal exercise alternate implementation strategy environment map name toboxed value don t cheating b wouldn t tell implement feature language box c doesn t necessarily carry mutation operation d doesn t really insight happening useful understand ﬁnd useful strategy adopt implementing language fore alter implementation obey strategy need style variable ve got structure mutation worked let s consider case able mutation terminology choice term ve insisted using word identiﬁer wanted reserve variable study java say assuming xi locally bound method parameter x x asking change value ﬁrst assignment value second s value xvaries course execution method use term variable mathematics refer function eters instance fpyq say yi variable called variable varies invocation invocation value scope identiﬁers corresponded notion variable contrast programming variable vary invocation identiﬁer bound box remained bound box value s content box changed box identiﬁer bound java xabove henceforth use variable mean identiﬁer value change scope identiﬁer happen doubt play safe use variable difference doesn t really matter use important caught speciﬁc term understand represent distinction matter ref syntax language overload mutation syntax racket kept distinct set used mutate variable force racket programmer confront distinction introduced beginning section course sidestep syntactic issue core language using different construct box variable ﬁrst thing note variable mutation term like box mutation setboxc syntax fundamentally different stand let s return java fragment x setting write arbitrary expression place x literally write identiﬁer expression position evaluate yielding value instance xwere previously bound tantamout writing following statement course nonsensical t assign new value pretty deﬁnition immutable instead want ﬁnd xi store change value held s way suppose local variable owere bound string object let s object say write o new string new string trying change sin way certainly statement intends leave salone want change value ois referring subsequent reference evaluate new string object instead interpreting variable ll start reﬂecting syntax exprc numc n number varc s symbol appc fun exprc arg exprc plusc l exprc r exprc multc l exprc r exprc lamc arg symbol body exprc setc var symbol arg exprc seqc exprc exprc observe ve jettisoned box operation kept sequencing s handy mutation importantly ve added setc case ﬁrst term expression literal variable ve renamed idcto varc ve gotten rid box rid special box value kind mutation variable don t need new kind value value numv n number closv arg symbol body exprc env env imagine support variable need style ve seen section reason differs cisely use sequencing interpreted just way observe code doe depend box versus variable leaf just variable mutation case handle evaluate value expression obtain updated store setc var val result interp val env sto v s remember just said don t want fully evaluate able just value bound instead want know memory location corresponds update stored memory location just thing did mutating box let lookup var env v s cell interesting new pattern added box theidccase looked identiﬁer environment immediately fetched value location store composition yielded value just used added store new pattern looking identiﬁer environment subsequently fetching value store result invoking just lookup traditionally called assignment value fancy way saying memory address stand contast actual value store yield observe doe directly correspond type value did hard work implemented style application allocated new location variable design stateful language operation programming language include kind state ied admission regarded trivial foregone matter hand state brings vital beneﬁts state provides form modularity interpreter demonstrates explicit stateful operation achieve effect need add explicit parameter return value pas equivalent store change allprocedures volved communication path producer consumer state different way think state programming language implicit parameter passed returned procedure imposing burden programmer enables procedure nicate distance intermediary having aware communication state make possible construct dynamic cyclic data structure relatively straightforward manner section state give procedure memory procedure remember thing caller need perform remembering behalf employing moral equivalent unwieldy creates potential caller interfere memory nefarious purpose caller purposely send old store obtaining reference granted party launch correctness security attack hand state imposes real cost programmer program process program compiler aliasing discus later ref referential transparency hope return ref finally described state provides form modularity description viewed communication intermediary did know monitor especially security distributed setting lead collusion extremely dangerous undesirable optimal answer probably wise include mutation tor carefully delinate standard ml instance variable mutation considered unnecessary instead language lent box called ref easily simulate variable using box consider written variable instead sive power lost doe create potential aliasing variable ref aliasing box used carefully return developer obtain expressive type data structure sidered immutable unless contains ref presence refis warning developer program compiler underlying value changing instance bi box developer aware replacing instance unbox b v vi bound unbox b unwise fetch current value box referring older content conversely developer want value certain point time oblivious future mutation box sure retrieve bind use unbox parameter passing current implementation function allocate fresh location store parameter mean following program let f lambda x set x let y begin f y y evaluates value formal parameter xi held different location actual parameter y mutation affect location x leaving yunscathed suppose instead application behaved follows actual rameter variable location memory instead allocating new location value simply pass existing variable formal parameter referring store location actual arevariable alias mutation formal leak ing context program evaluate called strategy instead interpreter implement strategy followed language like java cause confusion value mutable change value callee observed caller simply artifact mutable value calling strategy avoid confusion year power considered good idea useful programmer write abstraction swap swap value variable caller disadvantage greatly outweigh advantage careless programmer alias variable caller modify realizing caller realize happened obscure condition trigger people thought necessary efﬁciency assumed native copy large data structure compatible passing just address data structure need make copy data structure mutable b want caller able mutate c language doe provide immutability annotation mechanism force reasoning instance pose procedure define f g let x begin g x language permit parameter passing mer just value xwill ellipsis language going permit parameter let caller determine pas let callee share memory address caller s option attractive sound callee face symmetric lem knowing parameter aliased traditional sequential program concern procedure reentrant callee face precisely predicament point consider fuss worthwhile instead caller want callee perform mutation simply send boxed value callee box signal caller callee perform mutation caller extract value s doe obviate ability write simple swapper s small price pay genuine software engineering concern recursion cycle procedure data recursion act speak recursion programming language meaning mind recursion data recursion control program say function recursive cyclic data recursion data refer thing mean referring kind referring thing recursion kind lead traditionally recursive data instance tree recursive data structure vertex multiple child tree write procedure traverse node tree expect terminate having track node visited ﬁnite data structure contrast graph cyclic datum node refers node refer original matter node refer directly traverse graph absent explicit check visited expect computation diverge terminate instead graph algorithm need memory visited avoid repeating traversal adding recursive data list tree language quite ward mainly require thing ability create compound structure node reference child ability recursion leaf exercise add list binary tree datatypes programming guage adding cyclic data subtle consider simplest form cyclic datum cell referring s try deﬁne racket s attempt let b b b doesn t work bon letisn t bound s easy desugar lambda b b b clarity rename bin function lambda x x b s patently clear bi unbound absent magical racket construct haven t seen clear construct shared virtually language notational mechanism won t dwell fact studying main idea shared actually t create cyclic datum shot instead need ﬁrst create place datum refer place use introduction suggest mutation operation let s try box plan follows want create box bind identiﬁer sayb want mutate content box want contain reference doe obtain reference using b bound way mutation creates cycle let b box begin b b b note program notrun typed plai written ll return typing program later ref run untyped lang plai language program run racket print notation fact precisely want recall racket print box similarly number racket name piece cyclic data racket saying bound box content bound exercise equivalent program interpreter box make sure produce cyclic value check idea generalizes datatypes way duce cyclic list graph central idea process ﬁrst vacant placeholder mutate placeholder content tain use previously bound course need limited data element cyclic combination recursive function shift terminology recursive function reference kind function function s useful ﬁrst ensure ve ﬁrst extended language conditionals kind check described earlier section write program terminate let s try write recursive factorial let fact lambda n n n fact n fact doesn t work inner fact give unbound identiﬁer error just cyclic datum example surprise encounter error cause traditional binding mechanism doe automatically make function nitions cyclic early programming language edly recursion considered special feature instead want typically write deﬁnitions don t encounter issue binding implicitly variable box result pattern automatically place want recursive local binding use letrec local function deﬁnition cyclically refer implement hand mean clear problem diagnosed reuse solution follow process ﬁrst create placeholder refer placeholder want cyclic reference ﬁnally mutate placeholder use let fact box let lambda n zero n n unbox fact n begin fact unbox fact fact don t need ve used binding just clarity observe isn t recursive identiﬁers variable use simply substituted value let fact box begin fact lambda n zero n n unbox fact n unbox fact small nuisance having repeatedly unbox fact language variable seamless use variable simplify desugaring pattern instead requiring use identiﬁer unboxed hand little extra effort desugaring process care doing unboxing let fact begin set fact lambda n zero n n fact n fact premature observation preceding discussion pattern show clear temporal sequencing create update use capture desugaring rule suppose add following new syntax rec value body example use rec fact lambda n n n fact n fact evaluate factorial new syntax desugar let box begin value body assume reference invalue andbody rewritten unbox alternatively instead use variable let begin set value body naturally inspires question order terestingly try use updating true value place observe state right creation placeholder raw form simplest example demonstrates follows letrec x x x equivalently local define x x x racket variant leak initial value given value meant public consumption troubling legitimate value mean probably used computation developer access us inadvertently effectively computing nonsense generally solution problem make sure value sufﬁciently obscure used meaningful context mean value like especially bad common datatypes shunned instead language create new type value just use passed operation result error explicitly check use identiﬁer belonging special mature value technically feasible imposes enormous formance penalty program usually employed teaching language allow recursion constructor used case binding function make sure binding syntactically tion unfortunately solution bit drastic precludes writing instance structure create graph explicit state aware way deﬁne recursive function recursive data doe leverage explicit mutation operation ve seen go wrong try use just letto deﬁne recursive function try harder hint substitute recursion just function amazing idea use term literally s written daniel friedman matthias felleisen book little schemer read sample chapter online exercise doe solution use state implicitly object language admits function value provides developer natural way represent unit computation suppose developer want parameterize function language let fbe parameterized passive data bers string attractive parameterize active data datum compute answer response information furthermore function passed data caller data having revealed f providing foundation security privacy function central design secure programming technique function splendid thing suffers excessive terseness want multiple function close shared data sharing especially matter function mutate expect result mutation case unwieldly send just single function parameter useful send group function recipient need way choose different function group grouping function mean select group essence object perfectly placed study object having covered function section mutation section emerge recursion section hope justice enormous space object system read programming language application interpretation éric tanter go cover topic ignored s add notion object language ll ﬂesh grow explore dimension design space object ll ﬁrst add object core language ll want prototype different idea quickly ll soon shift strategy use depends think understanding critical understanding essence language way measure complex desugaring strategy adding key core language enhancement greatly reduce complexity desugaring object inheritance simplest notion thing talk object agrees object value map name stuff value method minimalist perspective method just function language aside distinction ﬁnd method awfully close function differ important way called s bound object core starting language function let s deﬁne simple notion object adding core language clearly extend notion value value numv n number closv arg symbol body exprc env env objv n listof symbol v listof value ll extend expression grammar support literal object construction expression observe design decision language like javascript developer write literal object notion popular subset syntax javascript web standard json language like java object created invoking constructor class simulate assuming model kind language write object literal special position following stylized convention desugaring objc n listof symbol e listof exprc evaluating object expression easy just evaluate expression position objc n e objv n map lambda e interp e env e unfortunately t actually usean object way obtaining content reason add operation extract member msgc o exprc n symbol behavior intuitive msgc o n n interp o env exercise implement symbol value value second argument expected objv principle msgc used obtain kind member simplicity need assume function use apply value cumbersome write concrete syntax let s assume desugaring taken care concrete syntax message invocation includes message fetch argument expression msg o exprs n symbol exprs desugars msgc composed application msg o n appc msgc desugar o n desugar ﬁrst language object instance object deﬁnition invocation let o objs list list lam x plus id x nums lam x plus id x nums msg id o nums evaluates numv object desugaring deﬁning object core language worthwhile s unwieldy way studying instead ll use racket represent object sticking part language know implement interpreter ll assume looking output desugaring reason ll stick stylized code potentially writing unnecessary expression ground simple program generator produce alert code follows lang plai notin typed language exercise lang plai problem sdo encounter try type following code amenable easy ﬁxes introducing new datatype applying consistently make simpliﬁcations purpose modeling assuming method argument tractable object named collection let s begin reproducing object language object just value dispatch given simplicity ll use lambda represent object case implement dispatching observe basic object generalization lambda multiple conversely lambda object just doesn t need method disambiguate define lambda m case m lambda x x lambda x x object deﬁned earlier use method way test test succeeds course writing method invocation nested function call unwieldy d best equipping convenient syntax invoking saw earlier msg simply deﬁne function ve taken advantage racket s syntax asays bind list named apply splice list argument function define msg o m apply o m enables rewrite test test msg important changed switched desugaring strategy recall syntax deﬁnition earlier msgc o exprc n symbol position message explicitly symbol developer write literal symbol desugared version position just expression evaluate symbol instance written test symbol succeeds general problem desugaring target language allow expression counterpart source mapped tunately don t need perform inverse mapping doe arise debugging program comprehension tool subtly ensure target language doe produce value corresponding equivalent source basic object let s start adding kind feature ve come expect object system constructor constructor simply function invoked object construction time currently lack function turning object literal function take constructor parameter achieve effect define x lambda m case m addx lambda y x y test msg test msg ﬁrst example pas constructor s argument adding second similar show invocation constructor don t interfere state people believe object primarily exist encapsulate state certainly alan kay won turing award inventing smalltalk modern object technology disagrees early history smalltalk say t small scale motivation oop ﬁnd ﬂexible version assignment try eliminate altogether add unfortunate called programming today simply old style programming fancier construct program loaded operation expensive attached haven t lost ability desugar language variable lently use box return slight desugaring overhead easily ple method mutate common state constructor argument define count lambda m case m lambda set count count dec lambda set count count lambda count instance test sequence operation test let o begin msg o msg o msg o notice mutating object doesn t affect test let begin msg msg msg msg private member common object language feature private member one visible inside object outside like additional feature need java instance class type privy private member simply able implement abstract data implement necessary mechanism form scoped variable define init let count init lambda m case m lambda set count count dec lambda set count count lambda count desugaring provides mean accessing count lexical scoping ensures remains hidden world static member feature valuable user object static member common instance type object merely use quote notion sameness object identiﬁer making private life outside constructor making common us constructor define let counter lambda begin set counter counter lambda m case m lambda n set n dec lambda n set n lambda count lambda counter ve written counter increment constructor object just manipulated inside method test make multiple object ensure affect global count test let o msg o test let o msg o object object simply package named function function multiple named ve seen feature sidered important object system actually simple pattern function scope name assigned decade programmer armed lambda characteristic actually distinguishes object system object automatically equipped reference object called self orthis prefer slightly dry way putting anthropomorphic know terminology adopted object advocate note gotten far object property needing resort implement easily using mutation yes seen just pattern implemented recursion ll just generalize refer just box function object define let self begin set self lambda m case m lambda x msg self x second lambda x x self observe precisely recursion pattern section adapted slightly ve tested having send method second sure produce expected answer test msg mutation studied implement recursion mutation ll notice solution applies observe define lambda m case m lambda self x self x second lambda self x x method take self argument mean method invocation modiﬁed follow new pattern define o m apply o m o invoking method o pas oas parameter method obviously approach dangerous potentially pas different object self exposing developer probably bad idea implementation technique used desugaring python expose just thisin surface syntax tribute touching resultant brittleness dynamic dispatch finally make sure object handle characteristic attribute ject system ability invoke method caller having know decide object handle invocation suppose binary data structure tree consists node leaf hold value traditional function forced implement equivalent form cond moral exhaustively list selects different kind tree deﬁnition tree grows include new kind tree code fragment modiﬁed dynamic dispatch solves problem making conditional branch disappear user s program instead handled method lection code built language key feature provides extensible conditional dimension extensibility object provide appears make system extensible grow needing modiﬁed accommodate hailed key beneﬁt advantage object function dual advantage function object object programmer end contorting visitor make look like organization read synthesizing functional design promote running example lay problem glory try solve favorite language racket s deﬁned kind tree object define mt let self begin set self lambda m case m add lambda self define node v l r let self begin set self lambda m case m add lambda v msg l msg r self make concrete tree define node node mt mt node node mt mt mt ﬁnally test test msg observe test case addmethod node reference add checking recipient mtornode instead extract recipient s addmethod invokes missing conditional user s program essence dynamic dispatch member access design space orthogonal dimension come treatment member name dimension provided statically computed set name ﬁxed variable static computed fixed set member base java java reﬂection compute variable set member difﬁcult envision use scripting language case doe quite make sense force developer specify member source ﬁle explicitly new member accessible access deleted member fail point design space explored language quadrant corresponds closely language use represent object simply index guages carry extreme use representation numeric dice instance conﬂating object dictionary array object handle member name style object creates signiﬁcant difﬁculty ref automatically desirable rest section stick traditional object ﬁxed set name static member reference rant ﬁnd study go case statement clause reason variable set member object probably better handled different representation conditional instance ve discussed contrast object s set member ﬁxed desugaring conditional work purpose illustration phasizes ﬁxed nature set member name hash table leaf open error reason clause chain control parent object called inheritance let s return model desugared object implement inheritance object given delegate method invocation doe recognize great deal depend answer simply object case m m representation object application effectively search method parent object presumably recursively parent method matching return chain original msgthat sought method ﬁnal object presumably signal message error exercise application m like half msg just like half value lookup ref tion let s try extending tree implement method size ll write extension tempted say hold node andmtto implement size method intend extend existing deﬁnitions node andmt ll use extension pattern described editing existing deﬁnitions supposed point object inheritance reuse code fashion mean different party know extend base code edit base ﬁrst ﬁnd addition dislike edits inheritance meant sidestep issue class immediately difﬁculty constructor pattern define v l r suggests parent level object s constructor ﬁelds reasonable parameter given object fully deﬁned define node v l r going write parameter twice write twice worry consistently inducing subtle error s alternative canconstruct instance node parent s parent parameter parent object parent s object maker define v l r let v l r self begin set self lambda m case m size lambda msg l msg r m self define let self begin set self lambda m case m size lambda m self object constructor remember pas maker invocation define node node mt mt node node mt mt mt obviously simplify appropriate syntactic sugar conﬁrm old new test work test msg test msg exercise rewrite block code using instead mutation capture essence class function parameterized parent s bit tricky really let s blob blob corresponds java programmer deﬁnes write class class nodesize extends node going way class developer invokes java class s constructor effect construct object way inheritance chain practice compiler optimize require constructor invocation object allocation private copy object corresponding parent class private presence static member question object visible java chooses implementation method given signature remains matter inheritance chain ﬁeld remains result accessed casting make sense ﬁeld presumably invariant governing keeping separate present wise contrast easy imagine implementation make method available one lowest reﬁned inheritance hierarchy scripting language approach exercise code fundamentally broken self reference syntactic object need refer object known open recursion modify object representation demonstrates form extensibility traditional object extensible recursion refers reﬁned version object hint ﬁnd method section recursion handy prototype description ve supplied class description parent class object construction make instance go inheritance chain way think parent class instantiated instead directly object child parent observe object mean change child object visible child shared parent object known prototype archetypal language self read language like javascript based self value studying idea source especially self present idea purest language designer argued prototype primitive class basic mechanism function recover class way essentially class function contains inside object description class exposed different operation sen inherit directly object akin prototype exercise modify inheritance pattern implement based language instead language class vide object distinct copy parent object language provide clone operation simplify creation ation simulates class atop prototype multiple inheritance ask option s easy generalize lead naturally multiple inheritance effect multiple object chain lookup course raise question order bad ascendant arranged tree tree doe canonical order traversal just traversal instance compelling us worse suppose blob aextends bandc suppose b andceach extend confront question infamous situation called diamond inheritance choose include multiple inheritance language lose day design decision highly unlikely ﬁnd canonical answer pain instance having save space interact better expectation visit object twice visiting twice make difference unnecessary visiting mean behavior borcmight change result virtually language accompanied subtle algorithm merely deﬁne lookup order multiple inheritance attractive ve thought language notion ability invoke method access ﬁeld higher inheritance chain includes doing note say chain switch multiple inheritance concept replaced object construction requirement constructor invoked make sure object properly deﬁned accustomed thinking call going chain forgotten ask natural direction mind constructor method expected enforce invariant trust argument say reﬁned global view object conversely vested protecting invariant violation ignorant fundamentally opposed view inheritance mean going chain mean view extension replacing parent going chain mean view extension reﬁning parent normally associate reﬁnement language choose wrong order ing language explored invocation downward direction default gbeta modern programming language support inner interesting feature interesting consider combining mixins trait let s return blob write class java really deﬁning opening closing brace entire class depends parent extends recursively deﬁne inside brace class extension class identify parent class place naturally ask separate act deﬁning extension applying extension base class suppose instead class c extends b instead write classext e separately class c e b bi class thusfar look like ve just gone great length obtain fore syntax meant suggestive apply extension different base class class e class e separating deﬁnition efrom class extends liberate class extension tyranny ﬁxed base class extension called mixins term mixin originated common lisp particular pattern using multiple inheritance lipstick make class deﬁnition compositional provide ﬁts reusing multiple fragment functionality aegis language complicated rule lookup order observe desugaring s actually quite easy add mixins language mixin primarily function class determined desugar class target language desugaring function class desugar expression nested inside function trivial implement simple model mixins case greater generality target language desugaring lead better construct reﬂect source typed language good design mixins actually improve programming practice suppose deﬁning version java mixin effectively function type function clearly mixin ought use interface expects provides java enables doe require doe enable class extension extends class member visible interface mean obtains parent s behavior speciﬁcation thereof turn parent change class break mixin language instead write mixin m extends ii interface mcan applied class satisﬁes interface turn language ensure member speciﬁed iare visible follows important principle good software design program interface patternsa good design mixins class used inheritance chain deﬁnition class eventually referred cycle inheritance chain causing potential inﬁnite loop contrast compose function qualm using function twice map filter map value using mixin twice certainly section ofclasses mixins solve important problem arises design library suppose dozen different feature combined different way class provide furthermore combined obviously impractical generate entire combinatorial explosion class better devleoper pick choose feature care mechanism prevent unreasonable combination precisely problem mixins solve provide class extension developer combine way create just class need mixins used extensively racket gui library instance color consumes basic text editor interface implement colored text editor interface iself basic text editor interface additional basic text mixins applied doe favorite library solve problem mixins limitation enforce linearity composition ness misplaced put burden programmer necessary generalization mixins called trait say instead extending single mixin extend setof course moment extend contend potential trait equipped mechanism resolving clash form algebra trait offer nice complement mixins enabling programmer choose mechanism best ﬁts need result racket provides mixins trait memory management garbage use term garbage refer allocated memory longer necessary distinct kind allocation typical programming language time performs kind environment follows discipline consistent nature static scope returning procedure return procedure s allocated environment space subsequent use seemingly free cost contrast allocation store follow value s lifetime s free machine execute explicit pop instruction recover space result necessarily cheaper memory management scope live forever need different strategy recovering space consumed garbage method recovering space largely fall camp manual automatic manual collection depends developer able know correctly discard unwated memory traditionally human proven especially good case knowledge machine ref decade automated method nearly ubiquitous correct garbage recovery garbage recovery recover space early soundness late pleteness regarded ﬂaws symmetric impact arguably recovering early worse recover store cation prematurely computation continue use potentially write data working nonsensical data lead gram incorrectness extreme situation lead worse phenomenon security violation contrast holding memory long decrease performance eventually cause program terminate tonic sense memory available performance degradation premature termination annoying certain system deeply problematic program doe compute nonsense ideally love automation soundness completeness face classic pick tradeoff ideal human capable attaining soundness completeness practice rarely achieve computer surely perfect fellow developer way economics discipline looking automation soundness completeness computability argument demonstrate automation t accompanied practice automated technique offer soundness ground doe harm b relatively easy implement c human intervention closely approximate completeness manual reclamation manual approach entrust human c instance basic primitive malloc allocation free reclaim malloc consumes size return reference value free consumes reference reclaims assocated memory moloch used ﬁguratively english literature john milton s paradise lost allen ginsberg s howl refer person thing demanding requiring costly moloch consider coincidental sound likemalloc cost reclamation let s start asking cost operation begin suming malloc associated register pointing store like ref allocation simply obtains free location model extremely fact deceptively problem arises free value provided ﬁrst free malloc encounter problem store data follow stack discipline free recently allocated value leave hole store hole lead fragmentation worst case unable allocate object ample space split fragment large exercise principle eliminate fragmentation making free space contiguous doe think quences sketch fact manually fragmentation remains insuperable problem manual memory management scheme consider seemingly simple cipline happens free value record available future allocation doe maintaining free list free space little reﬂection immediately suggests question free list stored manages itsmemory answer free list reference stored freed cell immediately implies minimum size allocation principle malloc traverse free list ﬁnd suitable freed spot say suitable allocator make complex decision ﬁrst slot match later way doe match mean slot exact right size larger slot break smaller one increasing likelihood creating unusably small hole developer like allocation cheap practice allocation system failing make allocation cheap make developer try encode trick based reusing value reducing clarity quite possibly use just ﬁxed set size power make possible maintain free list s hole size power table refers list indexing table cheap using return developer sacriﬁce space object end needlessly padded classic computer science trading space time free freed memory right slot break larger block multiple smaller block prepare future allocation model inherently cheap particular free free course assumes developer function sound complete fashion don t reference counting entirely manual reclamation put undue burden developer automated technique seen use notably reference counting reference counting value associated count reference developer responsible incrementing decrementing count count reach zero value s space safely restored future reuse observe immediately signiﬁcant assumption lurking simple deﬁnition developer track reference recall alias reference developer writes let x value let y x remember yi second reference value referred byx increment count accordingly value ﬁnite number reference assumption fails value cycle need manually increment decrement reference technique suffers lack soundness completeness second assumption naturally lead lack completeness ﬁrst assumption point simplest way break soundness peril manual memory management subtle run deeper developer charged freeing memory equivalently managing reference count policy memory management library s face effectively s going value allocated library library value passed unfortunately difﬁcult document follow policy precisely worse pollutes description library detail usually intended behavior intriguing idea automate insertion reference increment ments add implementation doing solves problem reference counting suffers reference count increase size object large overﬂow small appreciably increase program s ory footprint time spent increase decrease count signiﬁcant object s reference count zero refers reference count recursively mean single deallocation action large time impact barring clever lazy technique increase program s memory footprint decrement reference count walk object garbage highly counterproductive traverse object longer interested practical consequence object interested accessed mean paged reference counter page just inform longer needed reason reference counting used utmost care accept default ask reject generally better automated technique exercise reference count overﬂows correctness property hurt examine tradeoff automated reclamation garbage collection people reference counting garbage collection technique prefer use term refer technique beware potential confusion browsing let s brieﬂy examine idea having language s automate process reclaiming garbage ll use abbrevation gc forgarbage tion refer algorithm process letting context disambiguate overview key idea gcalgorithms traverse memory following reference value traversal begin root set place program possibly refer value store typically root set consists bound variable environment global variable actual ing implementation implementor careful note ephemeral value reference register root set algorithm walk accessible value using variety algorithm usually variation search search generally preferred work implementation course wonder gc s stack stored identify live usable sequence program tions deﬁnition garbage different algorithm address recovery space different way truth provability read carefully ll notice slipped algorithm tion implementation speciﬁcation iﬁcation garbage collection term truth want collect precisely value garbage obtain truth programming language settle provability algorithm described give efﬁcient proof liveness rendering complement garbage course variation scheme enable collect garbage correspond different strength proof value s garbageness remark highlight weakness strict speciﬁcation say ing garbage collected actually useful think extreme case trivial deﬁne sound garbage collection strategy similarly trivial deﬁne complete garbage collection strategy sound simply make sure don t accidentally remove live way absolutely certain collect garbage dually trivial complete gccollects obviously useful certain highly dangerous highlight practice want gcthat sound complete possible efﬁcient central assumption able soundly perform gcdepends critical assumption ﬁrst language s implementation language s semantics confronted value gcneeds know kind value memory representation laid instance traversal reach con cell know con cell b say byte offset c rest say byte offset obviously property hold recursively enabling traversal rithm correctly map value memory program manufacture reference way object reference reside outside implementation s root set b object reference refer point object second property violated gccan effectively haywire terpreting data ﬁrst property sound obvious violated clearly failed obey language s semantics consequence property subtle discus ref convervative garbage collection ve explained typical root set consists environment global variable choice ephemeral reference reside language language m looking c allow reference turned arbitrary number arbitrary number turned reference result principle anynumeric value program nature c s type virtually anyvalue program potentially treated reference problematic reason mean gccan longer limit attention small root set instead entire store potentially root set second gctries modify object record visited bit potentially changing value actually changing innocent numeric constant program result particular conﬂuence feature language like c conspire make sound efﬁcient gcextremely difﬁcult impossible stimulating line research called conservative gchas aged create reasonably effective gcsystems language principle hind conservative gcnotes principle store location root practice proceeds series increasingly clever observation deduce notbe reference opposite traditional gc safely ignored instance architecture odd number reference skipping store making basic assumption program behavior manufacture certain kind reference careful modify changing bit value moving data actually yield reasonably effective egy bit dog walking hind gcis popular programming language implementation written rely base code c instance early version racket relied exclusively good reason offer quick bootstrapping technique language implementor focus innovative feature language control reference racket doe easily create memory representation especially conducive increasing effectiveness gc padding true number enables easy interoperation useful library written c vided course meet expectation technique word vocabulary order argued ref allpractical gc technique conservative approximate truth reachability word conservative refer gctechnique operates uncooperative hopefully hostile precise garbage collection conventional gcterminology opposite conservative precise misnomer gccannot precise sound complete precision statement ability identify reference confronted value precise gcknows exactly isn t reference reference remove monumental effort conservative gchas guessing hoping eliminate potential reference possible process space precise gc contemporary language time system use wide range implementation technique refer paul wilson s survey despite relative age ﬁeld remains excellent resource book material richard jones particular quick readable overview generational garbage collector read simple generational garbage collection fast allocation representation decision look interpreter function value ref curiously really consider chose represent different kind value number function ignoring superﬁcial numv andclosv wrapper focus underlying data representation represented interpreted language s number racket number did represent interpreted language s function closure racket function closure s uniform use racket s resentations notuse racket s representation did make particular choice trying illustrate point point explore right changing representation moment let s explore number racket s number make good target reuse powerful integer bignums rational beneﬁt bignum representation integer complex number represent ordinary programming language number system doesn t mean want little want restricted number instance java prescribes speciﬁc set representation int speciﬁed number fall outside set represented number arithmetic respect set overﬂowing adding doe notproduce little want richer number quaternion bers associated probability worse didn t stop ask wanted blithely proceeded racket number reason did weren t really interested study bers interested programming language feature value language designer sure ask hard question let s talk representation closure instead resented closure exploiting racket s corresponding concept correspondingly function application unvarnished racket application replace closure data structure racket function representing value numv n number closv f value value define interp expr exprc env env value exprc expr numc n numv n idc n lookup n env appc f local define interp f env define interp env plusc l r interp l env interp r env multc l r num interp l env interp r env lamc b closv lambda interp b bind env exercise observe curious shift previous implementation environment extended appc case s extended lamc case incorrect did change occur certainly concise ve lost important understanding saying source language function corresponds lambda tell virtually ing knew precisely lambda doe studying didn t mapping teach absolutely fact pile confusion ignorance reason did use racket s state understand variety stateful operator ref ve understood feature feel use tation doing yield concise interpreter aren t doing manually fact later interpreter ref virtually unreadable did exploit richer representation exploiting s little like saying understand addition term use addition deﬁne multiplication don t use deﬁne host language feature peril safeguard error program wrong programmer need careful presentation error using host language feature run risk user host language error understand carefully translate error condition term user language understand letting host language leak worse program error instance suppose decide function appear position fail expressly check desugaring permissive lambda result interpreter produce answer halted error great care permit intended surface language mapped host language example consider different mutation operation language attempting mutate unbound variable produce error language doing result variable deﬁned failing pin intended semantics common language designer error saying instead tion doe attitude lazy sloppy b yield unexpected negative consequence c make hard language mentation platform don t make mistake changing meaning mapping lambda work especially intend meaning make difﬁcult change meaning function doe lem ya hypothetic suppose wanted guage implement dynamic scope original interpreter easy don t let past hypothetical stage easy history show try make interpreter us lambda implement dynamic scope similarly difﬁcult subtle map eager evaluation language lazy application ref exercise convert interpreter use dynamic scope point raw data structure representation doe make pecially easy usually doesn t way contrast mapping host language feature make match host language doe easy subtle difﬁcult added ger certain host language s feature doe doe lambda actually implement static scope moral good property exploit want pas base language s especially wise ensures don t accidentally change meaning want exploit signiﬁcant base language augment meaning implementation strategy ref work just instead writing interpreter example let s consider representation change environment environment map name value location tion ve chosen implement mapping data structure way represent map function course environment function take argument return bound value error env symbol value environment s return error matter try look define symbol error principle type annotation return value course thiis vacuous extending environment binding creates function take check just extended return corresponding value punt environment extended define b binding e env lambda symbol value b b lookup e finally look environment simply apply ment define lookup n symbol e env value e n desugaring language feature far extensively discussed relied desugaring current desugaring mechanism weak actually used desugaring way used shrink language large language distill core ref used grow language existing language add new feature ref just show desugaring tremendously useful feature useful ask question create language simplify creation common task language designed support desugaring look like note look don t mean syntax key behavioral property given language used target desugaring don t offer desugaring capability language instance mean extending base language additional language response previous question going explore answer question simultaneously studying facility provided racket example drracket useful tool called macro stepper show expansion program try example chapter using macro stepper run lang plai lang ref added let syntactic sugar lambda pattern followed let var val body transformed lambda var body val doesn t sound familiar good time refresh memory work simplest way describing transformation state directly write let var val body lambda var body val fact precisely racket enables ll use instead letbecause deﬁned racket var val body lambda var body val tell racket see expression diately opening parenthesis check follows pattern var val body var valandbody aresyntactic variable variable stand body code particular match position expression match pattern syntactic variable bound corresponding part expression available use noticed additional syntax ll explain case lambda var body val output generated syntactic variable replaced corresponding part input using old friend substitution substitution utterly simplistic make attempt try using racket initially complain provided identiﬁer position let identiﬁer percolate desugaring lambda turn produce error lambda expected id id type function argument immediately tell desugaring process straightforward tion doesn t attempt guess clever instead simply rewrite tuting output expression subject desugaring matter terminology simple form called amacro mentioned earlier ref traditionally form desugaring called macro expansion term misleading output ing smaller input usually larger course racket letcan bind multiple identiﬁers just write informally say board write like let var val body lambda var body val ing zero intent var output spond sequence var input precisely racket syntax var val body lambda var body val observe power notation sequence pair input turned pair sequence output differently racket unzips input quence conversely notation used zip sequence syntax transformer function earlier saw doe attempt ensure syntax identiﬁer position truly syntactically identiﬁer remedy mechanism powerful mechanism called exhibit useful feature ll introduce grow gradually ﬁrst thing understand macro actually function function regular value value function syntax syntax function execute world purpose create program execute observe talking program toexecute actual execution program occur later point actually extremely clear examine desugaring explicitly function kind syntax kind syntax obscured way notation explicit parameter tion header make clear functional transformation rewriting rule format doe allude fact desugaring specify atomic function entire process actually writing little function kind new syntactic construct piece woven ble function control overall rewriting process concrete example inherently clear output macro expanded simple example immediately demonstrates case exercise write macro conﬁrm output macro panded subtlety form macro look like racket code immediately clear life world abstract helpful imagine macro deﬁnitions actually written entirely different language process syntax simplicity misleading practice program called compiler program need power ordinary program necessitated creation parallel language purely processing program wasteful pointless racket instead endows program power racket prelude let s introduce ll begin simply using new notation write header deﬁnition notice explicit parameter x bind xto entire expression imagine simply tell racket deﬁne new macro doe pick precisely want implement leaving free use mechanism s convenient earlier used going use particular need explicitly given access expression x ready express rewrite wanted previously rewriting rule part structure input corresponding output hold ﬁrst matching input second output little different var val body lambda var body val observe crucial extra character let s examine mean entire output simply speciﬁes structure contrast laying bare functional nature mation output fact arbitrary expression perform tations wish simply evaluate piece syntax syntax actually distinct datatype distinct dataype rule construction concretely construct syntax value writing lowing treated syntax value case wondering x bound macro deﬁnition datatype syntax constructor enjoys special property inside output macro syntax variable input automatically bound replaced currence result expander encounter varin output say replaces varwith corresponding input expression remove try using macro deﬁnition happens far merely appears complicated form rule slightly better cleanly delineates functional nature expansion type output simply unwieldy offer signiﬁcant power exercise actually expressed macro deﬁne guard return problem originally motivated introduction case ensuring binding position syntactically identiﬁer need know new feature rewriting rule part present middle treated aguard predicate evaluate true expansion proceed signal syntax error especially useful context predicate identifier determines syntax object syntactically identiﬁer variable write guard rewrite rule incorporate hopefully stumbled subtlety argument identifier type syntax need refer actual fragment syntax bound var recall var bound syntax space substitute identiﬁers bound correct way write guard identifier information write entire rule var val body identifier lambda var body val guarded rule deﬁnition try use macro binding position happens simple macro feature consider implement disjunction natural preﬁx syntax allow orto arbitrary number expand orinto nested conditionals determine truth expression attempt let s try ﬁrst version x x say provide number moment expansion rewrite conditional test ﬁrst true value return value thisin moment disjunction remaining term let s try simple example expect evaluate true instead f t bad syntax happened expression turned f f t turn expanded f f t t deﬁnition s pattern mean ignored case zero happen identity disjunction falsehood exercise fthe right default ﬁlling illustrate macro rule macro rule matched sequentially sure speciﬁc rule ﬁrst lest overridden general one particular case rule yield improved macro x x f expands expect isn t necessary add rule case single x x f e e keep output expansion concise ﬁnd useful observe version macro pattern arenotdisjoint subsumes second essential second rule swap guarding evaluation said expands expect doe let s try following example let init f begin set init init init f observe orreturns actual value ﬁrst truthy value developer use computation return value init expect naturally ve negated value init expect evaluating produce f problem artifact set instead internal mutation say printed output printing occurred understand examine expanded code let init f begin set init init init begin set init init init f aha ve written output pattern looked entirely benign ﬁrst wrote illustrates important principle writing macro program transformation system copy code setting syntactic variable repeated need repeat way cause multiple execution code make sure considered consequence alternatively meant work value expression bind use bound identiﬁer s subsequently easy demonstrate x x f e e let v v v pattern introducing binding creates new potential problem end evaluating expression weren t necessary fact creates second subtle going evaluated evaluate wrong context reason carefully expression evaluated evaluate just right place store value subsequent use repeat previous example contained set result t hoped hygiene hopefully nervous consider macro let v t f v expect compute naturally t ﬁrst branch fbut second v bound let s look expansion let v t let v f v v v expression run directly evaluates let v t f v evaluates word macro magically produce right value name identiﬁers chosen macro independent introduced macro unsurprising happens function macro expander enjoys property called hygiene give property way think hygiene effectively automatically renames bound identiﬁers s program expands follows let v t f v turn let t f notice consistent renaming turn let t let v f v renaming let t let f expansion terminates observe program run directly produce correct answer identiﬁer capture hygienic macro address routine important pain creator syntactic sugar confront rare instance developer want intentionally break hygiene returning object consider input program define x msg self x second x x doe macro look like s obvious candidate object var val let self lambda lambda v error begin set self lambda msg case msg lambda var val self unfortunately macro produce following error self unbound identifier module self referring self body method bound exercise hygienic expansion process understand error expected outcome solve directly let s consider variant input term make binding explicit define self x msg self x second x x corresponding macro small variation object self var val let self lambda lambda v error begin set self lambda msg case msg lambda var val self macro expands difﬁculty exercise work expansion version s different offer critical insight identiﬁer go binding position written macro user problem want able pretend introduced identiﬁer written user function syntax convert second argument ﬁrst argument syntax pretend case original macro use bound x introduce result environment used expansion use bind environment x x object var val self syntax x let self lambda lambda v error begin set self lambda case lambda var val self having self implicit define x msg self x second x x inﬂuence compiler design use macro language s deﬁnition impact tool especially pilers working example consider virtue compiled efﬁciently just extending current environment contrast expansion let function application result expensive operation creation closure application argument achieving effectively result cost time space argument using macro smart compiler recognizes pattern occurs instead internally effectively convert ref equivalent let tages mean language designer freely use macro obtain smaller core language having trade execution cost second subtler advantage compiler recognizes pattern macro exploit obtain optimization don t need contort output insert let term pattern occurs naturally instance pattern occurs naturally writing certain kind extra step convert letin longer necessary desugaring language modern language deﬁne operation desugaring racket python instance iterating using foris simply syntactic pattern developer writes x o introducing new identiﬁer sure capture ithe programmer deﬁned bind ihygienically binding iterator obtained o creating potentially inﬁnite loop repeatedly invokes method iuntil iterator raise stopiteration exception pattern modern programming language control operation term control refers programming language instruction cause ation proceed control program counter machine sense simple arithmetic expression qualify control operation sequential program execution function call return certainly practice use term refer primarily operation cause transfer control especially mere function procedure step exception study operation chapter study following control operator s worth remembering language power control operator change potentially improve way express intent enhance structure program pay study focusing program structure control web let begin study examining structure web program consider following program henceforth ll addition server course understand sophisticated application instance prompt ask starting ending point trip place addition compute route compute airfare computation step entering ﬁrst city airline prompt choice ﬂies display number second number test idea s implementation define prompt string number begin display prompt let v read v number v prompt run console drracket program prompt number display sum suppose want run web server immediately encounter difﬁculty structure web program generate single web asking ﬁrst halt result therest program case prompt second number add print result lost web server behave strange way reason behavior historical technical historical reason web server initially designed serve page static content program ran generate output server offer naturally developer wondered program couldn t run demand web content dynamic terminating program generating single piece output simplest incremental step program page web important stayed technical imagine addition server generated ﬁrst prompt recall siderable pending computation second prompt addition display result computation suspend waiting user s input million user million computation suspended creating mous performance problem furthermore suppose user doe actually complete searching bookstore airline site completing purchase doe server know nate computation doe resource associated computation remain use conceptually web protocol designed stateless store state server associated intermediate computation instead web program developer forced maintain necessary state request need able resume computation practice web proven stateless hews largely direction studying structure program instructive consider web program run inside browser written compiled javascript suppose computation need communicate server primitive called xmlhttprequest user make instance primitive invokes send method send message server nicating server instantaneous complete depending state network leaf sending process suspended designer javascript decided make language thread execution time avoids various peril structuring problem cause various proposal effect add safe thread javascript idea described chapter viewed alternative offer similar structuring arise combining mutation thread result javascript process lock awaiting response happen dlers page longer respond avoid problem design xmlhttprequest demand developer provide procedure responds request arrives callback procedure registered need embody rest processing request entirely different performance avoiding problem synchronization web evolved demand pattern developer let better understand pattern program decomposition later let consider take make program work stateless setting web server determine ﬁrst interaction prompt ﬁrst number racket evaluates argument left right instructive divide program part happens generate ﬁrst interaction run need happen remembered easy number ve explained prose s left s time write program like intentionally ignoring ll return let s pretend s display result interaction second number web server t execute evidently isn t program instead need way writing let s observe characteristic computation need legitimate program need stay suspended request come need refer value ﬁrst tion characteristic clear function lambda display second number partial solution web additional wrinkle web page input element need refer program stored web receive data form process program named action ﬁeld form imagine server generates fresh label store function table associated label refers table action ﬁeld client actually submits form server extract associated function supply form s value resume execution solution stateless let s imagine custom web server maintains table server special version record rest program number lambda display second number test let s implement procedure need representation label number easy substitute label number let s say generates fresh label invocation exercise deﬁne use inspiration need table store procedure representing rest program define table store procedure define prompt string rest let g begin table g rest display prompt display enter use action field label display g run invocation print number enter use action field label tantamount printing prompt web page putting label theaction ﬁeld simulating need represent browser s submission process need label action ﬁeld value entered form given value procedure need extract relevant procedure table apply form value define resume g label n number table g n simulate act entering clicking submit button running resume label user s input unfortunately simply produce prompt haven t fully converted program delete number forced convert entire program number lambda second number lambda display safe make sure computation terminates output adding error invocation end truly ensure extreme form suspension execute program use resume twice number enter use action field label halting program shut resume second number enter use action field label halting program shut resume user input giving total halting message generated error command inserted ve purposely played little coy type interesting part program let s examine type second argument need procedure consumes number return computation eventually produce number similarly return type resume communicate table map label number step computation make progress outcome writes table resume read achieving statelessness haven t actually achieved statelessness large table ing server clear mean remove entry better avoid server state entirely mean relevant state client actually way server hold state reserved right create entry hash table wish constant number linear size program storing table closure holding arbitrary state ll clearly soon let s start eliminating closure instead let s funtion ments named function immediately force ﬁxed number program s size unbounded number define second number define display code block refers real closure value argument come form s just problem free identiﬁer way ﬁx problem instead creating closure step send client stored store browser offer mechanism doing cooky andhidden ﬁelds use interaction state fundamental difference cooky hidden ﬁelds page share cookie page hidden ﬁelds let s consider sequence interaction existing program us interaction point look like number enter use action field label resume second number enter use action field label resume resuming label represent adding given argument form ﬁeld value sure resume far good suppose use label resume second number enter use action field label observe new program execution need resumed using label resume ought ask happens reuse label try resume doing tantamount resuming old computation expect produce answer resume let s create stateful implementation simulate observing closure environment closure share mutable state simulate using existing making sure don t rely closure behavior lambda having free identiﬁers body define cookie number lambda begin set cookie second number lambda display cookie exercise expect sequence happens initially different number enter use action field label resume second number enter use action field label resume reuse initial computation new resumption label resume second number enter use action field label used computes d expect resume come critical step resume unsurprising resumption label produce different answer given rely mutable state reason s problematic happens translate behavior web imagine visiting hotel reservation web site searching hotel city return shown list hotel label explore new tab window produce information hotel label make reservation decide return hotel listing explore hotel fresh tab window produce second hotel s information label reserve hotel decide choose ﬁrst hotel return ﬁrst hotel s page choose reservation submit label hotel did expect booked expected reservation ﬁrst hotel travel site reserve second viewed page reservation button produce error pervasive use cooky web site practice encouraged web apis style function ve writing ve presented idea term web relying older idea function called continuation style program called style cps worth liberty using cps noun verb particular structure code process convert code right basis studying variety trivial control generator earlier converted program web input operation nested inside motivation simple program terminates nested putations lost similar argument applies local sense case xmlhttprequest computation depending result response web server need reside callback associated request server fact don t need transform expression care sion involve actual web interaction example computed plex mathematical expression just addition wouldn t need transform function d absolutely certain function didn t web invocation inside function invokes one theyinvoke defensive transform transform expression t sure performs web interaction heart transformation turn function f extra argument extra argument continuation represents rest computation continuation function argument argument take value returned byfand pass rest computation f instead returning value instead pass value returned continuation cpsis general transformation apply program s program transformation think special kind desugaring particular instead transforming program larger language smaller macro language entirely compiler transforms program language language restricted version obeys pattern ve discussing result reuse evaluator language evaluate program cpssubset implementation desugaring good support desugaring let s use deﬁne form concretely ll implement cpsmacro ref cleanly separate source language target ll use slightly different name guage construct andrecinstead letandletrec laminstead oflambda cnd instead seq forbegin set forset ll sufﬁciently rich language write interesting program presentation follows order case macro believe easiest hardest code macro avoid pattern follows diffent order cps e e rec lam cnd seq set quote display representation cpswill turn expression procedure argument continuation converted expression eventually supply value continuation pas continuation expression preserving invariant value output cpswill look like lambda k rely hygiene ref introduced k s clashing let s dispatch easy case atomic value conceptually easiest written pattern shadow case ideally written ﬁrst provided guard expression precisely deﬁnes syntactic case want treat atomic playing loose becuase focus interesting case atomic case value simply need supply continuation atomic lambda k k atomic similarly quoted constant e lambda k k e know ref ref treat andrecas macro respectively v e b cps lam v b e rec v f b cps v lam arg error seq set v f b easy evaluate new value perform actual update set v e lambda k cps e lambda ev k set v ev sequencing straightforward perform operation turn observe preserve semantics sequencing doe obey order operation value ﬁrst mentioned body second given identiﬁer holding value irrelevant seq lambda k cps lambda cps k handling conditionals need create new continuation remember waiting test expression evaluate value dispatch result return existing continuation cnd tst thn el lambda k cps tst lambda tstv tstv cps thn k cps el k application case consider absolutely need handle treatment procedure created language ment purpose writing example program useful able employ primitive assume simplicity argument procedure written user need conversion cps one primitive perform web control ations invoked directly assume primitive written application position complex expression say perform web interaction application evaluate function argument expression ve obtained ready apply function tempting write f lambda k cps f lambda fv cps lambda av k fv av wrong problem function value value closure potentially complicated body evaluating body example result web interaction point rest function s body pending k rest program lost avoid supply kto function s value let inductive invariant ensure kwill eventually invoked value applying fvtoav f lambda k cps f lambda fv cps lambda av fv av k treating special case binary operation easier f b lambda k cps lambda av cps b lambda bv k f av bv pattern use procedure employ assume application fwill return unusual transfer control function value returned pending computation application case show transform function extra argument continuation point invocation leaf quandary continuation supply body lam b identifier lambda k k lambda cps b place continuation supply continuation supply continuation point closure creation continuation point closure invocation word static dynamic case need use dynamic continuation strange happen program return point closure created used result seemingly strange program behavior wish avoid observe consciously choosing dynamic continuation just scope concerned chose static environment lam b identifier lambda k k lambda cps b finally purpose modeling web programming add input output procedure output follows application pattern ve seen display output lambda k cps output lambda ov k display ov finally input use time generate us force programmer construct prompt lambda k cps prompt lambda pv pv k notice continuation bound ki precisely continuation need stash point web interaction testing code converted cpsis slightly annoying cpsterms expect continuation initial continuation simply consumes value return b consumes value print c consumes value print get ready computation prompt drracket interaction window doe effectively just identity function various guise following deﬁnition helpful testing define run c c identity instance test run cps test run cps lam test run cps lam x x x test run cps lam x x x test old web program run cps display second lest lost myriad code let highlight important lesson ve recovered code structure write program direct style properly nested expression case take care making work suitable underlying api good gramming language ought converting example let s consider example convert hand easy way employ macro stepper drracket assuming need code lang racket force macro include application identity contained run lambda k lambda k lambda k lambda k k lambda pv pv k lambda lv lambda k lambda k k second lambda pv pv k lambda rv k lv rv lambda ov k display ov isn t version wrote hand fact program administrative lambda s duced particular cpsalgorithm used fear stepwise apply designing better cpsalgorithms eliminate needless administrative lambda s ongoing open research lambda s substitute program reduces lambda lv second lambda rv identity display lv rv precisely wanted implementation core ve seen cpscan implemented desugaring ask core instead recall ve said cpsapplies program program especially interested interpreter sure apply cps transformation making available effectively continuation ll ﬁnd convenient use procedural representation closure ref ll interpreter extra argument consumes value given continuation eventually return define expr exprc env env k value value value easy case instead returning value need simply pas continuation argument exprc expr numc n k numv n idc n k lookup n env note multc handled entirely analogous plusc let s start easy case plusc interpret left continuation evaluation interprets right continuation add result happen result addition interp returned whichever computation caused plusc interpreted remember longer return value instead pas continuation plusc l r l env lambda lv r env lambda rv k lv rv implement code multc leaf difﬁcult related piece application interpret apply resulting closure argument ve agreed cation need continuation argument update deﬁnition value value numv n number closv f value value value value decide continuation pas application s tinuation given interpreter appc f f env lambda fv env lambda av fv av k finally lamc case create closv using lambda procedure need argument actual value argument continuation application critical question value essentially choice krepresents static continuation active point closure construction want continuation point closure invocation dynamic continuation lamc b k closv lambda b bind env test revised interpreter need invoke kind tial continuation value need procedure represents remaining computation natural representation identity function define interp expr exprc value expr lambda an an signify strictly interface ve dropped environment parameter pas environment automatically want especially sure haven t accidentally used procedure recursively insert error end prevent returning return value used generator programming language notion generator generator like procedure invoke application regular procedure begin execution beginning generator resume left course mean generator need notion exiting s known yielding returning control called design variation variation generator point variation predictably enter exit generator language generator object instantiated like ject execution resumed invoking method python just like procedure applying like function language value addition regular procedure used application value collectively called applicables language yielding python s yield able inside syntactic body generator racket yield applicable value bound body virtue value passed abstraction stored data structure python s design represents extreme point generator simply function contains keyword yield body addition python s yield passed parameter function performs yielding behalf generator small issue naming language generator yielder automatically called word yield keyword python identiﬁer bound applicable value racket possibility user generator indicate generator expression yielder use look like curiously python expects user determine callself orthis object doe provide ﬂexibility yield way determine function generator generator yield rec f lam n seq yield n f n f equivalently generator y rec f lam n seq y n f n f yielder actual value user abstract yielding generator y rec f lam n seq y n f n f presumably perform actual yielding actually design decision yield statement expression language actually sion meaning value supplied resuming generator make generator ﬂexible user generator use rameter s alter generator s behavior forced use state communicate desired change happens end generator s execution language generator raise exception signal completion implementing generator implement generator especially useful employ cpsmacro guage let s ﬁrst decide stand regarding design decision use applicative representation generator asking value generator applying necessary argument similarly yielder applicable value turn expression seen macro automatically capture ref let s make yielder s explicit macro simpler finally ll raise error generator executing generator work yield generator remember execution currently know caller return invoked remember execution caller currently know body return duality invocation yielding guess s correspond continuation let s build generator rule cps macro incrementally header pattern generator yield v b identifier v identifier beginning body easy code cpsneeds consume continuation generator value value supplied continuation lambda k k ready tackle heart generator recall generator applicable value mean occur tion position interface procedure procedure argument ﬁrst value second continuation point plication procedure ve described just generator remember caller execution precisely continuation point application remember simply mean stored state generator return previously itsown continuation clearly stored core applicable value lambda v begin set resumer v record continuation caller resume ing resumer local continuation generator let s think initial value initial value generator invoked need throw error used fortunately error occur mutated ﬁrst entry generator error just safeguard bug implementation initially rest generator generator resumer bound cpsof continuation continuation entire generator generator ﬁnishes ve agreed signal error case error truly occur case generator asked produce value s equipped need bind yield ve pointed symmetric generator resumption save local continuation resumer return applying putting piece let lambda v error letrec resumer lambda v cps b lambda k error fell yield lambda v begin set resumer v pattern letandletrec instead let observe dependency code fragment doesn t depend resumer oryield clearly depends andresumer resumer andyield mutually referential try alternative subtle dependency missing resumer contains b body generator contain reference yield need closed binding yielder exercise generator differ coroutines thread implement tine thread using similar strategy continuation stack surprising cpsconversion actually provides tremendous insight nature program execution stack ﬁrst thing understand continuation actually stack odd given stack machine primitive continuation seemingly complex procedure stack really s record remains computation tion s traditionally thought list stack frame frame reference frame remaining ﬁnishes similarly continuation small procedure refers close continuation chosen different representation program instruction combining data structure representation closure obtain uation representation essentially machine stack stack frame store procedure parameter implicitly managed procedural representation continuation itly data stucture representation using bind frame space local variable principle doe tinuation using macro implementation local binding ve effectively reduced procedure parameter conceptually true procedure parameter local binding turned procedure parameter macro stack reference doe close heap change heap visible stack frame precisely way closure refer close store change store visible closure traditionally stack responsible maintaining lexical scope automatically using closure language study conversion various term understand mapping stack instance consider conversion function application ref f lambda k cps f lambda fv cps lambda av fv av k read follows let s use kto refer stack present function application begin evaluate begin evaluate function position f create new stack frame lambda fv frame free identiﬁer closure need record element environment rest stack code portion stack frame represents left obtain value function evaluate argument perform cation return result stack expecting result application evaluation fcompletes begin evaluate creates stack frame lambda av frame twofree identiﬁers kand fv tell longer need stack frame evaluating function position need temporary record function evaluating function position code portion second frame represents left invoke function value argument stack expecting value application let apply similar reasoning conditionals cnd tst thn el lambda k cps tst lambda tstv tstv cps thn k cps el k say evaluate conditional expression create new stack frame frame close stack expecting value entire conditional frame make decision based value conditional expression invokes expression examined value frame created evaluate conditional expression longer necessary evaluation proceed ink viewed lens easily provide operational explanation generator generator private stack execution attempt return past end implementation raise error invocation generator store reference stack rest program resume stack referred resumer yielding swap reference stack coroutines thread generator conceptually similar mechanism create little stack instead having single global stack tail call observe stack pattern add frame current stack perform evaluation eventually return current stack particular observe application need stack space evaluate function position argument evaluated resume computation using stack started application word function call need consume stack space need space compute argument language observe respect property language programmer use recursion obtain iterative behavior sequence function call consume stack space function call remove need create special looping construct loop simply expressed syntactic sugar course property doe apply general fis performed compute argument g fis consuming space relative context surrounding really speak relationship sion expression tail position relative evaluation requires stack space cpsmacro expression us ka function application evaluated tail position relative enclosing application recursively contrast expression create new stack frame tail position language special support tail recursion procedure call tail position relative body obviously useful enables recursion efﬁciently implement loop hurt loop squeezed single recursive function instance implementing scanner state machine convenient set function representing state transitioning state making tail function call onerous miss point turn single recursive function language recognizes tail call optimize call just doe one racket particular promise implement tail call allocating additional stack space people refer tail optimization term misleading optimization optional language promise properly implement tail call semantic feature developer need know language behave affect program feature observe interesting program cps transformation function application tail call starting example began chapter pending computation continuation argument assuming program terminate tantamount using stack space stack wiped exercise program able function absence stack continuation language feature insight connection continuation stack return treatment procedure ignored continuation point sure creation instead used point closure invocation course corresponds normal procedure behavior ask use continuation instead correspond maintaining reference copy stack point procedure creation procedure applied ignoring dynamic evaluation going point procedure creation principle trying leave lambda intact instead language construct corresponds behavior current continuation kont b identifier lambda k let kont lambda v k v cps b k say way control return expression ately surround falling continuation body b isk invoking continuation discard dynamic continuation simply ignoring returning kinstead s simplest test test run cps esc conﬁrms use continuation evaluation body proceeds weren t cps b k use value given continuation return point creation test run cps esc esc example course isn t revealing consider test run cps esc esc conﬁrms addition actually happens dynamic uation test run cps esc esc show addition happens dynamic continuation ignored just sure continuation point creation respected observe test run cps esc esc example probably noticed familiar pattern eschere having like exception throw exception case invoke continuation s s throw pending intermediate computation ignored computation return point exception creation exercise using macro create throw mechanism example scratch surface available power continuation point invocation extension point creation just earlier stack demand related mean fact free unrelated mean distinct stack fact easily implement procedure exercise properly analogous lambda introduced struct called say following expansion b identifier lambda k k lambda cps b k didn t consider static typing implication construct behavior using construct instead presentation language writing program little toy language soon frustrating nately racket provides construct called reiﬁes continuation procedure argument procedure argument racket applies current procedure ment got fortunately easily write macro program instead k b lambda k b sure old test pas test esc test esc esc test esc esc test esc esc test esc esc deﬁning generator start create interesting abstraction instance let s build generator previously needed cpsexpressions pas continuation automatically need current continuation simply conjure having transform program extra parameter disappear place capture continuation generator e e generator yield v b let lambda v error letrec resumer lambda v begin b error fell yield lambda v begin set resumer v lambda v begin set resumer v observe close similarity code implementation ators desugaring cpscode speciﬁcally drop extra continuation argument replace invocation capture precisely continuation rest code fundamentally unchanged exercise happens s mutation ﬁrst ment inside begin s instead instance write generator iterates initial value upward define generator yield v letrec loop lambda n begin yield n loop n loop v behavior body refers initial value ignoring returned invoking yield value pas subsequent invocation irrelevant contrast sider generator define generator yield v letrec loop lambda n loop yield n n loop v ﬁrst invocation return value supplied subsequent tions value added provided generator word generator additively accumulates value given exercise ve seen implement generator using implement coroutines thread deﬁning thread having generator let s similar primitive thread let s assume want able write program define d display useful shorthand follows list y d y d y d y d y d y d y d y d y d expect output ll build piece necessary achieve let s start deﬁning thread scheduler consumes list thread interface assume procedure consumes continuation tually yield control time scheduler reactivates thread supply continuation scheduler choose thread simple manner use complex algorithm detail chooses don t concern generator ll assume yielding invoking procedure named user y use capture ref automatically bind like yield importantly notice user thread manually yield control called cooperative multitasking instead chosen timer intrinsic mechanism automtically yield user s permission preemptive multitasking wrests control thread distinction important buildling system interesting perspective setting continuation exercise building cooperative multitasking implement tive multitasking change stated constraint write ﬁrst scheduler consumes list thread continues executing long thread remaining time applies thread procedure continuation represents returning scheduler proceeding thread define thread cond thread con thread begin thread append rest thread list thread recipient thread invokes continuation bound control return end ﬁrst statement begin sequence result value supplied continuation ignored dummy value ll chose dummy easily spot show undesired place control proceeds rest scheduler loop appending recently invoked thread end list thread treating list circular queue let s deﬁne thread ve said procedure argument scheduler s continuation thread need resume continue left presumably store ll initially entire thread body subsequent instance ation speciﬁcally continuation invoking yield obtain following skeleton thread yielder b letrec lambda begin b lambda leaf yielder need procedure argument store thread s continuation invoke scheduler continuation dummy scheduler continuation doe need invoke provided thread initiation recent thread value yielder way accomplish simplest brutal way simply reconstruct yielder thread resumption closed recent value thread yielder b letrec lambda begin b yielder lambda error lambda begin set yielder lambda begin set run ensemble hey s wanted continues hmmm s happening ve quiet need happen thread reach end fact control just return thread scheduler appends thread end queue thread come head queue control resume previously stored continuation corresponding printing value print control return thread appended ad inﬁnitum clearly need thread scheduler notiﬁed thread terminated scheduler remove thread queue ll create simple datatype represent signal threadstatus tsuspended tdone real course status message carry informative value computation modify scheduler actually check use value define thread cond thread con thread threadstatus thread thread tsuspended append rest thread list thread tdone rest thread modify thread representation way provide pended scheduler s continuation intermediate return provide tdone terminates doe terminate executing code body b observe ﬁnally termination process sure use latest scheduler continuation just yielding doe thread yielder b letrec lambda begin b finisher finisher lambda error yielder lambda error lambda begin set finisher lambda tdone set yielder lambda begin set tsuspended replace example program just output desire better primitive web programming finally tie knot began let s return observe language running server program instead having cps entire program simply capture current continuation save hash table leaving program structure intact checking program invariant statically type program grow larger subtle developer need tool help scribe validate statement program invariant invariant gests statement program element expected hold element example write x number typed language mean thatxwill hold number part program depend x rely statement enforced type just point spectrum invariant wish state static type diverse family point spectrum method use enforce invariant type static discipline chapter focus especially static type checking checking clared type program executes experienced form program virtue using typed programming language explore design space type finally static typing especially powerful important form invariant enforcement examine technique available consider program typed language define f n number number n f x static type error program begin execution program type annotation ordinary racket fails runtime define f n n f x exercise test assertion fails program cutis fails execution consider following racket program define f n n fails program execution begin parse error think parsing distinct assumes parsed program begin useful think parsing simply simplest kind determining ically program obeys free syntax asks obeys sensitive richer syntax short generalization parsing concerned syntactic method ing discipline program classical view type begin introducing traditional core language type later plore extension ref variation ref simple type checker deﬁne type checker ﬁx thing syntax typed core language syntax type begin ll return language ref fore added mutation complication ll return later language add type annotation conventionally don t impose type annotation constant primitive operation addition instead impose boundary function method course study explore good locus annotation given decision typed core language tyexprc numc n number idc s symbol appc fun tyexprc arg tyexprc plusc l tyexprc r tyexprc multc l tyexprc r tyexprc lamc arg symbol argt type rett type body tyexprc procedure annotated type argument expects type argument purport produce decide language type follow tradition type abstract set value language kind value value numv n number closv arg symbol body tyexprc env env follows kind type number function numeric type straightforward information doe number type need record language actually numeric type single represents number ignored gradation number ref s sufﬁcient just having decided record additional information number principle soon run decidability problem function information type expected argument type claimed result record information given unless proven useful combining obtain following abstract language type type numt funt arg type ret type ve ﬁxed term type structure language let s make sure agree constitute type error language ﬁat type error pas type checker obvious form type error argument number numt argument number expression function position application function funt actually missing expression function position application function type actual argument doe match type formal argument expected function clear program language ought natural starting signature procedure consumes expression return boolean value indicating expression know expression contain identiﬁers soon clear want type environment map name type ogous value environment seen far exercise deﬁne type function associated type environment begin program follows define tc expr tyexprc tenv tyenv boolean tyexprc expr abbreviated set case suggests approach work ll soon let s begin easy case number doe number course doe surrounding context expecting number error signaled numc n true let s handle identiﬁers identiﬁer appear provided actually bound identiﬁer context desire hopefully handled write idc n lookup n tenv true error bound identifier make little uncomfortable lookup signal error identiﬁer isn t bound s need repeat error invocation let s push tackle application function make sure s function ensure actual argument s type consistent function declares type formal argument instance function number application function vice versa case want prevent doe code look appc f let ft tc f tenv recursive tccan tell function expression check doe know type immediate function reach syntax pull argument return type complex expression need procedure calculate resulting type expression course procedure provide type expression able provide coherent answer word type calculator type checking special case strengthen inductive invariant tc tell expression typed type giving type conﬁrms expression type signal error let s deﬁne richer notion type checker define tc expr tyexprc tenv tyenv type tyexprc expr let s ﬁll piece number easy numeric type numc n numt similarly identiﬁers type environment say aren t bound signal error idc n lookup n tenv observe far similarity difference interpreting identiﬁer case did essentially thing returned type actual value numeric case returned abstract number indicate speciﬁc number let s examine addition make sure meric type overall expression evaluate number plusc l r let lt tc l tenv rt tc r tenv equal lt numt equal rt numt numt error number ve usually glossed multiplication considering addition instructive handle explicitly multc l r let lt tc l tenv rt tc r tenv equal lt numt equal rt numt numt error number did s different s right practically multc instead plusc slightly different error message notwithstanding s perspective type language difference addition multiplication anytwo function consume number return observe difference interpreting care argument number interpreter return precise sum product indifferent difference sion computes return numt constant constant case finally hard case application funcions ve discussed application compute value function argument sion ensure function expression function type check argument expression compatible type hold type overall application type function body return value eventually return result evaluating function s body appc f let ft tc f tenv tc tenv cond funt ft error function equal ft error app arg mismatch ft leaf function deﬁnitions function formal parameter presumably used body unless bound environment body probably properly extend type environment formal bound type extended environment body value computes declared type body function function type type argument type body exercise say probably lamc argt rett b equal tc b bind argt tenv rett funt argt rett error lam type mismatch observe curious difference interpreter interpreter application responsible evaluating argument expression ing environment evaluating body application case doe check argument expression leaf environment simply return type body traversing instead body actually traversed checker checking function deﬁnition point environment tually extends conditionals suppose extend language conditionals humble duce design decision ll discus return later ref type test expression language uate boolean value case enrich type language include booleans probably good idea guages value value considered truthy falsy relationship language type single unambiguous type overall expression type language branch distinct type greatly change design nature programming language exercise add booleans type language doe entail minimum expected typical language exercise add type rule conditionals test expression expected evaluate boolean type type overall expression recursion code ve obtained basic programming language let s add recursion saw earlier ref easily desugaring ll prove complex story attempt typing recursion let s try express simple recursive function simplest course loop forever write inﬁnite loop just function simply lambda x x x lambda x x x know represent language function value exercise doe construct inﬁnite loop subtle dependency making nature function call typed language force annotate function let s annotate simplicity ll assume writing program typed surface syntax desugaring take care constructing core language term observe ﬁrst identical term applied ically overall term called capital omega greek identical called omega greek given identical term precisely type depends invariant want assert context use case observe xbinds ond go ﬁrst second position result typing effectively type let s try type let s type s clearly function type function take argument form argument s type value going type expands expands word type written ﬁnite string did notice subtle important leap just program termination observed obvious typing entail typing run problem jumped conclusion type written ﬁnite string ve given intuition proof fact stranger true type ve deﬁned far type strong statement actually say stronger typed language far property called strong normalization pression type terminate computation ﬁnite number step word special peculiar inﬁnite loop program isn t t type t type anyinﬁnite loop potential inﬁnite loop rough intuition help ﬁnite ﬁnite number s application discharge perform ﬁnite number application language permitted program unsurprising conditionals function passed value encode datatype want guarantee make somewhat astonishing result exercise encode list using function untyped typed language doe tell impact type encoding result say deeper show contrary type prevents buggy program type change semantics language previously write inﬁnite loop just line write show type establish invariant just particular program language want absolutely ensure program terminate simply need write language pas type checker guarantee possible use language program terminate purpose programming course specialized domain s dously useful guarantee instance suppose implementing plex scheduling algorithm like know scheduler guaranteed terminate task scheduled actually run main beneﬁt guarantee router event processor device initializer conﬁguration ﬁle callback javascript compiler linker case unstated expectation program terminate language offer impossible test hypothetical example standard ml language language linking module us essentially typed language writing module linking speciﬁcations mean developer write quite sophisticated guaranteed linking terminate producing recursion say able handle rec entirely desugaring make explicit typed language simplicity consider special case cover common recursive identiﬁer bound function surface syntax write rec n num n n n summation function function nit argument num type consumed returned function expression represents use function sum number type expression clearly nbound body function type course use function know typing function obviously bound type environment checking use type num num bound type checking body function observe type returned body match declared return type break shackle ﬁniteness type tainly true write ﬁnite number s type program source rule typing recursion duplicate body refers ensuring inexhaustible supply application s inﬁnite quiver arrow code implement rule follows assuming fis bound function s atis function s argument type rtis return type bi function s body uis function s use recc f rt b u let bind f funt rt tenv cond equal rt tc b bind error body return type correct tc u recursion data seen type recursive program doesn t enable create recursive data kind recursive function haven t seen developer create recursive datatypes recursive datatype deﬁnitions speak allowing programmer create recursive data actually talking different facility creating new type letting instance new type ﬁelds letting ﬁelds refer instance type fact allow allow allowing type conﬂuence design criterion lead commonly called algebraic datatype type supported typed language instance consider following deﬁnition binary tree number later ref discus type parameterized btnum btmt btnd n number l btnum r btnum observe new datatype btnum able refer ot btnd similarly ability btnum able deﬁne btmt wouldn t able terminate recursion finally course need multiple ﬁelds btnd construct useful interesting data word mechanism packaged useful conjunction langauges permit deﬁnition structure return impact design decision type later ref concludes initial presentation recursive type fatal problem actually explained new type btnum come pretend baked simply impractical changing new recursive type like modifying interpreter time program contains recursive function instead need ﬁnd way make deﬁnitions intrinsic type language return problem later ref style data deﬁnition known sum product uct refers way ﬁelds combine variant instance legal value btnd legal value ﬁelds supplied btnd constructor sum aggregate variant given btnum value just think product sum introduced type impact doe datatype deﬁnition introduces new type us deﬁne constructor predicate selector instance example ﬁrst introduces btnum us ascribe following type btmt btnum btnd number btnum btnum btnum btmt btnum boolean btnd btnum boolean btnum number btnum btnum btnum btnum observe salient fact constructor create instance btnum reﬁned discus design tradeoff later ref predicate consume value type btnum type tell type value need distinguish variant type selector really work instance relevant ncan work instance btnd instance btmt don t way express static type lack suitable static type applying result dynamic error static caught type say recursive type return shortly ref desugaring observe type thing left provide account instance write expression btnum t btmt btnd nv lt rt seen ref written term function deﬁned simulate binding using let cond btmt t btnd t let nv t lt t rt t short macro doe need core language instead delegated desugaring turn mean language different mechanism s quite true macro generates code term cond need know positional selector btnd respectively information explicit type deﬁnition implicitly present use point information communicated deﬁnition use macro expander need akin type environment accomplish task observe furthermore expression reliable identiﬁed expression macro expansion pands use expansion depends type environment depends result expansion word otic need happen quite parallel building desugaring typed language syntactic sugar make assumption type little intricate doing untyped language type time space evident type bestow performance beneﬁt safe language check performed argument performed statically typed language annotation like number answer question particular type ask result predicate need disappear entirely need use program cost developer convince static type program doe induce type error limitation decidability program run error run afoul type ertheless program meet requirement type provide notable execution time saving let s discus space language needed store information attached value indicating type implement predicate number used developer primitive predicate disappear doe space needed hold information implement longer necessary needed garbage collector representation bibop greatly reduce space predicate left variant btmt andbtnd example applied instance noted selector like perform check course tions possible consider code generated desugaring need selector implement check control gotten btnd returned true vlaue provide just desugaring level access special unsafe primitive perform check resulting generated code cond btmt t btnd t let nv t lt t rt t net result representation store information accurately answer question previously needed use bit record possible type variant type statically segregated type variant kind string need store variant information mean use available bit store actual dynamic value contrast variant present sacriﬁce bit distinguish variant number variant type obviously far smaller number variant type type btnum ple variant need use bit record variant btnum value represents observe particular type s segregation prevents confusion different datatypes variant untyped world variant require distinct representation contrast typed world representation overlap type static type ensure type s variant confused type genuine space saving representation time eliminating check performance beneﬁt program type mutation covered basic feature core language tion way type simple interaction mutation classical setting don t interact consider instance following untyped program let x begin set x set x type x doesn t really time s number later note temporal word s string simply t type general type checking atemporal activity program run independent speciﬁc order program execute keeping track precise value store reach example course easy statically understand mislead simple example suppose instead program like let x enter number set x set x literally impossible reach static conclusion type xafter conditional ﬁnishes know user entered avoid morass traditional type checker adopt simple policy type invariant mutation mutation variable mutation structure change type mutant ples type type language far ﬂexibility give programmer function type language instance admit ﬂexible type stand number string example type xwould precise type us xwould contend reduced speciﬁcity issue return later ref short mutation easy account traditional type rule simply value change way level speciﬁcity type type change case operation like set core language s setc mean type assigned value match variable case structure mutation box mean assigned value match box s contained type central theorem type soundness seen earlier ref certain type language offer strong rem program instance program language terminate general course obtain guarantee added general recursion precisely let write unbounded loop meaningful type wish bestow noble title type provide kind meaningful guarantee typed program repeatedly used term type type usually combination component language type set type rule algorithm applies rule program largely presenting type rule embedded function blurred distinction second thought intellectually payoff programmer typing program tain certain bad thing certainly happen short just useful sufﬁcient basis building level tool obtaining security privacy robustness guarantee theorem want type remember type checker run static program execution doing essentially making prediction program s behavior instance state particular complex term type num effectively predicting run term produce numeric value know prediction sound type checker lie type accompanied theorem prof good reason suspicious type general ticism difference way type checker program evaluator work type checker see program text evaluator run actual store type environment bind identiﬁers type evaluator s ment bind identiﬁers value location type checker compress inﬁnite set value type evaluator treat distinctly type checker terminates evaluator type checker pass body expression evaluator pas body zero inﬁnite time assume correspond central result wish given called soundness say suppose given expression program conclude type run e let say obtain value v type standard way proving theorem prove part known progress andpreservation progress say term pass able make step evaluation unless value preservation say result step type original interleave step ﬁrst progress preservation repeat conclude ﬁnal answer type original type sound instance consider expression type num sound type progress offer proof term type value step clearly step program reduces sure preservation prof type original num progress say step producing preservation show type previous intermediate expression num progress ﬁnds answer step left taken answer type given original expression isn t entire story caveat program produce answer loop forever case theorem strictly speaking doe apply observe intermediate term type program computing meaningfully isn t producing value rich language property decided statically language designer chose property array index meaningful type program implicit type soundness theorem set published permitted exception error condition occur developer us type implicitly sign accepting set example set user typical typed language acknowledges vector dereference list indexing yield exception caveat look like fact easy forget really statement happen exception set provably raised course language designed static type ﬁrst place clear loose analogy exception cause need deﬁne retroﬁt type existing programming language dynamic ment racket set exception explicitly stating set exception application position method simply occur payoff programmer receives return accepting type s syntactic restriction extension core basic typed language let s explore extend obtain useful programming language explicit parametric polymorphism string string listof string quite ﬁrst alike ﬁrst java typed language second different clear good read parameterized type language programming demonstrates value parametric polymorphism instance type mapis given b listof listof b say type aand b map consumes function generates b value avalues list avalues generates corresponding list bvalues aand bare concrete type type variable terminology properly called type identiﬁers don t change course instantiation stick traditional terminology different way understand actually inﬁnite family map function instance mapthat type number string listof number listof string type say type base type number number number listof number listof number number type say aand bcan t string string listof string listof string different type need different name num make different function d refer speciﬁc maprather generic one obviously impossible load function standard library s inﬁnite number d way obtain function demand naming convention offer hint map take parameter type given pair type argument obtain amap customized particular type kind parameterization type called parametric polymorphism confused polymorphism object discus ref parameter explicit word effectively saying mapis actually function argument type actual value function list language explicit type try write define map b f b l listof listof b raise question go place type ofaandb aandbare going replaced type type type second really want calling mapwith argument instantiation really mean type parameter ﬁrst actual value answer question actually lead rich space polymorphic type system notexplore recommend reading pierce s type programming language modern accessible start parameterizing code expect end parameterized instance consider type humble con type really parametric type value list doesn t actually depend value bit ref use con instantiated appropriate type matter instantiated create list correct type course java programmer familiar pain polymorphism instead limit particularly useful tractable point space type standard ml typed language book earlier version haskell roughly java c generic roughly obtained using template language deﬁnes called predicative orprenex polymorphism answer question yes let s explore ﬁrst divide world type group ﬁrst group consists type language ve used extended include type variable called monotype second group known polytypes consists parameterized type conventionally written preﬁx list type variable type expression use variable type mapwould b b listof listof b logic symbol read type b type mapis polymorphism type variable substituted type furthermore concrete type left substitute remaining type variable result obtain clear ration type regular parameter don t need provide type annotation type variable know precisely kind thing produce relatively clean language offer considerable expressive power impredicative language erase distinction monotype polytypes type variable instantiated polymorphic type variable replaced monotype independent result type parameter brought parameter list enables write type form tv t tvare type variable ti monotype refer variable justiﬁes syntax prenex prove useful implementation interpreting polymorphism desugaring simplest implementation feature view form desugaring essentially interpretation taken differently form template happy accident obtains form polymorphism use template instance imagine new syntactic form take type variable body provision type replaces type variable given type body id t lambda x t t x deﬁnes identity function ﬁrst deﬁning idto polymorphic given concrete type t yield procedure argument type t t ti priately substituted instantiate idat different define id number define id string obtaining identity function type test test x x contrast expression like x expect fail fail case curious s implementation simplicity assume type parameter easy generalize using deﬁne macro itwill turn deﬁne macro tyvar body stx stx type tyvar given deﬁnition id t lambda x t t x language creates macro named id begin example isid instantiation id id number replaces tthe type variable tyvar given type vent hygiene use force us type variable tyvar actually replaced given type effect define id number turn define lambda x number number x approach important limitation let s try deﬁne recursive polymorphic function filter earlier said ought instantiate single polymorphic value con andempty type code concise ll rely fact underlying typed language doe focus just type parameter filter s code filter t lambda f t boolean l listof t listof t cond l con l f l con l filter t f rest l filter t f rest l observe recursive us filter instantiate appropriate type perfectly good deﬁnition s just problem try use define filter number drracket doe terminate speciﬁcally macro expansion doe terminate repeatedly trying make new copy code filter contrast write function follows expansion t letrec fltr lambda f t boolean l listof t listof t cond l con l f l con l fltr f rest l fltr f rest l fltr needlessly push pain user template expanders cache previous value expansion avoid code given parameter racket general body macro depend mutable variable value perform output racket guarantee given input generate output consider instantiation identity function compare different type type eq test eq id number id number f use idcreates new copy body optimization mentioned applied type code body different code body different unnecessary s absolutely body template notorious creating code bloat instance actually depends type argument entire inﬁnite family idfunctions share just implementation simple desugaring strategy fails provide word desugaring based strategy essentially tation substitution largely problem saw earlier regard substitution implementation parameter instantiation case substitution give ground truth expect program s behavior true polymorphism soon ref observe virtue desugaring strategy doe require type checker know polymorphism core type language continue monomorphic polymorphism handled entirely sion offer cheap strategy adding polymorphism language introduces signiﬁcant overhead finally focused function preceding discussion ply equally data structure alternate implementation implementation strategy don t suffer problem won t essence caching approach sketched certain given set type parameter typed body need instantiate polymorphic function type twice avoids inﬁnite loop check instantiated body avoid checking instantiation type body changed furthermore need retain instantiated source checked expanded program dispose expanded term retain just copy avoids problem discussed pure desugaring strategy shown retaining beneﬁts actually little glib beneﬁts static type enable pick precise representation instance static type tell number matter value value effectively boolean compiler generate specialized code representation taking advantage bit laid example booleans packed single word used type polymorphic instantiator track special type function data structure used provide information compiler result copy function areeq good reason operation truly different rightly relational parametricity s address regarding polymorphism earlier said function like con doesn t depend speciﬁc value argument true map filter mapandfilter want operate individual element parameter function turn responsible making decision treat element mapandfilter simply obey parameter function way test true substitute different value argument list correspondingly different parameter function imagine relation set value convert list element according relation parameter function question output map andfilter predictable relation input true output map mapinspected actual value did information fact won t happen map standard polymorphic function function obey relational rule called relationally parametric read wadler s theorem free reynolds s type abstraction parametric polymorphism powerful property type tell strong limit kind operation polymorphic function perform essentially drop duplicate rearrange element directly inspect make decision ﬁrst sound impressive inspection alize doesn t square experience java instance polymorphic method use instanceof check particular kind value obtained change behavior accordingly method relationally parametric relational parametricity equally viewed web ﬁnd property described inability function inspect quite weakness language permit limited set erations inspect act learned make inspection pointless want simulate relational parametricity remove operation like instanceof various proxy instance adding value catching exception reveal value number elegant surprising result show power program reasoning possible rich type system type inference writing polymorphic type instantiation awfully frustrating cess user version java attest imagine program single time wrote orrest instantiate type reason able avoid fate language implement type inference enables write deﬁnition define mapper f l cond l con l con f l mapper f rest l programming environment automatically declare mapper b listof listof b correct type general type process able derive general type just program structure feel magical let s look curtain let s understand type inference doing people mistakenly think language inference having type declaration inference taking place confused multiple level thing language inference programmer free documentation purpose declare type furthemore absence declaration inference undecidable programmer choice declare type finally writing explicit annotation greatly reduce indecipherable error quite clear inference actually mean instead better think underlying language fully explicitly like polymorphic language just studied ref simply say free leave type annotation s blank assume programming environment feature ﬁll far drop s extra embellishment let inserted automatically inference simply user convenience alleviating burden writing type annotation language underneath explicitly typed think inference doe suppose expression program e written explicitly typed language ehas type annotation required suppose erase annotation e use procedure infer deduce property expect infer demand thing produce precisely annotation eoriginally problematic reason e case infer possibly know strike pedantic triﬂe e didn t erasing annotation ﬁlling make program care reasoning correct suppose eis lambda x number string x procedure obviously fails erase type obtaining lambda x x equally obviously obtain typeable function reasonable mand original version notation replaced inferred type implication useful way doe say happen efails doe preclude type inference algorithm make identity function typeable importantly assures lose employing type inference program previously typeable cease mean focus using explicit annotation want forced course hold inference decidable expect version type type given function lambda x number number x type number number applying inference erasing type yield general type relating type giving precise deﬁnition type equality trivial brieﬂy return issue later ref preliminary way ready delve ic type inference important thing note simple descent algorithm ref longer work possible annotation function boundary descend tion body carrying information annotation type environment sans annotation clear descend fact clear particular direction make sense deﬁnition like mapper fragment code inﬂuences instance applying con rest tolall point list list t tell operation fact apply fto element mean list member type passed similarly know output list con andempty element return type finally note subtle argument list return l know bound point using leaf type return free kind list constrained freturns using force type argument list information function extract systematically algorithm terminates enjoys property stated step generate constraint based program term type solve constraint identify inconsistency join constraint spread function body step relatively simple combination creates magic constraint generation goal ultimately ﬁnd type ﬁll type annotation position prove just ﬁnd type expression moment s thought likely necessary instance determine type function knowing type body sufﬁcient expression type calculated include one need annotation generate constraint later solve constraint generation walk program source emitting appropriate constraint expression return set constraint work recursive descent mainly simplicity really computes setof constraint order traversal generation really doe matter pick recursive descent simplicity use list represent set constraint simply statement type expression addition binding instance variable expression calculate type function requires argument return type general say type expression related type identiﬁer related type expression number function domain range type presumably strained deﬁne following datatypes constraint eqcon lh term rh term term texp e exprc tvar s symbol tnum tarrow dom term rng term deﬁne process generating constraint define cg e exprc listof constraint exprc e expression number say expect type expression numeric numc list eqcon texp e tnum sound trivial don t know expectation expression containing possibility outer expression contradict assertion expression s type numeric leading type error identiﬁer simply say type expression expect type identiﬁer idc s list eqcon texp e tvar s context limit type expression s type automatically ited consistent context expects addition give ﬁrst look contextual constraint addition sion ﬁrst make sure generate return constraint expression complex expect numeric type form mands type numeric lead type error finally assert entire expression s type numeric just version append plusc l r cg l cg r list eqcon texp l tnum eqcon texp r tnum eqcon texp e tnum case multc identical variant interesting case function declaration tion case remember generate return constraint expression function deﬁnition type function function arrow type argument type formal parameter return type body lamc b append cg b list eqcon texp e tarrow tvar texp b finally application directly state constraint type application say function application position consume argument actual parameter expression s type return type application expression s type appc f cg f cg list eqcon texp f tarrow texp texp e s ﬁnished generating constraint just solve constraint solving using uniﬁcation process used solve constraint known uniﬁcation uniﬁer given set equation equation map variable term datatype note subtle point actually twokinds variable tvar andtexp variable evidently equally need solve type expression alternate formulation introduce fresh type variable expression need way identify one correspond expression eq expression doe automatically generate far larger constraint set making visual inspection daunting purpose goal uniﬁcation generate substitution mapping variable term contain variable sound familiar set simultaneous equation variable used linearly equation solved using gaussian elimination context know end system thing happen soon uniﬁcation algorithm work iteratively set constraint constraint equation term term kind essentially sixteen case consider fortunately cover sixteen fewer actual code case algorithm begin set constraint substitution constraint considered removed set principle mination argument utterly simple prove slightly tricky reality constraint disposed substitution set tends grow constraint disposed uniﬁcation return ﬁnal substitution set given constraint uniﬁer examines equation variable ripe elimination uniﬁer add variable s substitution truly eliminate replaces occurrence variable substitution practice need implemented efﬁciently instance using mutational representation variable avoid having occurrence setting need backtrack presence uniﬁcation ref mutational implementation disadvantage did notice subtle error subtle error said uniﬁer eliminates variable replacing instance substitution assumes doe contain instance variable circular deﬁnition impossible perform particular substitution reason uniﬁers include occurs check check variable occurs side doe decline unify term constraint trigger occurs check remember let consider implementation uniﬁcation traditional denote substitution greek letter subst listof substitution substitution sub var term term define unify c listof constraint subst let s easy part way define c listof constraint subst subst cond c con c let l c r c term l ready heart uniﬁcation depend function signature term term subst subst expect perform occurs test fails circularity extends substituion replaces existing instance ﬁrst term second substitution similarly assume existence lookup term subst optionof term exercise deﬁne andlookup constraint equation variable ﬁrst look stitution present replace current constraint new extend substitution tvar s optionof term lookup l bound con eqcon bound r rest c rest c l r logic applies expression designator texp e optionof term lookup l bound con eqcon bound r rest c rest c l r base type number examine possibility different kind term number equation claim type num type num patently true ignore tell remainder course question constraint come ﬁrst place clearly constraint generator did generate constraint prior extension current substitution resulted situation practice encounter function type clearly type error numeric function type disjoint generated straint directly resulted prior substitution variable kind carefully arranged constraint generator thermore substitution introduce case occur result following code tnum term r tnum rest c error number finally left function type argument exactly numeric type tarrow d r term r tarrow con eqcon d con eqcon r c error arrow note shrink size constraint set simple gument doe sufﬁce proving termination instead make argument based size constraint set size substitution including number variable algorithm general work sort type term number function used number form base type function similarly stand constructed type listof vectorof uniﬁcation produce substitution traverse substitution ﬁnd type expression program insert type annotation accordingly theorem prove dictate success process implies program need explicitly run program observe nature type error changed dramatically previously algorithm walked expression using type environment binding type environment type taken intended authoritative speciﬁcations type result mismatch blamed expression reporting type error simple easy understand type error failure tify uniﬁcation failure based event occur conﬂuence smart generation ily comprehensible programmer particular equational nature constraint mean location reported error location true error quite far apart result producing better error message remains active research area practice algorithm maintain metadata program source term involved probably history uniﬁcation able trace error source remember constraint precisely dictate type variable equation clash resulting type error instead mean don t information make deﬁnitive statement expression instance expression lambda x x constraint indicate type x entire expression error simply mean xi free anytype word type type x type x constraint type underconstrained identiﬁers presented type variable expression s type reported uniﬁcation algorithm actually wonderful property automatically putes general type expression known principal type actual type expression obtained instantiating inferred variable actual type remarkable result example computer beating human say human generate general type algorithm unfortunately type variable superﬁcially similar phism earlier ref consider following program let id lambda x x id true id id write explicit type annotation id boolean true id number id number use type inference doe s type ofidunify boolean number depending order constraint processed point ideffectively boolean boolean number number function use idof type type error reason type inferred uniﬁcation actually polymorphic important remember just type variable haven t seen polymorphism type variable uniﬁed use point end mere monomorphic function true phism obtains true instantiation type variable language true polymorphism constraint generation uniﬁcation instead language like ml haskell typed programming language implement colloquially called strategy term type variable bound lexical context type automatically promoted quantiﬁed use term effectively automatically instantiated implementation strategy accomplish naive unsatisfying merely copy code bound identiﬁer use idabove get copy lambda x x get type variable ﬁrst type second b b c c type variable clash effect phism obviously increase program size doe work presence recursion give insight better solution instead copying code just copy type use create renamed copy inferred type id s b b ﬁrst use achieving effect copying code burden strategy effectively mimic copying code work lexical context union type suppose want construct list zoo animal kind madillos boa constrictor currently forced create new datatype texas ain t middle road yellow line dead hightower animal armadillo alive boolean boa length number make list listof animal type animal represents union armadillo andboa way construct union make new type time want represent union animal plant need livingthings animal animal plant p plant actual animal extra level deep datatypes called tagged union ordiscriminated union introduce explicit tag inators animal andplant tell apart turn structure reside inside datatype declaration create datatypes just variant constraint eqcon lh term rh term hold datatype ve use type constraint eqcon type variant distinguished way point union type represent disjunction value s type type union value usually belongs type union function precisely union type deﬁned rule normalizing structure type natural reaction lift restriction allow structure exist deﬁne type union collection structure language ranging c racket programmer deﬁne structure having wrap type tag constructor instance raw racket write struct armadillo alive struct boa length comment say animal armadillo boolean boa number enforced static type comparison messy directly compare typed racket typed form racket built drracket typed code lang struct armadillo alive boolean struct boa length real foot deﬁne function consume value type boawithout reference armadillo s http define b boa boolean b fact apply function type including armadillo true static error armadillo related boa number string course deﬁne union type animal u armadillo boa function define animal boolean cond boa armadillo type variant type just happens type form union convenience deﬁne untagged union appear need discriminative tag don t language union type effect optionof type constructor tained combining intended return type disjoint representing failure ness instance moral equivalent optionof number maybenumber u number boolean matter boolean union true andfalse typed racket accurate simulation option type maybenumber u number false generally deﬁne struct maybeof t u t work type new distinct type confused give beneﬁt optionof type value want buried level deep inside structure available immediately instance consider member typed racket type listof u false listof element member return false return list starting element onward ﬁrst element list desired element member list convert use maybeof write define t e t l listof t maybeof listof t let v member e l v v element return value return list list need remove list wrapper discriminating untagged union s thing value union consider manner type use stylized language identify pull apart piece particular write define animal boolean animal armadillo boa l l type aremains entire expression identiﬁers andlare bound boolean numeric value respectively consume type armadillo andboa different term function consumes boa type contrast union type boatype follow principle act asking predicate value narrow type instance thecond case boa abegins type animal pass boa test type checker expected narrow type just boabranch application turn rest conditional type case leaf possibility armadillo put greater pressure checker s ability test recognize certain impossible program union type default recognizing just pattern recognized retroﬁtting type unsurprising typed racket us union type especially useful retroﬁtting type existing programming language program deﬁned type discipline mind scripting language common principle retroﬁtted type statically catch dynamic exception possible course checker ultimately reject program unless implement interesting idea called soft typing reject program provides information point program reject program run error developer unlikely adopt program written mind type checker need heroic length accept considered reasonable idiom language consider following javascript function var slice function arr start stop var result var stop start result arr start return result consumes array index produce dice instance slice produce javascript developer free leave trailing argument function elided argument given special value undefined function cope instance typical implementation splice let user drop argument following deﬁnition var slice function arr start stop typeof stop undefined stop var result var stop start result arr start return result automatically return subarray end array slice return typed javascript programmer explicitly indicate function s willingness built brown arjun guha web accept fewer argument giving parameter type u undefined giving type t array t int int u undefined array t principle mean potential type error expression stop start stop number assignment stop set numeric type precisely elided user word control path stop eventually numeric type subtraction occurs function course requires able reason conditional state assignment ensure function typed javascript bless function design choice language union type common structure type represented using class datatypes variant ad hoc collection structure represent particular type use sentinel value represent failure convert program written style type discipline tremely onerous retroﬁtted type system adopt union type ease process typing property ﬁrst morally neutral warrant discussion address reverse order let s tackle sentinel ﬁrst case sentinel ought replaced exception language exception costly velopers prefer make distinction truly exceptional ought situation expected normal course ation checking element list failing ﬁnd clearly category knew element wasn t present need run predicate case using sentinel reasonable square observation failure check ceptional sentinel value common source security c program easy reconcile c sentinel type effectively type regular return value furthermore check sentinel used legitimate value type error result sentinel treated address allocate data potentially crashing contrast sentinel truly new type used tion easily reason observing existing function language consume value type setting aside use ad hoc pejorative different grouping set structure good idea fact grouping occur program using discipline programmer want carve different universe larger instance ml programmer use type like sexp numsexp n number strsexp s string listsexp l listof sexp represent function operates just subset just number list create fresh type convert value type underlying representation essentially identical example consider set cpsexpressions clearly subset possible expression create fresh datatype able use existing program process interpreter word union type appear reasonable variation type seen earlier union type design variation consequence instance type create new union named union permitted expression like true allowed type u number boolean type error introduce union previously named explicitly identiﬁed typed racket provides construct truly ad hoc union arguably better importing existing code typed setting ﬂexible clear good design writing new code union programmer did intend occur way prevent offer unexplored corner design space programming language nominal versus structural system initial type considered equivalent structure fact offered mechanism naming type clear alternative consider typed racket developer write u number boolean u number boolean followed define v suppose developer deﬁnes function define f x x try apply ftov f v application type perfectly reasonable interpretation say vwas declared type different considered different type application result error called nominal type paramount determining type equality contrast interpretation structure identical way developer write program behaves differently value type type considered identical want especially careful note difference considered actually won t issue consider implication compiler writer choosing representation value especially language allows inspection static type type called structural successfully type expression typed racket follows structural discipline reduce burden importing existing untyped code usually written structural pretation mind fact typed racket type f v print result having type despite return type annotation f difference nominal structural typing commonly tentious language return issue brieﬂy later ref point section illustrate question trinsically object language permit type programmer contend question naming merely nience choice name intended meaningful choosing answer lead structural typing choosing lead nominal path intersection type ve just explored union type naturally wonder alsointersection type union type mean value type belongs type union intersection type clearly mean value belongs allthe type intersection conjunction strange value belong type concrete answer consider overloaded function instance guages number string given number produce ber given string produce string language proper type number number number reject use string reasoning string string string u number number number string string string just function truly ascribe type number u string number u string number u string reﬂecting fact argument result type doing lead loss precision way doe type lose precision observe type return type allinvocations number u string return distinguish beween numeric string return type error know given numeric ments numeric result information lost type subtly type permit argument s type chosen independently according type invocation x perfectly valid produce value type number u string course addition ation speciﬁed deﬁned input proper type ascribe form addition number number number string string string reminiscent conjunction operator logic permit invocation number string invocation number numeric result type string string result type corresponds precisely intended behavior overloading called ad hoc polymorphism observe handle ﬁnite number overloaded case recursive type ve seen union type pay return original recursive datatype formulation accept variant type constructor write recursive type union instance returning btnum shouldn t able equivalent btmt u btnd number btnum btnum showing btmt constructor btnd take parameter type parameter type ve written btnum built type language unsatisfactory unbound hap mean btnum btmt u btnd number btnum btnum equation obvious solution remember situation familiar recursion value ref invented recursive function constructor showed implementation circumvent problem similarly need recursive type constructor conventionally called greek letter mu write type btmt u btnd number btnum btnum binding construct bind btnum entire type written including recursive binding btnum practice course entire recursive type wish btnum btmt u btnd number btnum btnum look like circular deﬁnition notice btnum right doe depend left equation rewrite btnum btmt u btnd number t t word deﬁnition btnum truly thought syntactic sugar replaced program fear inﬁnite regress semantic level usually different way thinking meaning type bound interpreted isorecursive orequirecursive distinction subtle scope chapter material covered especially pierce s sufﬁces note recursive type treated equivalent unfolding instance deﬁne numeric list type numl mtl u consl number t mtl u consl number t mtl u consl number mtl u consl number t mtl u consl number mtl u consl number consl number mtl u consl number t differ precisely notion equality deﬁnitional equality isomorphism step simply replace rameter entire type value recursion mean consl constructor demand differently type list written union zero arbitrarily element type consists zero arbitrarily element list number ﬁts precisely type observe informal understanding provide type exercise ascribe type subtyping imagine typical binary tree deﬁnition simplicity ll assume value number write typed racket illustrate point lang mt nd v number l bt r bt bt u mt nd consider concrete tree value mt mt mt nd mt mt nd nd observe structure constructor make value type value typebt consider expression nd mt mt deﬁnition nddeclares type bt able successfully value type mt obviously coincidental deﬁned btin term mtandnd doe indicate simply checking function equality far instead checking type ﬁts notion ﬁtting called subtyping act ﬁt subsumption essence subtyping deﬁne relation usually denoted relates pair type say s t value type scan given value type ti expected word subtyping formalizes notion substitutability value type twas expected replaced value type s hold si called subtype andtthesupertype useful usually accurate subset interpretation value sare subset t expression expecting tvalues unpleasantly surprised receive svalues subtyping pervasive effect type reexamine kind type understand interaction subtyping base type ally quite obvious disjoint type like number string unrelated language base type used represent instance scripting language number merely string written special syntax language booleans merely subtyping tionships base type common consider subtyping interacts single compound type constructor fact diction type change suppose expression type normally say produce value type careful say produce value orat t produce value subtype reference type implicitly cloaked reference potential subtyping avoid pestering refrain doing wary possible make reasoning error keeping implicit interpretation mind union let union interact subtyping clearly subtype entire union running example clearly mtvalue bt likewise fornd mt bt nd bt result mt type bt enabling expression nd mt mt type type type bt general s s u t t s u t write rule twice just make clear doesn t matter union subtype say value scan thought value s u t expression type s u t contain value type intersection brieﬂy visit intersection imagine intersection behave dually s t convince subset interpretation value sandt clearly following notvalid subsumption s u t s ﬁrst valid value type ti perfectly valid element type s u t instance number member type string u number number supplied value type string expected second general value type ti value type consumer value expecting able treat tand s justiﬁed instance given overloaded t number number number function type know operate string function seen constructor function determine seen parametric datatypes edition exploring subtyping left exercise subtyping type function usually assume tions disjoint type need consider function type subtype convenience let type question expression expecting function safely function easiest think using subset interpretation consider use return value type context surrounding function application satisﬁed value type clearly use continue type similarly subset ﬁne problem value context encounter unexpected value result undeﬁned behavior word need observe direction containment entire function type called covariance vary direction precisely expected token expect covariance argument position predictable wrong let s application function providing parameter value type suppose instead substitute function type mean new function accepts value type strictly smaller set mean application free provide substituted function deﬁned resulting undeﬁned behavior avoid make subsumption direction substituting function accept input replaces need say function position contravariant go direction subtyping putting observation obtain subtyping rule function method implementing subtyping course rule assume modiﬁed respect subtyping essence subtyping rule say expression eis type s ands t ealso type sound intuitive immediately problematic reason type rule enabled write rule applies allexpressions longer sure apply level subtyping result longer obvious stop subtyping particular able calculate type expression possible type expression return wrong type error type expected context exists type expected context issue point description subtyping giving fundamentally declarative saying true showing turn algorithm actual type language interesting problem turning algorithmic subtyping actual algorithm realizes ideally type exactly program typed declarative regime sound complete object type ve mentioned earlier type object typically riven camp inal structural nominal type familiar programmer java won t say structural type object dictate object s type structured object consisting name ﬁelds type instance object method ref type number number number number future reference let s type addsub follow predictable line ﬁeld access simply ensure ﬁeld exists use declared type dereference expression method invocation ensure member exists function type far straightforward object type complicated reason book devoted topic abadi carelli s theory object important somewhat dated bruce s foundation language type semantics modern offer gentle exposition pierce cover necessary theory type self type object operation applied object outside applied inside using self mean object type recursive type access control private public restriction lead tion type object outside inside inheritance type parent object s visible inheritance path differ visible outside interplay subtyping relationship class interface language like java cost mutation cast snake plane problem simplify presence nominal type given type s determine behavior type ration effectively dictionary object s description looked demand argument favor nominal typing note java s approach way build nominal type argued java s class needlessly restricts expressive power programmer ref turn java s nominal type needlessly conﬂates type interface description implementation possible better nominal type system java s scala instance take signiﬁcant step exposition issue room limit interesting question remember said subtyping force consider type constructor structural typing object introduces object type constructor understand interaction subtyping let s make sure understand object type mean consider type addsub list method object given type obviously object just method precisely type eligible equally obviously object method matter phrase matter meant leading object represents arithmetic package contains method addition appropriate type case certainly object supply method arithmetic package certainly type addsub method simply inaccessible using type addsub let write type package type number number number number number number number number number number just argued object type allowed claim type addsub mean substituted context expecting value type addsub word just said want addsub number number number number number number number number number number number number number number momentarily look confusing ve said subtyping follows set inclusion expect smaller set left larger set right look like larger type certainly term character count left smaller type right understand sound help develop intuition larger type fewer value object method left clearly method right object method right fail left think type constraint acceptable value shape bigger type imposes constraint admits fewer value type appear wrong size set value subscribe expected size generally say dropping ﬁelds object s type obtain supertype called width subtyping subtype wider subtyping hierarchy adjusting object s width nominal world java inheritance chain class fewer fewer method ﬁelds reach object supertype class fewest class type cin java c object somewhat confusingly term narrowing andwidening used consider opposite meaning widen subtype supertype go narrower smaller wider bigger set term evolved independently unfortunately expect important form subtyping given member simply say particular member subsumed corresponding position obvious reason form called depth subtyping exercise construct example depth subtyping ﬁeld object type use width subtyping subtype ﬁeld ﬁeld function type java limited depth subtyping preferring type invariant object hierarchy safe option conventional mutation combination width depth subtyping cover interesting case object subtyping type implemented needlessly annoy programmer convenient mathematically necessary rule include ability permute name reﬂexivity type subtype convenient interpret subtype relationship ity language like typed javascript employ feature provide maximum ﬂexibility programmer checking program invariant dynamically tract system offer rich valuable way represent program invariant represent important property program veriﬁed statically furthermore devise method formal property known rice s certain property statically burden annotation computational plexity great inevitable property care ignored settled discus enforcement virtually programming language form assertion mechanism enables programmer write property richer language s static type permit language static type property start simple assertion parameter numeric instance language assertion entire programming language predicate used assertion instance implementation cryptography package want ensure certain parameter pas primality test balanced binary want ensure subtrees balanced preserve ordering contract predicate easy implement simple contract contract embodies follows use language lang plai reason better simulates programming untyped language second simplicity write assertion contract typed language ﬂagged letting behavior effect easier turn type checker contract make perfect sense typed world enhance set invariant programmer consumes value applies predicate value value pass predicate contract return value unmolested value fails contract report error behavior return supplied value error change value way short value pas predicate contact act identity function encode essence following function define pred lambda val pred val val blame violation define blame s error s s example contract define lambda n number n n typed language number check course unnecessary statically checked type function using tract suppose want make sure don t imaginary number computing square root write define x sqrt x language assertion written statement expression alternate way write define x begin x sqrt x case form clearer state crisply beginning function expected parameter enables parameter checked just language contract written function header improving information given interface applied produce applied raise contract violation error tag type observation value point ve reproduced essence assertion system language say let s suppose moment language statically typed want write assertion reproduce traditional like invariant capture standard property checking number string assuming appropriate predicate provided language fashioned one given recall simplest type language just base type like number constructed type like list vector appear challenging care mutation performance blame discus function immediately problematic working example following function define lambda f lambda x f x f x statically type number number number number consumes function produce function let suppose want guard contract fundamental problem language directly express predicate language system store limited information type limited relative type seen far use different information traditionally called tag coincide regard type instance effort preserve rich type information source program lower level abstraction way assembly language research tag identifying number speciﬁc kind number string tag identifying string forth write predicate based value tag structured value situation complex vector tag declaring vector dictating kind value element kind program usually obtain size traverse gather information said structured value ref write contract check list consists solely number define lambda l list l andmap number l andmap l note ﬁrst question need asked know statically list number similarly object simply identify object providing additional information language permit reﬂection object s structure contract gather information need language problematic encounter tions think function having type domain range function just opaque object function tag hap limited metadata function s arity hardly tell function consumes produce posed kind consumes produce one number number type problem nicely embodied misnamed typeof operator javascript given value base type like number string typeof return string effect number object return object importantly tions return function additional information reason typeof bad operator called tagof instead leaving open possibility future static type system javascript provide true typeof summarize mean point confronted function function contract check function clearly error check domain range function contract determine help recall sort guarantee contract provide ﬁrst place demanded argument negative checked actually used actual value passed instance program contains fragment lambda thunk invoked programmer contract violation fact thunk invoked run program later run program lurking contract error reason usually preferable express invariant static type use contract understand caveat notiﬁed error program suitably exercised useful insight offer solution problem function check immediately purported function value truly function instead ignoring domain range contract defer check domain contract time function actually applied value check range contract function actually return value clearly different pattern followed descriptive check immediate contract checked entirety racket contract immediate contract called ﬂat term slightly misleading protect data structure define immediate pred lambda val pred val val blame val contrast function contract take contract check domain return predicate predicate apply value purporting satisfy contract check given value actually function immediate create asurrogate procedure applies residual check domain behaves original function creation surrogate represents departure traditional assertion mechanism simply check value leaf instead tions use created surrogate want contract checking general useful wrapper consumes contract value creates guarded version value define guard ctc val ctc val simple example let suppose want wrap function numeric contract function constructor function contract deﬁned momentarily define guard function immediate number immediate number want bound essentially following code define lambda x num num x lambda x surrogate applies numeric contract invocation recall contract behave like identity function absence violation procedure precisely behavior us achieve use following deﬁnition function remember simplicity assume function extension multiple arity straightforward complex contract check relationship ensure given value truly function checked immediately check disappeared time bind surrogate define function dom rng lambda val procedure val lambda x rng val dom x blame val understand work let substitute argument resulting code readable ﬁrst construct number contract checker define num immediate number define num lambda val number val val blame val let s return deﬁnition apply guard define function num num apply function contract constructor define lambda val procedure val lambda x num val num x blame val applying give define procedure lambda x num num x blame notice immediately check guarded value function define lambda x num num x precisely surrogate desired behavior execution way violate contract way corresponding contract constructor value wrapped function wrapped value function applied value wrapped value function consumes number produce value type exercise write example perform violation observe behavior contract improve error message better distinguish case wrapping technique work define guard function function immediate number immediate number function immediate number immediate number lambda f lambda x f x f x exercise seven way violate contract corresponding seven contract constructor violate passing argument modifying code needed improve error reporting correctly identify kind violation notice nested function contract defers checking immediate tract application expect immediate contract report problem actual value report applied actual value doe mean notion olation subtle function value passed fact truly violation contract violation observed numeric value passed returned syntactic convenience earlier saw style using ﬂat contract embodied style disadvantage reminiscent traditional assertion system simply doe work value wrapped value used computation surprisingly traditional assertion system handle immediate contract fail notice subtlety style wrap use contract work theory suffers downside developer forget wrap us contract checked use wasteful use program comingles contract checking functional behavior reducing readability fortunately judicious use syntactic sugar solve problem common case instance suppose want make easy attach contract function ters developer write x immediate positive sqrt x intent guarding xwith positive performing check function invocation translate say define let x guard immediate positive sqrt x macro generates fresh identiﬁer associate given user wrapped version value supplied fresh following macro implement exactly stx stx f id c b id define f lambda let id guard c b convenience like designer contract language improve ity efﬁciency robustness contract use extending compound data structure discussed appears easy extend contract structured datatypes list vector recursive datatypes requires appropriate set observation available usually case resolution type language instance discussed ref language datatypes doe require typepredicates offer predicate distinguish variant case contract checking best left static type contact assert reﬁned structural property strategy run signiﬁcant performance problem instance suppose built balanced binary perform asymptotic logarithmic time size tree insertion lookup say wrapped tree suitable contract sadly mere act checking contract visit entire tree taking linear time ideally prefer strategy contract time construction doe need checked time lookup worse balancing ordering recursive property ple attach applied recursive insertion recursive procedure contract checked visited tree size t contract predicate applies oft oft worst visiting total oft telements making intended time insertion process linear time case ready mitigation available case value need associated intrinsically storage hash table set contract passed contract ready apply ﬁrst check value checked doe check tially form memoization contract checking reduce algorithmic complexity checking like memoization work best value immutable value mutate contract perform arbitrary computation sound perform optimization subtler way examine issue data structure example consider contract wrote earlier check value numeric list suppose wrapped list contract interested ﬁrst element list naturally paying cost checking value list long time importantly user argue reporting violation second element list violation expectation did actually use element suggests deferring checking value checked mediately instance entire list turned wrapped value containing deferred check value checked visited strategy attractive trivial code especially run problem ence aliasing different identiﬁers referring list contract guard ensure function expected usually mean store mutable state list contract observation general problem contract exacerbated complex curious earlier complained difﬁcult check function contract insufﬁcient power observe check value function real language problem data structure actually opposite ability observe instance implement strategy deferring checking list quite possibly need use structure hold actual list modify andrest value structure checking contract procedure like list return false true structure list list need procedure return true structure represent special contract list contract author need remember tackle con pair goodness know procedure perform observation general observation essentially impossible ﬁx eq normally property value eq function wrapped value function new procedure isn t eq probably shouldn t behavior truly different contract violation value supplied observe violation mean program surreptitiously guard act guarding observed result malicious module detect passed guarded value behaving normally abnormally contract mutation rightly concerned interaction contract mutation contract inherently deferred implemented deferred fashion thing concerned storing contracted value mutable state writing contract mutable state store contracted value strategy wrapping ensures contract checking work gracefully stage contract check value hand creates wrapped value embodying residual check wrapped value stored mutable state retrieved use later contains check performed value eventually used issue writing contract mutable data box vector case probably create wrapper entire datatype record intended contract value inside datatype replaced new operation performs retrieve intended contract wrapper apply value store wrapped value requires changing behavior data structure mutation operator sensitive contracted value mutation doe change point violation caught right away immediate contract appropriate use deferred one combining contract ve discussed combinators basic datatypes s natural discus combining contract just saw union ref intersection ref type considering union intersection respectively s s matter consider negation contract cially like type consider question light contract try map meaning learned type sphere tract immediate case straightforward union contract combine predicate result literally combined intersection contract conjunction apply predicate turn circuiting generate error return contracted value intersection tract combine conjunction negation contract simply original immediate contract applied decision negated contract combination harder deferred case stance consider negation function contract number number exactly doe mean negate doe mean function notaccept bers doe produce particular enforce contract instance check function doe accept expecting given number produce error consider identity function wrapped contract clearly doe result error given number value doe mean wait produce value doe produce number reject worst note mean running function domain notdeﬁned sure recipe destroying program invariant polluting heap crashing program intersection contract require value pas mean wrapping value check domain range failing meet mean value failed entire intersction union contract subtle failing meet ground rejection simply mean longer candidate contract representing wrapped value candidate left reject value mean implementation union contract maintain memory case sophisticated term use mutation fails removed list candidate language like racket requires lock avoid race remaining one continue applied candidate remain contract report violation error report presumably provide actual value eliminated keeping mind nested multiple function deep implemented version contract constructor combinators racket place restriction acceptable form enable implementation efﬁcient yield useful error message furthermore extreme situation discussed rarely occur know need blame let s return issue reporting contract violation don t mean string print important question report really semantic consideration illustrate problem recall deﬁnition assume running contract checking suppose apply function entirely inappropriate consumes produce number simply produce value define observe succeed contract checking mediate portion function contract recognizes function suppose apply number ought able contract violation expected string given notice error report deep inside body hand tirely legitimate improper application occurred fault fault body code supplied purportedly legitimate function number number code did long ﬂed scene longer stack outside ambit traditional mechanism problem peculiarity fact routinely occurs large tems system especially graphical network external interface make heavy use callback function method register entity invoked signal status value moral equivalent graphic layer callback plied stored eventually layer invokes callback result error fault given purportedly right norof callback presumably legitimate us improperly supplied function fault entity introduced entity point stack tains callback guilty party longer present kind error extremely difﬁcult debug solution extend contract incorporate notion blame idea effectively record introduction resulted pair component coming contract violation occurs ascribe failure expression did introduction observe really interesting context function consistency extend blame immediate contract natural way function notice possible point failure given wrong kind value produced wrong kind important distinguish case case blame particular actual parameter case assuming parameter passed muster blame function natural extension immediate value blame value satisfying contract akin contract introduce term positive andnegative position function negative position positive appear needless extra terminology soon term general meaning generalize parameter consumed contract previously mediate contract consumed predicate function contract consumed domain range contract case return function argument label positive negative position label drawn reasonable datatype abstract syntax node buffer set description simplicity use string function contract close label program position later blame provider invalid function theguard function responsible passing label tract application location define guard ctc val po neg ctc po neg val let blame display appropriate label pas contract implementation define blame s error s suppose guarding use useful name positive negative position positive position failure blamed body negative position failure blamed parameter define guard function immediate number immediate number body input provided guard expect error condition location really failure surely parameter blamed application failed function show really stretching term term positive provides useful alternative trust implementation produce number expect impossible fail expect expression like x trigger error presumably signaling contract error location input contrast guarded function violates define guard function immediate number immediate number string body input expect blame ascribed body let implement contract constructor immediate tract seen blame ascribed positive position define immediate pred lambda po neg lambda val pred val val blame po function tempted write define function dom rng lambda po neg lambda val procedure val lambda x dom val rng x blame po fails work fundamental way violates expected signature contract contract expect given label positive negative position mean dom andrng used hint using po neg body seen example expect position bound negto blamed instead clearly instantiate domain range contract using po andneg know remember potentially violating function applied obvious reaction instantiate contract constructor value domandrng define function dom rng lambda po neg let dom po neg rng po neg lambda val procedure val lambda x val x blame po signature match run contract answer little strange instance simplest contract violation example x contract body maybe expand code happened x guard function immediate number immediate number body input function immediate number immediate number body input let immediate number body input immediate number body input lambda x x let lambda val number val val blame body lambda val number val val blame body lambda x x poor stood chance blame label left body thing blamed return problem moment observe code real trace function contract left immediate tract ready blame actual value occur perfectly consistent said earlier ref able observe immediate value course true function function longer true went wrong notice contract bound ought ing body contrast contract bound ought blaming input s domain position function contract positive negative label swapped consider case key insight applying function taken parameter outside come inside vice versa body positive caller function differentiate putting function s body positive position body negative position domain contract nested function contract cause positive negative position swap range need swap consider function return represents derivative given number representing point calculate derivative return number derivative point negative position function client us derivative positive position body responsible generating derivative result obtain updated correct deﬁnition function tor define function dom rng lambda po neg let dom neg po rng po neg lambda val procedure val lambda x val x blame po exercise apply earlier example conﬁrm expected blame expand code manually happens suppose deﬁne label body positive position input negative say supply function string patently doe compute derivative apply result guard function immediate number immediate string string s body s input correctly indicates blame ascribed expression fed string supposed numeric function exercise apply allthe relevant violation example conﬁrm resulting blame accurate happens supply number function contract indicating map string number supply function contract alternate application semantics long ago ref considered question substitute performing application ready consider alternative time suggested just alternative fact understand answer question f x f x f x f x ﬁnd fragment syntax wildly different behavior instance distinction mentioned variation evaluated variation time evaluated fis run variation value xﬂow strictly caller callee ﬂow opposite direction lazy application let s start considering parameter reduced value stitute formal parameter value actual parameter actual parameter expression deﬁne define sq x x x invoke sq doe reduce called eager application lazy course don t people use term strict arcane terminology evaluation evaluation versus represent technical distinction concludes return deﬁning interpreter substitution useful think substitution design principle lazy application example lazy alternative distinguished history instance true calculus us returned fore programming experiment considering happen certain operator did evaluate argument application value needed instance consider deﬁnition define one con one ordinary racket clearly one deﬁned left try evaluate right result error try evaluate actually need time deﬁnition rest obtains one produce inﬁnite list ve glossed lot need explaining doe one rest position con evaluate copy expression result word simply created inﬁnitely unfolding list created actually cyclic depends good language mutation doe modify cell resulting list mean observe difference implementation unfolded version mutating affect cyclic changing affect language mutation argue represent lazy unfolding actual cyclic datum discussion mind resolve right let examine lazy evaluation little return question ref value return core function interpreter ref recall kind value number closure want support lazy evaluation instead need ask happens function application exactly passing obvious lazy application semantics need pas pressions moment s thought show problematic expression contain identiﬁer name don t want accidentally bound truly identiﬁers notvariables ref instance suppose define f x lambda y x y apply follows f x produce clearly error reporting xas bound let s trace ﬁrst application creates closure xi bound bind yto x result expression x x environment xi bound result answer error subtle assumption yes ve assumed argument return numeric swers behaves lazily study issue moment theless central point remains careful erroneous expression produce kind valid answer error case think entirely problem erroneous program treated specially ﬁrst scan program source free identiﬁers use f let x f x produce expect produce result probably substitute xinside arithmetic expression instead example hold key solution example problem ostensibly arises use environment instead use substitution xin application substituted soon encounter let result expect fact note argument hold earlier used substitution occurrence xwould signaled error short make sure implementation match substitution doesn t sound familiar word solution bundle argument expression ment create closure closure parameter effectively thunk demonstrates function us substitute name value defer substitution letis thunk established valuable right section show true use existing function represent thunk instinct tell better use different data representation logically different purpose closv closure one deed wise separate place critical tell apart conclude discussion new set value value numv n number closv arg symbol body exprc env env suspendv body exprc env env ﬁrst variant exactly new discussed effectively procedure type suggests cause evaluation let return discussing arithmetic expression evaluating lazy application interpreter return number thing including suspendv way suspended computation cascade suspended legitimate write expression written environment free identiﬁers doesn t need environment s limiting case program return immediately answer thunk representing suspension computation clearly force suspension lifted lifting suspension mean course evaluating body stored environment expression position undo suspension called strictness point obvious ness point interactive environment s printer user clearly use environment did wish answer embody act lifting suspension procedure strict define strict v value value value v numv n v closv b e v suspendv b e strict interp b e returned value guaranteed suspendv imagine printer wrapping strict result evaluating program obtain value print impact using closure represent suspended computation deﬁnition strict depends crucially able distinguish deferred closure conﬂated guess closure fail process incorrectly error thunk numeric value residing inside process accidentally force thunk prematurely short need ﬂag thunk telling internal clarity interpreter us separate variant let return interaction strict interpreter tunately deﬁned thing cause inﬁnite loop act trying interpret addition creates suspension strict try undo forcing interpreter interpret addition clearly expression simply suspend computation instead limit suspension application sufﬁces rich power laziness making language absurd interpreter usual deﬁne interpreter case define interp expr exprc env env value exprc expr number easy value point needlessly ing numc n numv n similarly remain lamc b closv b env identiﬁers just return bound idc n lookup n env argument arithmetic expression usually deﬁned strictness point simply implement actual arithmetic plusc l r strict interp l env strict interp r env multc l r num strict interp l env strict interp r env finally application instead evaluating argument position suspend function position strictness point wouldn t know function apply continue computation appc f local define strict interp f env interp bind suspendv env s adding new kind answer inserting call strict replacing interp suspendv argument position application turned eager application interpreter lazy application small change enormous impact program write thorough examination impact study haskell lang lazy language racket exercise instead replace identiﬁer case strict lookup n env wrapped strict result looking identiﬁer impact language consider richer language data structure exercise construct program produce different result lazy evaluation eager evaluation program text different answer case try make difference interesting return suspendv doesn t instance doe terminate produce error doesn t instrument interpreter count number step turn answer program produce answer uation strategy doe strategy step laziness mutation virtue lazy evaluation defers execution usually good thing enables build inﬁnite data structure avoids computation essary unfortunately change computation occur particular change order computation evaluate relative depending strictness point encountered result programmer greatly lose predictability ordering course problem expression perform tation operation extremely difﬁcult predict value program compute relative eager version result core lazy language free mutation haskell tion state operation introduced variety mechanism monad andarrows ultimately introduce ability strictly sequentialize code sequentiality essential able predict order execution result operation program structured number dencies small furthermore haskell type attempt reﬂect operation type programmer easily reason effect caching computation ve concluded lazy computation mutation observe pleasant consequence dare say given ﬁxed environment pression produce answer result cache value expression ﬁrst forced answer strictness return cached value subsequent attempt compute course form memoization sound expression return value time assumed fact compiler aggressively hunt us expression different part program relevant part environment conﬂate evaluation strategy evaluating suspended computation time needed called caching result reactive application consider expression like evaluate return single number representing current time instance stare value represents time function application occurred doe stay current motivating example timer suppose trying implement timer measure elapsed time ideally like write program let start start javascript write d new date start current elapsed current start machine racket expression value elapsed javascript evaluate small number program sent onemeasure elapsed time second invocation procedure get current time give instanteous time split actual timer language build actual timer create instance sort timer object install callback time clock tick timer operating callback callback responsible updating value rest hopefully doing globally consistently returning value return operating agnostic doe care application callback forced perform action mutation javascript instance var timerid null var elapsedtime function doeverysecond elapsedtime elapsedtime function starttimer timerid setinterval doeverysecond assuming html page id named curtime onload callback invokes starttimer alternative spaghetti code application program repeatedly poll operating current time calling frequently waste resource calling infrequently result incorrect answer just right resolution need timer signal ﬁrst place possible create polling loop regular event timer impossible accurately unpredictable behavior user input frequency general predicted writing loop pollutes program s structure force developer sustain extra burden solution demonstrates inversion control stead application program calling operating operating charged calling application program reactive behavior deeply nested inside display expression instead brought value drive computation fundamental cause world control program external stimulus program run intrinsic program expression callback type word characteristic signature speak pattern manifest type cause operating agnostic program s value callback usually return type generic status indicator value typed language type usually word instance fragment guilibrary java interface changelistener extends eventlistener void statechanged changeevent e interface actionlistener extends eventlistener void actionperformed actionevent e interface mouselistener extends eventlistener void mouseclicked mouseevent e void mouseentered mouseevent e s ocaml mainloop unit unit closetk unit unit destroy unit update unit unit pack list unit grid b list unit haskell letter extra space select selecting w event w io mouse reactive w event w eventmouse io keyboard reactive w event w eventkey io resize reactive w event w io focus reactive w event w bool io activate reactive w event w bool io case presence void type clearly indicates function return interesting value purpose mutate store mean rich mean nesting possible composition operator statement sequencing type reveal forced away able write nested expression reader course familiar problem earlier discussion web programming problem occurs server statelessness ref client ref server able use continuation address problem continuation available language implementing onerous furthermore tricky set just right continuation pas callback instead explore alternate solution alternative reactive language consider frtime pronounced father time language drracket run drracket select language language menu writing lang frtime provide interesting interaction window expression interaction window small number let start start fact try expression frtime exactly like traditional racket bind additional identiﬁers instance provides value bound second type interaction prompt interesting second later second later kind value called behavior value change time haven t written callback code current behavior used computation instance write second second evaluates expression try interaction prompt second modulo second modulo second identity modulo second identity behavior sticky behavior enclosing expression thanks evaluation model time second update entire application happens afresh result written seemingly simple expression explicit control program loop word having explored application semantics argument evaluated evaluated zero time evaluated time necessary entire corresponding function sequence reactive value inside expression longer need brought outside reside nested inside expression giving programmer natural mean expression style evaluation called dataﬂow orfunctional reactive programming historically dataﬂow tended refer language function functional reactive language support function implement transparent reactivity programmer inject reactive behavior program s evaluation needing make syntactic change context virtue making easy inject reactivity existing program make evaluation cost model complex programmer language programmer instead itly introduce behavior appropriate primitive trading convenience greater predictability frtime s sister language flapjax extension javascript provides mode flapjax web site implementing transparent reactivity make existing language implement transparent reactivity naturally alter semantics function application step rewrite reactive function application complex form complex form enables reactive update dataﬂow graph construction essence making application reactive simple explain aring assume deﬁned new constructor behavior constructor take thunk represents computation perform time argument update value expression depends value produce store current value behavior expression like f x y turn behavior x behavior y behavior f x y x y f x y assume given constant behaves identity function let look example using deﬁnition consider trivial case parameter behavior desugars behavior behavior behavior number behavior reduces precisely like reﬂects important principle behavior present program behave exactly did version language compute second expands behavior behavior second behavior second second second second behavior reduces behavior second second expression depends see argument behavior making property sticky argued exercise way did desugaring depend eager evaluation dataﬂow graph update course simply constructing behavior value key additional information extra argument behavior language ﬁlters argument behavior second register new behavior depends existing one registration process creates graph behavior expression dependency known dataﬂow graph reﬂects path data need ﬂow program did evaluate behavior evaluation simply produce answer graph created behavior dencies evaluation produce traditional answer behavior value dependency recorded practice useful track tive behavior actually necessary avoid unnecessarily evaluating primitive behavior program refers short program execution generates dataﬂow graph need special new evaluator language instead embed semantics traditional evaluation dataﬂow propagation algorithm begin execute time primitive behavior change algorithm applies stored thunk obtains new value store signal behavior dependent instance second update tiﬁes second expression s behavior behavior evaluates thunk second add newest value second making new value expect evaluation order discussion present simple view graph update consider following program second second program primitive behavior second construct second entire expression expect expression true second date depending order handle update update expression doe second suppose old value second new node second storing old value updated hold mean compare false making expression return value simply ensued static description situation called glitch easy solution avoiding glitch example illustrates theorem sufﬁcient topologically sort node node processed depends updated danger seeing outdated inconsistent value problem difﬁcult presence cycle graph case need special recursion operator initial value cyclic behavior make possible break cyclic dependency reducing evaluation process deﬁned say evaluation dataﬂow language treatment conditionals dual notion behavior discrete like hope read literature reactive language learn topic exercise earlier picked haskell library fair reactive solution shown enunciated haskell lazy evaluation make form evaluation relatively easy support implement reactive evaluation using laziness backtracking application reason application occur multiple time search tree language s application semantics attempt satisfy search succeeds return information success fails retries application hope succeeding course assumes program written term choice tried search succeeds central operation language backtracking application semantics disjunction variety reason language include conjunction negation problematic usual rule boolean algebra don t apply searching satisfaction easiest problem backtracking search term simple valued goal boolean variable ﬁnding satisfying assignment sitional formula computationally challenging performance perspective extremely important variety problem consider look numerous us sat solver version problem given boolean constant variable need determine truth formula mildly interesting help set actually interesting general case special case just draw truth table won t work general given formula conjunction disjunction constant representing truth falsity goal determine formula evaluates truth falsity want minimize computation discover want return quickly possible context depends instance evaluating conjunction discover false like entire term false right familiar notion evaluation conditionals want generalize discovers truth falsehood matter enclosing expression reported stack quickly general computation parameterized receptacle report truth current term discovered report falsity discovered avoid complication pending function call furthermore expect value supplied parameter continuation value return right context quickly possible stead scrutinized intermediate level evaluation don t care result continuation currently interesting value communicate continuation invoked supply information bit representing truth falsehood default continuation expect argument supply symbol indicates know easiest value truth falsity recall expression consume continuation called success andfailure continuation invoke deﬁnitive value value truth invokes success ation falsity failure define truth define falsity let examine disjunction simplicity assume sion like computation disjunction backtracking search consume success failure continuation define lambda success failure simplest conceptually think setting local continuation pas andfail supply evaluation recursively descendent succeeds control return context creation pas failure return fail return pas know ﬁrst ceeded matter disjunction hold return control continuation success invocation pas mediately trigger success contrast suppose try fail deﬁned sequence try expectation control simply return way trying need worry pas andfail failure success failure entire disjunction form tail position success failure continuation expression result obtain success pas begin fail pas fail success failure control return context creating pas invokes success control return continuation creating fail statement sequencing symmetric reasoning dual program define lambda success failure failure fail begin pas pas fail success failure convert response simple testable value write convenient little wrapper define run t escape t lambda v escape lambda v escape construct test case test run falsity falsity test run falsity truth truth falsity truth falsity truth